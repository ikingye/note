'use strict';(function(){const indexCfg={cache:true};indexCfg.doc={id:'id',field:['title','content'],store:['title','href'],};const index=FlexSearch.create('balance',indexCfg);window.bookSearchIndex=index;index.add({'id':0,'href':'/note/docs/live/diary/2020/03/31/','title':"2020-03-31",'content':"2020 年 3 月 31 日（星期二） 今日待办  xxx   语言 滥觞 lànshāng 浮起酒杯。喻事情的开始\n夫江始出于岷山,其源可以滥觞。——《孔子家语·三恕》\n社会 内卷化（网络）  靠极端剥削、压榨自己，从而在社会获得少量的竞争优势 明明可以有更加轻松，效果还更好的选择，却仍旧在旧有的选择中不断投入各类资源，以及由此产生的各种现象 不改变生产方式，不提高技术水平，而是靠极端剥削、压榨本国的劳动力在国际市场获得竞争优势  举一个很简单的例子：\n假定某省考生数量，录取名额不变，即录取率不变。\n现在有一所学校，甲校要求高中生每天学习 14 个小时，寒暑假和双休日补课。这一操作的效果是在短期内提高了甲校的录取率。\n这种录取率提升的甜头让乙、丙、丁校羡慕，于是均决定向甲校学习，推行甲校的教学管理模式。\n由于担心甲、乙、丙、丁校录取率的上升导致某省其余中学的录取率相对下降，于是该省其余学校也不得不采取跟进策略，学习和推广甲校的教学管理模式。\n最终，某省所有中学都开始强迫学生一天学习 14 个小时，取消寒暑假和双休日。\n于是，由于全省均采用甲校的模式，各个学校的考分尽管普遍上涨，在高考录取率不变的前提下，各个学校的录取率与推广甲学校模式之前相差无几（比如，原来一本线是 550 分，由于学生成绩普遍提高，一本线上调至 590 分，导致各个学校录取率与推广甲校之前无异）。\n在这一过程中，为提高分数，中学生不得不投入更多的学习时间和资源。由于该省高考录取分数线提高，单个学生的分数看似提高，但从录取结果看，这种投入没有意义。这就是所谓的分数增长，但学生考取好大学的几率没有实质增长，即 “没有发展的增长”—— 内卷化。\n内卷化（学术） 从词源来看，“内卷化” 一词的英文为 involution, 它源于拉丁语 involutum, 原意是 “转或卷起来”。\n从起源看，“内卷化”（involution）滥觞于顶顶大名的大哲学家康德，他初步区分了内卷化（involution）和 “演化”（evolution），随后学者 Alexander Goldenweiser 借用该概念描述 “一种内部不断精细化的文化现象”。\n真正把 “内卷化” 这一概念发扬光大的是人类学家 Clifford Geertz 和经济史学家黄宗智。\n1963 年，Clifford Geertz 出版了一部研究印度尼西亚的著作 ——《农业的内卷化 (agricultural involution)：印度尼西亚生态变迁的过程》。他在研究中发现，在殖民地时代和后殖民地时代的爪哇，农业生产长期以来原地不动，未曾发展，只是不断地重复简单再生产。\n针对这一现象，Clifford Geertz 借用了 “内卷化” 的概念，即 “一个既有的形态，由于内部细节过分的精细而使得形态本身获得了刚性”, 以刻画印度尼西亚爪哇地区 “由于农业无法向外延扩展，致使劳动力不断填充到有限的水稻生产” 的过程 。\n著名的经济史学家黄宗智教授在其著作《华北的小农经济与社会变迁》和《长江三角洲小农家庭与乡村发展》中借用了 Clifford Geertz 的概念。\n他在考察明清以降，中国经济发展与社会变迁时指出，当时普遍存在的现象是农民通过在有限的土地上投入大量的劳动力来获得总产量增长的方式，但是这种方式却是边际效益递减的，是一种没有发展的增长，即 “内卷化”。\n按照黄教授的说法，“内卷的要旨在于单位土地上劳动投入的高度密集和单位劳动的边际报酬减少”。\n在《华北的小农经济与社会变迁》一书中，黄教授认为 “内卷化” 有两层含义：\n一是家庭农场因为耕地面积过于狭小，为了维持生活而不得不在劳动力边际回报已经降到极低的情况下继续投入劳力，以期增加小农农场总的产出；\n二是发展不足的经营式农场和小农经济结合在一起，形成的一种特别顽固、难以发生质变的小农经济体系。\n在《长江三角洲小农家庭与乡村发展》中，黄教授指出，即使在长三角当时这样商品经济其实很发达的的地区，商品经济反而促进了 \u0026quot; 小农经济” 的内卷化发展，而非像英国那样 “向资本主义过渡”。\n实际上，黄教授使用这一概念，描绘的是小农经济的顽固性，要回答的问题是：为什么中国小农经济始终没有过渡到资本主义经济，即使有，也始终是 “资本主义萌芽”？\n进而，这一概念要回答的是：\n为什么中国与西方在近代走上了不同的路，即中国继续在传统的小农经济中固守，而欧洲则通过工业革命提高了单位劳动生产率，最终走上了以机器大生产为核心的现代化道路？\n如今，这一概念进一步拓展，延伸到了政治学等领域。例如，学者杜赞奇在其著作《文化、权力与国家 ——1900-1942 年的华北》中提出了 “国家政权内卷化” 概念。\n该书以微观视角对清末新政到日本控制华北这一时间段的华北农村社会进行分析。他阐述了国家政权现代化与乡村社会文化网络互动的议题。\n具言之，清末新政后，在国家内卷化的冲击下，国家政权通过融入乡村文化网络与乡村社会良性互动的控制模式遭到破坏，这种依赖传统文化网络的良性互动遭到破坏后，对乡村造成巨大冲击，国家政权再也无法像 20 世纪之前一样对乡村进行有效控制。\n他实际证明了 20 世纪前期的中国国家政权，如果离开或破坏文化网络以控制乡村社会的企图是注定要失败的。\n因此，杜赞奇利用这一概念实际上是表达：国家机构不是靠提高旧有或新增（此处指人际或其他行政资源）机构的效益，而是靠复制或扩大旧有的国家与社会的关系 —— 如中国旧有的赢利型经纪体制 —— 来扩大其行政职能。\n总体来说，“内卷化” 是一个描述性概念，并非成熟的理论，“内卷化” 出现的原因并未得到进一步解答。\n 参考：\n 何为「内卷化」？有什么通俗易懂的内卷化的例子？  "});index.add({'id':1,'href':'/note/docs/live/diary/2020/05/31/','title':"2020-05-31",'content':"2020 年 5 月 31 日（星期日） 今日待办     编程 Service Mesh Comparison "});index.add({'id':2,'href':'/note/docs/study/docs/office/excel/','title':"Excel",'content':"Excel "});index.add({'id':3,'href':'/note/docs/study/docs/office/ppt/','title':"PPT",'content':"PPT "});index.add({'id':4,'href':'/note/docs/study/docs/office/word/','title':"Word",'content':"Word "});index.add({'id':5,'href':'/note/docs/study/docs/storage/imagehost/','title':"图床",'content':"图床 图床选择 GitHub + jsdelivr 上传图床软件 PicGo 参考官网：https://github.com/Molunerfinn/PicGo\nvs-picgo https://github.com/PicGo/vs-picgo\n"});index.add({'id':6,'href':'/note/docs/humanities/movie/others/Merrage-Story/','title':"婚姻故事",'content':"婚姻故事 —— 不容易 豆瓣\n"});index.add({'id':7,'href':'/note/docs/humanities/movie/favorite/','title':"我的最爱",'content':"a\n"});index.add({'id':8,'href':'/note/docs/live/parenting/appendix/tutorial/','title':"教程",'content':"教程 基础 进阶 高阶 "});index.add({'id':9,'href':'/note/docs/study/docs/note/','title':"笔记",'content':"笔记 "});index.add({'id':10,'href':'/note/docs/live/parenting/basic/','title':"第一部分 基础入门",'content':""});index.add({'id':11,'href':'/note/docs/live/parenting/basic/practice/spec/','title':"编程规范",'content':"编程规范 "});index.add({'id':12,'href':'/note/docs/humanities/movie/doubantop250/The-Shawshank-Redemption/','title':"肖申克的救赎",'content':"肖申克的救赎 —— 自由 豆瓣\n"});index.add({'id':13,'href':'/note/docs/live/diary/2020/04/30/','title':"2020-04-30",'content':"2020 年 4 月 30 日（星期四） 今日待办     编程 网络 增加组播路由 使用 route 命令添加\n使用 route 命令添加的路由，机器重启或者网卡重启后路由就失效了，方法：\n# 添加到主机的路由 route add –host 192.168.168.110 dev eth0 route add –host 192.168.168.119 gw 192.168.168.1 # 添加到网络的路由 route add –net IP netmask MASK eth0 route add –net IP netmask MASK gw IP route add –net IP/24 eth1 # 添加默认网关 route add default gw IP # 删除路由 route del –host 192.168.168.110 dev eth0  OCR 光学字符识别（Optical Character Recognition, OCR）\n参考：\n OCR 文字识别用的是什么算法？   Kubernetes Pod 驱逐机制 在 kubernetes 里，pod 的驱逐机制分为 kubelet 驱逐（被动驱逐）和主动驱逐两种。\n在 node 节点的资源紧缺的条件下，kubelet 为了保证 node 节点的稳定性，回触发主动驱逐 pod 的机制\n 算法 二叉树转化成双向链表 两个有序链表合并 二叉树的层次遍历 如何判断一棵二叉树是否为另一棵二叉树的子树  操作系统 什么是死锁？如何预防死锁  Redis 数据结构 持久化  TCP / IP 滑动窗口 Socket 网络编程  HTTP Post vs Get  epoll epoll vs select 边缘触发，水平触发 Linux 查看进程的内存分布 "});index.add({'id':14,'href':'/note/docs/live/diary/2020/05/30/','title':"2020-05-30",'content':"2020 年 5 月 30 日（星期六） 今日待办     编程 华为 5G 边缘计算 CSP Edge 现在使用 Kubernetes，原来是 CSP Edge\ncommunicationsservice provider (CSP)\n 5G 时代的运营商 5G MEC 将云计算和 5G 核心网带到网络边缘，带来了新的流量模型和部署模型。 如果运营商还继续采用 4G 移动承载网的设计思路，在 5G 时代，运营商网络将面临边缘计算的困局。\nMEC 使运营商能在网络边缘分流业务， 通过端到端整体方案为客户提供更低时延、更高带宽、更低成本的业务体验， 快速响应用户请求并提升服务质量。\n"});index.add({'id':15,'href':'/note/docs/live/diary/2020/06/30/','title':"2020-06-30",'content':"2020 年 6 月 30 日（星期二） 今日待办     编程 Go GMP 调度器 "});index.add({'id':16,'href':'/note/docs/study/docs/note/hugo/theme/academic/','title':"hugo-academic",'content':"Academic 配置 写博客 hugo new \u0026ndash;kind post post/my-post\n"});index.add({'id':17,'href':'/note/docs/study/docs/type/markdown/','title':"markdown",'content':"markdown 图片大小设置 \u0026lt;img src=\u0026quot;xxx\u0026quot; width=\u0026quot;30%\u0026quot; height=\u0026quot;30%\u0026quot;\u0026gt;\n"});index.add({'id':18,'href':'/note/docs/live/parenting/appendix/interview/basic/','title':"基础",'content':"基础面试题 "});index.add({'id':19,'href':'/note/docs/live/parenting/design/','title':"第二部分 设计",'content':""});index.add({'id':20,'href':'/note/docs/humanities/movie/doubantop250/','title':"豆瓣电影 Top 250",'content':"a\n"});index.add({'id':21,'href':'/note/docs/live/parenting/appendix/interview/advanced/','title':"进阶",'content':"进阶面试题 "});index.add({'id':22,'href':'/note/docs/study/docs/note/hugo/config/','title':"配置",'content':"Hugo 配置 参考：https://themes.gohugo.io/hugo-book\n"});index.add({'id':23,'href':'/note/docs/live/parenting/appendix/interview/','title':"面试题",'content':"面试题 基础题 进阶题 高阶题 "});index.add({'id':24,'href':'/note/docs/live/diary/2020/04/29/','title':"2020-04-29",'content':"2020 年 4 月 29 日（星期三） 今日待办     编程 docker 权限 docker run # 无法使用 gdb 调试 --cap-add SYS_PTRACE # 无法使用 date -s 修改时间 --cap-add=SYS_TIME # –privileged 等效于–cap-add=ALL 参考：\n 使用 docker run \u0026ndash;cap-add 参数解决权限问题（无法使用 gdb 调试、无法 date -s 修改时间)  insecure-registry # vi /etc/docker/daemon.json { \u0026#34;insecure-registries\u0026#34; : [ \u0026#34;hostname.cloudapp.net:5000\u0026#34; ] } # 参考：https://stackoverflow.com/questions/42211380/add-insecure-registry-to-docker # 重启 docker systemctl restart docker  面试 字节头条面试要求  算法、数据结构和系统设计 提前温习软件工程的核心概念，  例如：如何从一个需求落实到一个系统设计，如何衡量两个不同设计的好坏，如何在各种限制下（人员、时间、资源等）选择其中更合适的设计，以及提升该设计的可拓展性等。​   在白板上练习算法题目，写出清晰、简洁、bug free 的代码，，并衡量时间和空间复杂度以及可能存在的副作用。​ 尝试用不同的方法，思路或数据结构去解决同一个问题，并且衡量不同解法之间的优劣。​ 练习  《Cracking the Coding Interview》​ https://leetcode.com/​ http://highscalability.com/    后台开发要求  高并发、高可用、高安全、可伸缩的后台系统 软件知识结构全面，基础扎实，较好的数据结构运用能力、较强的算法设计和逻辑思维能力； 熟悉 linux 操作系统，了解 Shell，熟练使用 linux 系统下的 C++、Java、nodejs 或 Go 优先； 熟悉 MYSQL 或其他大型数据库，能够快速根据需求完成高性能数据库设计，有网络系统的开发经验； 有海量数据处理相关开发经验者优先，如 Hadoop、Spark 等； 掌握 WEB 后端开发技术：协议、架构、存储、缓存、安全等；  架构师要求  具备丰富的架构设计经验，能够准确、全面的理解业务，并根据业务发展设计合理的架构方案； 具备海量数据和大规模分布式系统的设计和开发经验； 具备质量管理和质量分析能力，熟悉相关方法论和管理工具； 良好的产品意识，能够做到技术和产品相结合，从设计到实现始终对齐业内一流产品水准； 具备良好的沟通能力、组织能力及团队协作精神； 负责过多条业务线或整个产品线的业务架构工作，组织过中等以上规模项目者优先； 对多种数据库中间件、消息中间件及其他大规模分布式系统的基础架构组件有深入理解者优先； 熟悉公有云，私有云，虚拟化，容器化部署者优先。   GPU nvidia-smi\n+-----------------------------------------------------------------------------+ | NVIDIA-SMI 418.116.00 Driver Version: 418.116.00 CUDA Version: 10.1 | |-------------------------------+----------------------+----------------------+ | GPU Name Persistence-M| Bus-Id Disp.A | Volatile Uncorr. ECC | | Fan Temp Perf Pwr:Usage/Cap| Memory-Usage | GPU-Util Compute M. | |===============================+======================+======================| | 0 Tesla P4 On | 00000000:3B:00.0 Off | 0 | | N/A 28C P8 6W / 75W | 0MiB / 7611MiB | 0% Default | +-------------------------------+----------------------+----------------------+ | 1 Tesla P4 On | 00000000:86:00.0 Off | 0 | | N/A 37C P0 23W / 75W | 2598MiB / 7611MiB | 0% Default | +-------------------------------+----------------------+----------------------+ | 2 Tesla P4 On | 00000000:AF:00.0 Off | 0 | | N/A 37C P0 23W / 75W | 619MiB / 7611MiB | 0% Default | +-------------------------------+----------------------+----------------------+ | 3 Tesla P4 On | 00000000:D8:00.0 Off | 0 | | N/A 30C P8 6W / 75W | 0MiB / 7611MiB | 0% Default | +-------------------------------+----------------------+----------------------+ +-----------------------------------------------------------------------------+ | Processes: GPU Memory | | GPU PID Type Process name Usage | |=============================================================================| | 1 2693 C bin/car 1943MiB | | 1 2783 C bin/car 645MiB | | 2 3971 C bin/car 609MiB | +-----------------------------------------------------------------------------+  产品 logo vs icon logo A logo is a graphical element like an ideogram and/or a carefully arranged typeface that together forms a trademark or a brand.\nA logo can be just an emblem, just a wordmark, or it can encompass both – often the formula for a strong visual brand identity is emblem + wordmark = logo.\nicon An icon (no no, not the religious kind) is a visual representation of a concept or action. We use icons to bridge the understanding of abstract analogies and practical use.\n参考：\n ICON vs LOGO : understanding the difference 微博标识下载   素材 Iconfont - 阿里巴巴矢量图标库\n阿里巴巴图标素材库，数量大，种类全，可自由变换颜色，可选择 PNG，SVG 以及 AI 3 种格式。\n 学习 课程搜 "});index.add({'id':25,'href':'/note/docs/live/diary/2020/05/29/','title':"2020-05-29",'content':"2020 年 5 月 29 日（星期五） 今日待办     编程 OpenYurt alibaba/openyurt 阿里云原生团队表示，使用 OpenYurt （Yurt，/jɜːrt/，蒙古包）作为本次开源项目名称，期望以其 “形” 来表示边缘计算侧重于创建一个集中管理但物理分布的基础设施，并支持自动 / 自治运行操作的含义。\n"});index.add({'id':26,'href':'/note/docs/live/diary/2020/06/29/','title':"2020-06-29",'content':"2020 年 6 月 29 日（星期一） 今日待办     编程 Kubernetes Pod 重启原因 标签 vs 注解 annotations\n 算法 数组中，所有的数都是 2 个，只有一个数是 1 个 按位异或，结果为这个数\n 相同的两个数按位异或，等于 0 0 与任何一个数按位异或，等于这个数  数组中，所有的数都是偶数个，只有一个数是奇数个（2n + 1） 按位异或，结果为这个数\n数组中，所有的数都是偶数个，只有两个数是奇数个 （2n +2） 按位异或，看结果的二进制表示，得知奇数个的两个数，不同的位是哪些 （结果的二进制表示值为 1 的位，就是不同的）， 按结果任意一个不同的位进行分组，就可以分成两组，然后分别再异或，就得到结果\nif num \u0026amp; (1 \u0026lt;\u0026lt; n): print(\u0026#34;num 的第 n 位是 1\u0026#34;) else: print(\u0026#34;num 的第 n 位是 0\u0026#34;) 3n +1, 3n +2, an +b TODO\n 位运算 C 语言 C 语言中\n优先级从高到低，依次为～、\u0026amp;、^、|\nPython a = 60 b = 13 a \u0026amp; b # 12 a | b # 61 # 按位异或 a ^ b # 49 # 按位取反 (~x 相当于 -x - 1) ~a # -61 (即 -60 - 1) # 左移 1 位，相当于乘以 2 a \u0026lt;\u0026lt; 2 # 240 # 由移 1 位，相当于除以 2 a \u0026gt;\u0026gt; 2 # 15 def get_bit_val(byte, index): \u0026#34;\u0026#34;\u0026#34; 得到某个字节中某一位（Bit）的值 :param byte: 待取值的字节值 :param index: 待读取位的序号，从右向左0开始，0-7为一个完整字节的8个位 :returns: 返回读取该位的值，0或1 \u0026#34;\u0026#34;\u0026#34; if byte \u0026amp; (1 \u0026lt;\u0026lt; index): return 1 else: return 0  补码  REPL Read-Eval-Print Loop\n“读取 - 求值 - 输出” 循环（英语： Read-Eval-Print Loop，简称 REPL），也被称做 交互式顶层构件（英语： interactive toplevel），是一个简单的，交互式的编程环境。这个词常常用于指代一个 Lisp 的交互式开发环境，也能指代命令行的模式。\n实现 为了实现一个 Lisp REPL，只需要实现这三个函数和一个不停轮询的函数即可 （当然，求值函数的实现是最为复杂的，因为它在内部要实现像 car 与 + 的原始函数以及像 if 一样的特殊操作符）。\n这些工作完成了之后，一个基本的 REPL 就可以用如下的简单形式表达： (loop (print (eval (read))))。\n一种实现 eval 的方式就是实现一个递归处理抽象语法树（该语法树被 read 函数创建）的函数。 另一种可行的方法是将这个抽象语法树编译为机器码并执行。\n主要的 REPL 编程语言环境  APL BASIC Clojure F# Haskell J Java (版本 jdk-9 起) Javascript Julia Perl PHP Prolog Python R Ruby Scala Smalltalk Standard ML Swift Tcl  Go Go does not provide a REPL.\nHowever, as already mentioned, Go Playground is very handy. The Go Authors are also thinking about adding a feature-rich editor to it.\nIf you want something local, consider installing hsandbox. Running it simply with hsandbox go will split your terminal screen (with screen) where you can write code at the top and see its execution output at the bottom on every save.\nThere was a gotry among standard Go commands, which used to evaluate expressions (with an optional package name), and could be run like gotry 1+2 and gotry fmt \u0026lsquo;Println(\u0026ldquo;hello\u0026rdquo;)\u0026rsquo; from shell. It is no longer available because not many people actually used it.\nmotemen/gore  Yet another Go REPL that works nicely. Featured with line editing, code completion, and more.\n参考：\n Does Go provide REPL?   录屏 cho45/KeyCast  Display keystroke for desktop screencast. (demo movie: youtube)\n 深入学习三巨头 Geoffrey Hinton Yoshua Bengio Yann LeCun  内心 OS OS 是 内心独白的英文 Overlapping Sound 的缩写。\n"});index.add({'id':27,'href':'/note/docs/study/docs/note/hugo/theme/hugo-book/','title':"hugo-book",'content':"hugo-book 配置 Site Configuration  点击查看配置详情 ...  # (Optional) Set Google Analytics if you use it to track your website. # Always put it on the top of the configuration file, otherwise it won\u0026#39;t work googleAnalytics = \u0026#34;UA-XXXXXXXXX-X\u0026#34; # (Optional) If you provide a Disqus shortname, comments will be enabled on # all pages. disqusShortname = \u0026#34;my-site\u0026#34; # (Optional) Set this to true if you use capital letters in file names disablePathToLower = true # (Optional) Set this to true to enable \u0026#39;Last Modified by\u0026#39; date and git author # information on \u0026#39;doc\u0026#39; type pages. enableGitInfo = true # (Optional) Theme is intended for documentation use, therefore it doesn\u0026#39;t render taxonomy. # You can remove related files with config below disableKinds = [\u0026#39;taxonomy\u0026#39;, \u0026#39;taxonomyTerm\u0026#39;] [params] # (Optional, default true) Controls table of contents visibility on right side of pages. # Start and end levels can be controlled with markup.tableOfContents setting. # You can also specify this parameter per page in front matter. BookToC = true # (Optional, default none) Set the path to a logo for the book. If the logo is # /static/logo.png then the path would be \u0026#39;logo.png\u0026#39; BookLogo = \u0026#39;logo.png\u0026#39; # (Optional, default none) Set leaf bundle to render as side menu # When not specified file structure and weights will be used BookMenuBundle = \u0026#39;/menu\u0026#39; # (Optional, default docs) Specify section of content to render as menu # You can also set value to \u0026#34;*\u0026#34; to render all sections to menu BookSection = \u0026#39;docs\u0026#39; # Set source repository location. # Used for \u0026#39;Last Modified\u0026#39; and \u0026#39;Edit this page\u0026#39; links. BookRepo = \u0026#39;https://github.com/alex-shpak/hugo-book\u0026#39; # Enable \u0026#39;Edit this page\u0026#39; links for \u0026#39;doc\u0026#39; page type. # Disabled by default. Uncomment to enable. Requires \u0026#39;BookRepo\u0026#39; param. # Path must point to \u0026#39;content\u0026#39; directory of repo. BookEditPath = \u0026#39;edit/master/exampleSite/content\u0026#39; # (Optional, default January 2, 2006) Configure the date format used on the pages # - In git information # - In blog posts BookDateFormat = \u0026#39;Jan 2, 2006\u0026#39; # (Optional, default true) Enables search function with flexsearch, # Index is built on fly, therefore it might slowdown your website. # Configuration for indexing can be adjusted in i18n folder per language. BookSearch = true # (Optional, default true) Enables comments template on pages # By default partals/docs/comments.html includes Disqus template # See https://gohugo.io/content-management/comments/#configure-disqus # Can be overwritten by same param in page frontmatter BookComments = true     Page Configuration  点击查看配置详情 ...  # Set type to \u0026#39;docs\u0026#39; if you want to render page outside of configured section or if you render section other than \u0026#39;docs\u0026#39; type = \u0026#39;docs\u0026#39; # Set page weight to re-arrange items in file-tree menu (if BookMenuBundle not set) weight = 10 # (Optional) Set to mark page as flat section in file-tree menu (if BookMenuBundle not set) bookFlatSection = true # (Optional, Experimental) Set to hide nested sections or pages at that level. Works only with file-tree menu mode bookCollapseSection = true # (Optional) Set true to hide page or section from side menu (if BookMenuBundle not set) bookHidden = true # (Optional) Set \u0026#39;false\u0026#39; to hide ToC from page bookToC = true # (Optional) If you have enabled BookComments for the site, you can disable it for specific pages. bookComments = true      使用 Shortcodes Buttons  Get Home  Contribute   点击查看配置 ...  {{\u0026lt; button relref=\u0026#34;/\u0026#34; \u0026gt;}}Get Home{{\u0026lt; /button \u0026gt;}} {{\u0026lt; button href=\u0026#34;https://github.com/alex-shpak/hugo-book\u0026#34; \u0026gt;}}Contribute{{\u0026lt; /button \u0026gt;}}     Columns Left Content hello hugo book shortcodes  Mid Content hello hugo book  Right Content hello hugo book shortcodes    点击查看配置 ...  {{\u0026lt; columns \u0026gt;}} \u0026lt;!-- begin columns block --\u0026gt; # Left Content Lorem markdownum insigne... \u0026lt;---\u0026gt; \u0026lt;!-- magic sparator, between columns --\u0026gt; # Mid Content Lorem markdownum insigne... \u0026lt;---\u0026gt; \u0026lt;!-- magic sparator, between columns --\u0026gt; # Right Content Lorem markdownum insigne... {{\u0026lt; /columns \u0026gt;}}     Expand  Custom Label ...  Markdown content hello hugo book shortcodes     点击查看配置 ...  {{\u0026lt; expand \u0026#34;Custom Label\u0026#34; \u0026#34;...\u0026#34; \u0026gt;}} ## Markdown content Lorem markdownum insigne... {{\u0026lt; /expand \u0026gt;}}     Hints Markdown content hello hugo book  Markdown content hello hugo book  Markdown content hello hugo book   点击查看配置 ...  {{\u0026lt; hint [info|warning|danger] \u0026gt;}} **Markdown content** hello hugo book {{\u0026lt; /hint \u0026gt;}}     Katex    \\( x = \\begin{cases} a \u0026\\text{if } b \\\\ c \u0026\\text{if } d \\end{cases} \\)   点击查看配置 ...  {{\u0026lt; katex [display] \u0026gt;}} x = \\begin{cases} a \u0026amp;\\text{if } b \\\\ c \u0026amp;\\text{if } d \\end{cases} {{\u0026lt; /katex \u0026gt;}}     Mermaid   sequenceDiagram Alice-Bob: Hello Bob, how are you? alt is sick Bob-Alice: Not so good :( else is well Bob-Alice: Feeling fresh like a daisy end opt Extra response Bob-Alice: Thanks for asking end  点击查看配置 ...  {{\u0026lt; mermaid \u0026gt;}} sequenceDiagram Alice-\u0026gt;\u0026gt;Bob: Hello Bob, how are you? alt is sick Bob-\u0026gt;\u0026gt;Alice: Not so good :( else is well Bob-\u0026gt;\u0026gt;Alice: Feeling fresh like a daisy end opt Extra response Bob-\u0026gt;\u0026gt;Alice: Thanks for asking end {{\u0026lt; /mermaid \u0026gt;}}     Tabs MacOS MacOS This is tab MacOS content.Linux Linux This is tab Linux content.Windows Windows This is tab Windows content.  点击查看配置 ...  {{\u0026lt; tabs \u0026#34;uniqueid\u0026#34; \u0026gt;}} {{\u0026lt; tab \u0026#34;MacOS\u0026#34; \u0026gt;}} # MacOS Content {{\u0026lt; /tab \u0026gt;}} {{\u0026lt; tab \u0026#34;Linux\u0026#34; \u0026gt;}} # Linux Content {{\u0026lt; /tab \u0026gt;}} {{\u0026lt; tab \u0026#34;Windows\u0026#34; \u0026gt;}} # Windows Content {{\u0026lt; /tab \u0026gt;}} {{\u0026lt; /tabs \u0026gt;}}      参考  https://github.com/alex-shpak/hugo-book  https://themes.gohugo.io/hugo-book   KaTeX/KaTeX  TeX wiki  "});index.add({'id':28,'href':'/note/docs/humanities/movie/imdbtop250/','title':"IMDB 电影 Top 250",'content':"a\n"});index.add({'id':29,'href':'/note/docs/study/docs/note/hugo/theme/','title':"主题",'content':"Hugo 主题 hugo-academic 适合作为个人主页，内容比较丰富，尤其适合作为技术或科研人员的博客。\nhugo-book  适合记笔记，或者写书。我很喜欢他右侧的页面目录，类似语雀。 其实语雀编辑体验很好，尤其是最近改版后允许用户直接在左侧目录操作新增页面。 不使用语雀，而使用 github pages，最关键也可以说唯一的原因就是对其他平台不放心，内容还是自己保管比较好。 不然万一哪天平台下线，只是一个道歉页面，而作为免费用户，只能自己想办法导出笔记，想想还是算了。  参考：https://themes.gohugo.io\n"});index.add({'id':30,'href':'/note/docs/social/history/country/south-korea/president/','title':"总统",'content':"韩国总统 "});index.add({'id':31,'href':'/note/docs/live/parenting/source/','title':"第三部分 源码实现",'content':""});index.add({'id':32,'href':'/note/docs/live/parenting/appendix/interview/expert/','title':"高阶",'content':"高阶面试题 "});index.add({'id':33,'href':'/note/docs/live/diary/2020/04/28/','title':"2020-04-28",'content':"2020 年 4 月 28 日（星期二） 今日待办     编程 算法 树的最长路径 #coding=utf-8 class TreeNode(): def __init__(self, val): self.val = val self.left = None self.right = None def longest(root): if root is None: return 0 return max(length(root), length(root.left), length(root.right)) def length(root): if root is None: return 0 return height(root.left) + height(root.right) def height(root): if root is None: return 0 return max(height(root.left), height(root.right)) + 1 n1 = TreeNode(1) n2 = TreeNode(2) n3 = TreeNode(3) n4 = TreeNode(4) n5 = TreeNode(5) n6 = TreeNode(6) n7 = TreeNode(7) n8 = TreeNode(8) n9 = TreeNode(9) n1.left = n2 n1.right = n3 n2.left = n4 n2.right = n5 n3.left = n6 n3.right = n7 n4.left = n8 n6.right = n9 print(longest(n1)) 乘积最大的数组平分方式 一个长度为 N 的数组（N 一定为偶数个），将其平均分成两部分，找出能够使这两部分的和的乘积最大的数组平分方式\nVSCode Clang-format VSCode 使用 Clang-format 时报错: write EPIPE\n解决方法： 填写 Clang-format 运行位置的绝对路径\n\u0026#34;clang-format.executable\u0026#34;: \u0026#34;/Users/yewang/.vscode/extensions/ms-vscode.cpptools-0.28.0-insiders/LLVM/bin/clang-format.darwin\u0026#34;, 生成配置文件（不需要）：\n/Users/yewang/.vscode/extensions/ms-vscode.cpptools-0.27.0/LLVM/bin/clang-format.darwin -style=llvm -dump-config \u0026gt; .vscode/.clang-format cpptools-srv 内存占用大 cpptools-srv\n限制内存大小\n\u0026#34;C_Cpp.intelliSenseCacheSize\u0026#34;: 100, 参考：\n Linux 下 vscode 编写 cpp 占用内存过高问题   TCP / IP tcp 粘包 只有 TCP 有粘包现象，UDP 永远不会粘包，因为 TCP 是基于数据流的协议，而 UDP 是基于数据报的协议\nTCP 本来就是基于字节流而不是消息包的协议，它自己说的清清楚楚： 我会把你的数据变成字节流发到对面去，而且保证顺序不会乱，但是你要自己搞定字节流解析。\n所谓粘包问题主要还是因为接收方不知道消息之间的界限，不知道一次性提取多少字节的数据所造成的。\n粘包问题的关键在于：\n接收端不知道发送端将要传送的字节流的长度，所以解决粘包的方法就是围绕，如何让发送端在发送数据前，把自己将要发送的字节流总大小让接收端知晓，然后接收端来一个死循环接收完所有数据\n我们可以把报头做成字典，字典里包含将要发送的真实数据的详细信息，然后 json 序列化，然后用 struck 将序列化后的数据长度打包成 4 个字节（4 个自己足够用了）\n发送时：\n 先发报头长度 再编码报头内容然后发送 最后发真实内容  接收时：\n 先手报头长度，用 struct 取出来 根据取出的长度收取报头内容，然后解码，反序列化 从反序列化的结果中取出待取数据的详细信息，然后去取真实的数据内容  UDP 不会沾包 TCP 为了保证可靠传输并减少额外的开销（每次发包都要验证），采用了基于流的传输，基于流的传输不认为消息是一条一条的，是无保护消息边界的（保护消息边界：指传输协议把数据当做一条独立的消息在网上传输，接收端一次只能接受一条独立的消息）。\nUDP 则是面向消息传输的，是有保护消息边界的，接收方一次只接受一条独立的信息，所以不存在粘包问题。\n举个例子：有三个数据包，大小分别为 2k、4k、6k，如果采用 UDP 发送的话，不管接受方的接收缓存有多大，我们必须要进行至少三次以上的发送才能把数据包发送完，但是使用 TCP 协议发送的话，我们只需要接受方的接收缓存有 12k 的大小，就可以一次把这 3 个数据包全部发送完毕。\n如何设计应用层协议 参考：\n tcp 粘包问题 什么是 TCP 粘包？怎么解决这个问题 怎么解决 TCP 网络传输「粘包」问题？   升级 gcc 安装开发必备环境：\nyum groupinstall \u0026#34;Development Tools\u0026#34; yum install glibc-static libstdc++-static 短 URL 系统是怎么设计的？ 关键字：短地址，长地址\n错误做法 即使我们定义短地址是 100 位。 那么它的变化是 62 的 100 次方。 62 = 10 数字 + 26 大写字母 + 26 小写字母。 无论这个数多么大，他也不可能大过世界上可能存在的长地址。 所以实现一一对应，本身就是不可能的。\n正确做法 通过发号策略，给每一个过来的长地址，发一个号即可，小型系统直接用 mysql 的自增索引就搞定了。 如果是大型应用，可以考虑各种分布式 key-value 系统做发号器。 不停的自增就行了。 第一个使用这个服务的人得到的短地址是 http://xx.xx/0 第二个是 http://xx.xx/1 第 11 个是 http://xx.xx/a 依次往后， 相当于实现了一个 62 进制的自增字段。\n如何实现同一个长地址多次转换，出来还是同一个短地址 最简单的是建立一个长对短的 hashtable，这样相当于用空间来换空间，同时换取一个设计上的优雅（真正的一对一）。\n实际情况是有很多性价比高的打折方案可以用。\n用 key-value 存储，保存 “最近” 生成的长对短的一个对应关系。注意是 “最近”，也就是说，我并不保存全量的长对短的关系，而只保存最近的。比如采用一小时过期的机制来实现 LRU 淘汰。\n这样的话，长转短的流程变成这样：\n 在这个 “最近” 表中查看一下，看长地址有没有对应的短地址  有就直接返回，并且将这个 key-value 对的过期时间再延长成一小时 如果没有，就通过发号器生成一个短地址，并且将这个 “最近” 表中，过期时间为 1 小时    参考：\n 短 URL 系统是怎么设计的？   TTY, PTS, Telnet, SSH  自媒体 5G-MEC Logo 微信公众号 Logo 2017 年之前，其 Logo 名称中均将「微信」与「公众平台」用圆点或竖杠符号进行区分。\n从 2018 年之后从文字中删除该符号后，图标开始使用一灰一绿的微信气泡图标\n微信公众平台 8 年来 Logo 方面的变化：\n参考：\n 微信公众平台更名「公众号」并更新 LOGO  我的微信首款码 6.66 元\n"});index.add({'id':34,'href':'/note/docs/live/diary/2020/05/28/','title':"2020-05-28",'content':"2020 年 5 月 28 日（星期四） 今日待办     编程 Hadoop HDFS Hadoop Distributed File System，是 Hadoop 的分布式文件系统\n每台机器上运行一个 DataNode 进程，负责管理一部分数据。\n有一台机器上运行了 NameNode 进程，负责管理整个 HDFS 集群的这么一个进程，里面存储了 HDFS 集群的所有元数据\n每次内存里改完了，写一条 edits log，元数据修改的操作日志到磁盘文件里，不修改磁盘文件内容，就是顺序追加\n每次 NameNode 重启的时候，把 edits log 里的操作日志读到内存里，就可以恢复元数据\nYARN MapReduce  Spring Cloud  Eureka：各个服务启动时，Eureka Client 都会将服务注册到 Eureka Server，并且 Eureka Client 还可以反过来从 Eureka Server 拉取注册表，从而知道其他服务在哪里 Ribbon：服务间发起请求的时候，基于 Ribbon 做负载均衡，从一个服务的多台机器中选择一台 Feign：基于 Feign 的动态代理机制，根据注解和选择的机器，拼接请求 URL 地址，发起请求 Hystrix：发起请求是通过 Hystrix 的线程池来走的，不同的服务走不同的线程池，实现了不同服务调用的隔离，避免了服务雪崩的问题 Zuul：如果前端、移动端要调用后端系统，统一从 Zuul 网关进入，由 Zuul 网关转发请求给对应的服务  Eureka Eureka 是微服务架构中的注册中心，专门负责服务的注册与发现。\n Eureka Client：负责将这个服务的信息注册到 Eureka Server 中 Eureka Server：注册中心，里面有一个注册表，保存了各个服务所在的机器和端口号  Feign Feign 的一个关键机制就是使用了动态代理。\nRibbon 负载均衡\nRibbon 的负载均衡默认使用的最经典的 Round Robin 轮询算法\nHystrix Hystrix 是隔离、熔断以及降级的一个框架。\nHystrix 会搞很多个小小的线程池， 比如订单服务请求库存服务是一个线程池，请求仓储服务是一个线程池，请求积分服务是一个线程池。 每个线程池里的线程就仅仅用于请求那个服务。\n解决服务雪崩：\n  熔断\n比如在 5 分钟内请求积分服务直接就返回了，不要去走网络请求卡住几秒钟。 这个过程，就是所谓的熔断！\n  降级\n每次调用积分服务，你就在数据库里记录一条消息，说给某某用户增加了多少积分，因为积分服务挂了，导致没增加成功！这样等积分服务恢复了，你可以根据这些记录手工加一下积分。 这个过程，就是所谓的降级。\n  Zuul 微服务网关\n可以做统一的降级、限流、认证授权、安全等等\n 运营商 DPI 系统 DPI， Deep Packet Inspection， 是指深度报文解析技术\nDPI 系统通常是指运营商的网络通道中的互联网流量监控、分析管理的系统，由硬件和软件组成。\nDPI 系统主要承担了将二进制的网络传输数据解析成一条条可视的报文，再对海量的报文进行一层层的特征分析，最终利用软件的形态可视化的呈现给运营商网络管理和运营服务单位，来帮助运营商进行更精细化的网络流量管理及其他相关业务的管理。\n 运营商的 DPI 系统是什么东西？  网管系统 国内三大运营商的专业网管系统建设已经普遍比较成熟，都建设了话务网管、数据网管、传输网管、信令监测、自动拨测、动环监控、电子运维和网管系统监控平台。\n在专业网管系统基础上，中国移动提出了 OneOSS 网管规划。我们需要加强跟踪研究下一代网管技术。\n下一代网管系统规划有综合网络应用平台、运营流程管理平台、业务开通平台、网络监控平台、质量保障平台和网管系统监控平台，需研究规划落地措施及有关实现技术\n"});index.add({'id':35,'href':'/note/docs/live/diary/2020/06/28/','title':"2020-06-28",'content':"2020 年 6 月 28 日（星期日） 备注：上班（端午调休）\n今日待办     编程 Redis redis.conf 配置\n daemonize  daemonize:yes: redis 采用的是单进程多线程的模式。当 redis.conf 中选项 daemonize 设置成 yes 时，代表开启守护进程模式。在该模式下，redis 会在后台运行，并将进程 pid 号写入至 redis.conf 选项 pidfile 设置的文件中，此时 redis 将一直运行，除非手动 kill 该进程。 daemonize:no: 当 daemonize 选项设置成 no 时，当前界面将进入 redis 的命令行界面，exit 强制退出或者关闭连接工具 (putty,xshell 等) 都会导致 redis 进程退出。    supervisor 管理 redis 参考：\n supervisor 管理 redis   Celery 现在都是基于 redis 的消息队列 ＋ 多 consumer ＋ supervisor 监控的方式 这样的好处是去除掉 python GIL 的限制，直接上多 process 不过只适合任务比较单一的情况\n参考：\n celery 有哪些比较好的替代品？   RTC 视频互动 Real-Time Communication\n QOS 设计 在公网情况下尽量不要用 udp，因为现在开源的成熟的可靠 udp 方案 比较少，而且都不是特别成熟和完善。\n如果是 RTC (视频互动) 这种超低延时场景，或者追求压榨弱网情况下网络性能，那么可以考虑使用可靠 udp 方案 (rudp)，否则没必要。\nRTSP 和 GB28181 中，如果使用 udp 传输 rtp，那么很大几率会存在丢包花屏，应该这些协议都没有 QOS 相关设计。\n SSRC GB28181 RTP 转 RTSP，如何绑定 RTSP 与 IPC 设备的关系？\n"});index.add({'id':36,'href':'/note/docs/humanities/movie/others/','title':"其他电影",'content':"a\n"});index.add({'id':37,'href':'/note/docs/live/parenting/appendix/','title':"第四部分 附录",'content':""});index.add({'id':38,'href':'/note/docs/live/diary/2020/04/27/','title':"2020-04-27",'content':"2020 年 4 月 27 日（星期一） 今日待办     编程 GB28181 SIP 协议 Antisip\n VSCode  kasecato/vscode-intellij-idea-keybindings   运维 disconf  Distributed Configuration Management Platform (分布式配置管理平台) http://disconf.readthedocs.io/\nconsul + consul-template gcc vs g++  后缀为 .c 的  gcc 把它当做 C 程序 g++ 当做是 C++ 程序     编译可以用 gcc/g++，而链接可以用 g++ 或者 gcc -lstdc++  编译阶段，g++ 会调用 gcc，对于 c++ 代码，两者是等价的 gcc 命令不能自动和 C++ 程序使用的库联接，所以通常用 g++ 来完成链接 可以选择手动链接，gcc -lstdc++    乐观锁 vs 悲观锁 乐观锁（读多写少） 总是假设最好的情况，每次去拿数据的时候都认为别人不会修改，所以不会上锁，但是在更新的时候会判断一下在此期间别人有没有去更新这个数据， 可以使用版本号机制和 CAS 算法实现。\n乐观锁适用于多读的应用类型，这样可以提高吞吐量，像数据库提供的类似于 write_condition 机制，其实都是提供的乐观锁。\n在 Java 中 java.util.concurrent.atomic 包下面的原子变量类就是使用了乐观锁的一种实现方式 CAS 实现的。\nCAS 算法 CAS 适用于写比较少的情况下（多读场景，冲突一般较少）\nCAS (compare and swap) 比较并替换\n CAS (compare and swap) 比较并替换，比较和替换是线程并发算法时用到的一种技术 CAS 是原子操作，保证并发安全，而不是保证并发同步 CAS 是 CPU 的一个指令 CAS 是非阻塞的、轻量级的乐观锁  乐观锁，严格来说并不是锁，通过原子性来保证数据的同步，比如说数据库的乐观锁，通过版本控制来实现等， 所以 CAS 不会保证线程同步。\nCAS (compare and swap) 比较并替换，就是将内存值更新为需要的值，但是有个条件，内存值必须与期望值相同。\n举个例子，期望值 E、内存值 M、更新值 U，当 E == M 的时候将 M 更新为 U。\n由于 CAS 是 CPU 指令，我们只能通过 JNI 与操作系统交互，关于 CAS 的方法都在 sun.misc 包下 Unsafe 的类里 java.util.concurrent.atomic 包下的原子类等通过 CAS 来实现原子操作。\n乐观锁的缺点 ABA 问题 ABA 问题是乐观锁一个常见的问题\n如果一个变量 V 初次读取的时候是 A 值，并且在准备赋值的时候检查到它仍然是 A 值，那我们就能说明它的值没有被其他线程修改过了吗？ 很明显是不能的，因为在这段时间它的值可能被改为其他值，然后又改回 A，那 CAS 操作就会误认为它从来没有被修改过。这个问题被称为 CAS 操作的 \u0026ldquo;ABA\u0026rdquo; 问题。\n循环时间长开销大 自旋 CAS（也就是不成功就一直循环执行直到成功）如果长时间不成功，会给 CPU 带来非常大的执行开销。\n只能保证一个共享变量的原子操作 CAS 只对单个共享变量有效，当操作涉及跨多个共享变量时 CAS 无效。但是从 JDK 1.5 开始，提供了 AtomicReference 类来保证引用对象之间的原子性，你可以把多个变量放在一个对象里来进行 CAS 操作。所以我们可以使用锁或者利用 AtomicReference 类把多个共享变量合并成一个共享变量来操作。\n参考：\n 深入分析 CAS（乐观锁）  悲观锁（写多读少） 总是假设最坏的情况，每次去拿数据的时候都认为别人会修改，所以每次在拿数据的时候都会上锁\n传统的关系型数据库里边就用到了很多这种锁机制，比如行锁，表锁等，读锁，写锁等，都是在做操作之前先上锁。\nJava 中 synchronized 和 ReentrantLock 等独占锁就是悲观锁思想的实现\nsynchronized 适用于写比较多的情况下（多写场景，冲突一般较多）\nJava 并发编程这个领域中 synchronized 关键字一直都是元老级的角色，很久之前很多人都会称它为 “重量级锁” 。但是，在 JavaSE 1.6 之后进行了主要包括为了减少获得锁和释放锁带来的性能消耗而引入的 偏向锁 和 轻量级锁 以及其它各种优化之后变得在某些情况下并不是那么重了。synchronized 的底层实现主要依靠 Lock-Free 的队列，基本思路是 自旋后阻塞，竞争切换后继续竞争锁，稍微牺牲了公平性，但获得了高吞吐量。在线程冲突较少的情况下，可以获得和 CAS 类似的性能；而线程冲突严重的情况下，性能远高于 CAS。\nJava 主流锁 参考：\n 【基本功】不可不说的 Java “锁” 事  Python 深拷贝 vs 浅拷贝 深拷贝和浅拷贝的不同仅仅是对组合对象而言，所谓的组合对象就是包含了其他对象的对象，如列表，类实例。 而对于数字，字符串，没有拷贝这一说，产生的都是原对象的引用。\n直接赋值 其实就是对象的引用（别名）。\n浅拷贝 (copy) 拷贝父对象，不会拷贝对象的内部的子对象。\n深拷贝 (deepcopy) copy 模块的 deepcopy 方法，完全拷贝了父对象及其子对象。\n应用场景 参考：\n 简述 Python 的深浅拷贝以及应用场景   Python 垃圾回收机制 引用计数 跟踪和回收垃圾\n在 Python 中，大多数对象的生命周期都是通过对象的引用计数来管理的。 从广义上来讲，引用计数也是一种垃圾收集机制，而且也是一种最直观，最简单的垃圾收集技术。\n原理： 当一个对象的引用被创建或者复制时，对象的引用计数加 1； 当一个对象的引用被销毁时，对象的引用计数减 1； 当对象的引用计数减少为 0 时，就意味着对象已经没有被任何人使用了，可以将其所占用的内存释放了。\n标记 - 清除 解决容器对象可能产生的循环引用的问题\n标记 - 清除” 是为了解决循环引用的问题。可以包含其他对象引用的容器对象（比如：list，set，dict，class，instance）都可能产生循环引用。\n我们必须承认一个事实，如果两个对象的引用计数都为 1，但是仅仅存在他们之间的循环引用，那么这两个对象都是需要被回收的，也就是说，它们的引用计数虽然表现为非 0，但实际上有效的引用计数为 0。\n原理：“标记 - 清除” 并不改动真实的引用计数，而是将集合中对象的引用计数复制一份副本，改动该对象引用的副本。对于副本做任何的改动，都不会影响到对象生命走起的维护。\n分代回收 以空间换取时间来进一步提高垃圾回收的效率\n无论使用何种语言开发，无论开发的是何种类型，何种规模的程序，都存在这样一点相同之处。 即： 一定比例的内存块的生存周期都比较短，通常是几百万条机器指令的时间，而剩下的内存块，起生存周期比较长，甚至会从程序开始一直持续到程序结束。\n原理：将系统中的所有内存块根据其存活时间划分为不同的集合，每一个集合就成为一个 “代”，垃圾收集的频率随着 “代” 的存活时间的增大而减小。也就是说，活得越长的对象，就越不可能是垃圾，就应该减少对它的垃圾收集频率。那么如何来衡量这个存活时间：通常是利用几次垃圾收集动作来衡量，如果一个对象经过的垃圾收集次数越多，可以得出：该对象存活时间就越长。\n参考：\n Python 垃圾回收机制？   HTTP Code  200: 服务器成功返回请求的数据。 201: 新建或修改数据成功。 202: 一个请求已经进入后台排队（异步任务）。 204: 删除数据成功。 304：协商缓存 400: 发出的请求有错误，服务器没有进行新建或修改数据的操作。 401: 用户没有权限（令牌、用户名、密码错误）。 403: 用户得到授权，但是访问是被禁止的。 404: 发出的请求针对的是不存在的记录，服务器没有进行操作。 406: 请求的格式不可得。 410: 请求的资源被永久删除，且不会再得到的。 422: 当创建一个对象时，发生一个验证错误。 500: 服务器发生错误，请检查服务器。 502: 网关错误。 503: 服务不可用，服务器暂时过载或维护。 504: 网关超时。  文件上传 根据 http 协议的规范和定义，完成请求消息体的封装和消息体的解析，然后将二进制内容保存到文件。\n form 标签的 enctype 设置为 multipart/form-data  multipart 互联网上的混合资源，就是资源由多种元素组成 form-data 表示可以使用 HTML Forms 和 POST 方法上传文件 具体的定义可以参考 RFC 7578   method 必须为 post 方法  断点续传 服务端增加一个获取分片的接口供客户端调用\n参考：\n 各种文件上传攻略，从小图片到大文件断点续传  可扩展性 设计模式可增加可扩展性 工厂模式\n抽象工厂模式\n观察者模式：很方便增加观察者，方便系统扩展\n模板方法模式：很方便的实现不稳定的扩展点，完成功能的重用\n适配器模式：可以很方便地对适配其他接口\n代理模式：可以很方便在原来功能的基础上增加功能或者逻辑\n责任链模式：可以很方便得增加拦截器 / 过滤器实现对数据的处理，比如 struts2 的责任链\n策略模式：通过新增策略从而改变原来的执行策略\n消息队列 微服务 可扩展的数据结构 使用 NoSQL 数据库（如 Cassandra）的 ColumnFamily （列族）技术可以做到可扩展的数据结构设计。它是一种面向列族的稀疏矩阵的存储格式。\n只需要指定 ColumnFamily 的名字，即可创建表。字段可以在写入数据时再指定，通过这种方式，一张表可以包含数百万个字段。这就使得应用的数据结构可以随意扩展。只需要指定任意字段名称和值即可查询。\n InfluxDB Usage: connect \u0026lt;host:port\u0026gt; connects to another node specified by host:port auth prompts for username and password pretty toggles pretty print for the json format chunked turns on chunked responses from server chunk size \u0026lt;size\u0026gt; sets the size of the chunked responses. Set to 0 to reset to the default chunked size use \u0026lt;db_name\u0026gt; sets current database format \u0026lt;format\u0026gt; specifies the format of the server responses: json, csv, or column precision \u0026lt;format\u0026gt; specifies the format of the timestamp: rfc3339, h, m, s, ms, u or ns consistency \u0026lt;level\u0026gt; sets write consistency level: any, one, quorum, or all history displays command history settings outputs the current settings for the shell clear clears settings such as database or retention policy. run \u0026#39;clear\u0026#39; for help exit/quit/ctrl+d quits the influx shell show databases show database names show series show series information show measurements show measurement information show tag keys show tag key information show field keys show field key information A full list of influxql commands can be found at: https://docs.influxdata.com/influxdb/latest/query_language/spec/ influx -precision rfc3339 # database SHOW DATABASES CREATE DATABASE mydb USE mydb INSERT cpu,host=serverA,region=us_west value=0.64 SELECT \u0026#34;host\u0026#34;, \u0026#34;region\u0026#34;, \u0026#34;value\u0026#34; FROM \u0026#34;cpu\u0026#34; SELECT * FROM /.*/ LIMIT 1 参考：\n Influx 中文指南   政治 苏哈托 "});index.add({'id':39,'href':'/note/docs/study/docs/office/','title':"办公",'content':"办公 "});index.add({'id':40,'href':'/note/docs/live/diary/2020/04/26/','title':"2020-04-26",'content':"2020 年 4 月 26 日（星期日） 备注：\n 法定上班。  今日待办     编程 duedge 基础架构\nhttp Host header 函数式编程 MostlyAdequate/mostly-adequate-guide  Mostly adequate guide to FP (in javascript)\n中文版 llh911001/mostly-adequate-guide-chinese 点击阅读\nJavaScript 如何衡量一个人的 JavaScript 水平？\n python 猴子补丁 属性在运行时的动态替换，叫做猴子补丁（Monkey Patch）。\nmonkey patch 即运行时动态改变方法、类的方法。 不管是定义在类外的普通方法、类里面的方法、甚至是模块这些都可以进行 “动态替换的操作”\nclass A: def func(self): print(\u0026#34;Hi\u0026#34;) def monkey(self): print(\u0026#34;Hi, monkey\u0026#34;) a = A() A.func=A.monkey #在运行的时候，才改变了func a.func() def outer_monkey(a): # a 这个参数是没有用到的，因为func有一个参数，如果这个函数没有参数的话不能这样直接赋值 print(\u0026#34;Hi,outer monkey\u0026#34;) a = A() A.func=outer_monkey a.func() 为什么叫猴子补丁 属性的运行时替换和猴子也没什么关系，关于猴子补丁的由来网上查到两种说法：\n  这个词原来为 Guerrilla Patch，杂牌军、游击队，说明这部分不是原装的，在英文里 guerilla 发音和 gorllia (猩猩) 相似，再后来就写了 monkey (猴子)。\n  还有一种解释是说由于这种方式将原来的代码弄乱了 (messing with it)，在英文里叫 monkeying about (顽皮的)，所以叫做 Monkey Patch。\n  猴子补丁的叫法有些莫名其妙，只要和 “模块运行时替换的功能” 对应就行了。\nujson import json import ujson def monkey_patch_json(): json.__name__ = \u0026#39;ujson\u0026#39; json.dumps = ujson.dumps json.loads = ujson.loads monkey_patch_json() 协程 gevent  Python 通过 yield 提供了对协程的基本支持，但是不完全。而第三方的 gevent 为 Python 提供了比较完善的协程支持。\ngevent 是第三方库，通过 greenlet 实现协程，其基本思想是：\n当一个 greenlet 遇到 IO 操作时，比如访问网络，就自动切换到其他的 greenlet，等到 IO 操作完成，再在适当的时候切换回来继续执行。由于 IO 操作非常耗时，经常使程序处于等待状态，有了 gevent 为我们自动切换协程，就保证总有 greenlet 在运行，而不是等待 IO。\n由于切换是在 IO 操作时自动完成，所以 gevent 需要修改 Python 自带的一些标准库，这一过程在启动时通过 monkey patch 完成：\nfrom gevent import monkey; monkey.patch_socket() import gevent def f(n): for i in range(n): print gevent.getcurrent(), i g1 = gevent.spawn(f, 5) g2 = gevent.spawn(f, 5) g3 = gevent.spawn(f, 5) g1.join() g2.join() g3.join() 参考：\n Python 猴子补丁 python 面试题精讲 ——monkey patch（猴子补丁）  Java JDK AdoptOpenJDK 清华大学 AdoptOpenJDK\n参考：\n JDK 用哪个版本比较好？  版本 在 2018.9 之前，Oracle JDK 是大家普遍运用于线上的 JDK，OpenJDK 的特性并不完全，并且 Oracle JDK 号称做了很多优化。\n在 2018.9 之后，Oracle JDK 正式商用（开发不收费，但是运行线上业务收费）。 但是与此同时，Oracle 宣布，OpenJDK 与 Oracle JDK 在功能上不会有区别。 并且，OpenJDK 11 RTS 将会由红帽社区进行维护。这样，更加增加了可靠性与保证问题的及时解决。\n我们可以在线上使用 OpenJDK，开发时，使用任意的 JDK。\n对于商业版的 JDK，不同的厂商都将长期维护版本定在 JDK 11/17/23/\u0026hellip;\n对于 OpenJDK，社区说，对于这些版本，至少会提供四年的维护更新时间。 每个长期维护版本都会有一个固定的管理者，对于 OpenJDK11，应该就是红帽社区。\n现在源代码搞定了，但是，我们应该从哪里获取编译好的 OpenJDK 呢？ 这个可以交给 AdoptOpenJDK，它会一直收集不同版本的 OpenJDK 以及全平台的 build 好的 OpenJDK\n\n各版本重大更新内容 从 Java 第一个版本发布到现在，已经有 24 年了，24 年中共发布了 14 个版本，那么，。让我们细数一下各个版本中增加的主要特性有哪些。\nJDK 1.0 第一个版本于 1996 年 1 月 23 日发布，叫做为 Oak。而真正第一个稳定的版本 JDK 1.0.2，被称作 Java 1。\nJDK 1.1  内部类 JDBC JavaBeans  J2SE 1.2  Java 集合框架 Swing 图像化 API JIT 编译器  J2SE 1.3  HotSpot JVM JNDI JPDA 用于实现动态代理的类  J2SE 1.4  assert 关键字 异常链 NIO  J2SE 5.0  泛型 元数据 自动封箱、自动拆箱 枚举 可变参数函数 强化 for each 循环 Swing java.util.concurrent 包  Java SE 6  支持 JDBC 4.0  Java SE 7  在 switch 中使用字符串类型 try-with-resources 新的 invokedynamic 字节码指令 允许在数值字面值中加入下划线  Java SE 8  Lambda 表达式 Nashorn 移除了虚拟机内存管理中的永久代 新的日期和时间 API  Java SE 9  Jigsaw 项目中将 JDK 模块化 jshell jlink  Java SE 10  局部变量类型推断 适用于 G1 的多线程完全垃圾回收  Java SE 11  ZGC Epsilon  Java SE 12  Shenandoah Switch 表达式（预览）  Java SE 13  Text Blocks（预览阶段） 动态 CDS 归档  Java SE 14  Records Switch 表达式 友好的空指针异常 打包工具   Java 工具 各种常用工具，建议升级到如下版本以后：\n IntelliJ IDEA: 2018.2 Eclipse: Photon 4.9RC2 with Java 11 plugin Maven: 3.5.0 Maven compiler plugin: 3.8.0 surefire and failsafe: 2.22.0 Gradle: 5.0  对于如下工具，由于已经不再维护，需要替换成其他工具：\n FindBugs（静态代码 bug 发现）： 用 SpotBugs 替换。 Cobertura（代码测试覆盖率）：用 Jacoco 替换  参考：\n 从 JDK8 升级到 JDK11，看这篇就足够了   语言 tutorial vs guide A tutorial is a step-by-step walk-through for someone with no experience. A guide gives basic information, not detailed instruction. Think \u0026ldquo;pointers\u0026rdquo;. Particularly for computers, a how-to is more of a list of detailed steps for particular operations.\n参考：\n Differences between “tutorial”, “guide” and “how-to”  "});index.add({'id':41,'href':'/note/docs/live/diary/2020/07/','title':"7 月",'content':"2020 年 7 月 本月计划 "});index.add({'id':42,'href':'/note/docs/live/diary/2020/04/25/','title':"2020-04-25",'content':"2020 年 4 月 25 日（星期六） 今日待办     编程 git submodule git submodule add -b 参考：\n How can I specify a branch/tag when adding a Git submodule?  submodule 修改 url  edit the .gitmodules file to update the URL git submodule sync  参考： How to change the remote repository for a git submodule?\ndelete submodule  Delete the relevant section from the .gitmodules file. Stage the .gitmodules changes git add .gitmodules Delete the relevant section from .git/config. Run git rm \u0026ndash;cached path_to_submodule (no trailing slash). Run rm -rf .git/modules/path_to_submodule (no trailing slash). Commit git commit -m \u0026ldquo;Removed submodule \u0026quot; Delete the now untracked submodule files rm -rf path_to_submodule  "});index.add({'id':43,'href':'/note/docs/live/diary/2020/05/25/','title':"2020-05-25",'content':"2020 年 5 月 25 日（星期一） 今日待办     编程 I/O 多路复用 vs 基于事件驱动 高并发是指不活跃的长连接，并不是并发请求\n典型的后端服务，在逻辑上可以划分为两层，\n 跟业务无关的通信层，负责 socket 连接的创建和管理，负责 bind/listen/accept/send/recv\u0026hellip; 通信层上面是业务逻辑层，负责被动响应请求，或主动推送业务消息  通信层特点：\n 都是 IO 行为，几乎不大消耗 CPU 连接数很多，可能同时有 10K 甚至 100K 个 TCP 连接 通信协议就那么几种，decode/encode 简单 外部网络是慢速 IO，收发一点数据可能要 1 秒甚至更久  业务逻辑层特点：\n 少量 CPU 消耗，大部分时间在等待数据库或者其它网络服务返回 业务逻辑五花八门，逻辑中往往需要调用别的网络服务，如 db 并发请求数，往往小于连接数，10K 个连接，可能每秒只有 100 个请求 单个业务请求通常很快，毫秒级别，几十毫秒算慢的了  如果完全采用传统的多线程模型，1 个 tcp 连接对应 1 个线程，10K 个连接需要 10K 个线程，典型的内存消耗是 10G。但是业务逻辑层并发请求往往要小 1 到 2 个数量级，每个请求往往只需要 100ms 以内，所以业务逻辑层需要的线程数，比通信层小 2-3 个数量级，不需要 10K 个线程，只要 100 个甚至 10 个就够了。\n这种 2-3 个数量级差距的不匹配，促使了第一代事件驱动的流行，常见的模型，纷纷把通信层剥离出来，用事件驱动的形式取代多线程，但是在业务逻辑层仍然采用多线程模型。几个著名的例子:\n nginx 负责通信层，PHP-FPM 负责业务逻辑层 nginx 负责通信层，uwsgi 负责 Python 的业务逻辑层 tomcat nio 负责通信层，业务逻辑层扔到线程池里处理  这些模型都很成功，用几百个甚至区区几十个线程 / 进程，满足了几万甚至几十万的并发连接。在整个 199X 年到 2010 年，这个模型都相当的适用，之后移动互联网兴起，随之也出现越来越多的网络 API 服务，我们的业务逻辑层，不但要跟内网的网络服务通信，还要跟外网的服务通信，在业务逻辑层也产生了大量的外网网络 IO，导致一个请求不能在 100ms 内完成，可能增加到了 500ms 甚至几秒钟，其中大部分时间是在等待网络，白白的占用了一个线程等 IO。\n如果业务逻辑层也要消耗很多时间等待网络 IO，那么它跟通信层的 2-3 个数量级的线程数量需求这个特性就被打破了，在极端的业务下，他们甚至重新回来 1:1 这个比例，举个例子，APP 的广告服务，一个请求里可能包含 3 个广告位，每个广告位从 20 家广告供应商那里获取广告，再选价格最高的返回给 APP 展示。这里每一个 http 请求，需要对外发起 60 个 http 请求，按照一个 100ms 算，需要耗时 6 秒，如果每秒有 1000 个广告请求，就需要 6000 个线程才能不积压至服务崩溃。\n所以第二代事件驱动模型应运而生，把业务逻辑也变成事件驱动，彻底消除浪费线程等待 IO 这个现象。事件驱动有两件常见的外衣，一件是异步回调，另一件是 coroutine，近几年有了很多应用：\n Go 的 goroutine Python 3 的 coroutine Kotlin 的 coroutine nodejs 的异步回调 swoole 1 的异步回调和 swoole 2 的 coroutine erlang/elixir 的 process 也算是 coroutine VertX 的异步回调 \u0026hellip;  第二代普遍出现的比较晚，而且只有大厂有这个流量需要用到，所以远没有第一代那么普及，coroutine 和 csp 等概念都是几十年前提出的，流行和普及的晚，因此只能算是老年新生事物。\n一小搓培训出身的码农，因为基础差底子差，喜欢把这个当作黑科技来吹，所以才变得有些神秘兮兮了。其实它就是一层窗户纸，轻轻捅破，也就这样了，一点儿都不稀奇。\n真正的门槛和功夫，不是模型本身，是实现这个模型时，处处往死里优化，死抠的那些细节，往往是一般 PPT 里看不到的。写字人人都会，写出来好不好看，差别就太大了。\n参考：\n 为什么基于事件驱动的服务器能实现高并发？  服务端经典的 C10k 问题 实现 C1000k 的常规做法是调整内核参数，提高文件数，降低每个连接的内存消耗\n参考：\n The C10K problem 高性能网络编程 (一)：单台服务器并发 TCP 连接数到底可以有多少 如何做到 100k 以上的并发处理？ C1000k 新思路：用户态 TCP/IP 协议栈 构建 C1000K 的服务器 (2) – 实现百万连接的 comet 服务器  ideawu/icomet  A C1000K comet/push server built with C++, for web and mobile app     在 Linux 上，编写一个每秒接收 100 万个 UDP 包的程序有多困难？ C100K-C1000K 这样的高并发是如何做出来的？基准测试是什么？  一个 TCP 连接要占用多少系统资源 在现在的 Linux 操作系统上，如果用 socket ()/connect () 或 accept () 来创建 TCP 连接，那么每个连接至少要占用一个文件描述符 (file descriptor)。\n为什么说 “至少”？ 因为文件描述符可以复制，比如 dup ()； 也可以被继承，比如 fork ()； 这样可能出现系统里边同一个 TCP 连接有多个文件描述符与之对应。\n参考：\n 关于 TCP 并发连接的几个思考题与试验  服务发现 Netflix/eureka  AWS Service registry for resilient mid-tier load balancing and failover.\nalibaba/nacos  an easy-to-use dynamic service discovery, configuration and service management platform for building cloud native applications. https://nacos.io\n"});index.add({'id':44,'href':'/note/docs/live/diary/2020/06/','title':"6 月",'content':"2020 年 6 月 本月计划  百度月读帮  《人人都是产品经理 2.0》 2020.5.1 - 6.14 《卓有成效的管理者》 2020.6.15 - 7.26 《201 principles of software development》 2020.7.27 - 9.6    "});index.add({'id':45,'href':'/note/docs/live/diary/2020/04/24/','title':"2020-04-24",'content':"2020 年 4 月 24 日（星期五） 今日待办     编程 github comment Review Comments Commit Comments Issue Comments  OAM (Open Application Model) OAM 是阿里巴巴和微软共同开源的云原生应用规范模型\n2019 年 10 月宣布开源，同时开源了基于 OAM 的实现 Rudr。\nRudr  A Kubernetes implementation of the Open Application Model specification https://oam.dev\nOpenTelemetry  Specifications for OpenTelemetry https://opentelemetry.io\n参考：\n OAM（开放应用模型）—— 定义云原生应用标准的野望   Kubernetes CRI（Container Runtime Interface） 容器运行时接口，提供计算资源\nCNI（Container Network Interface） 容器网络接口，提供网络资源\nCSI（Container Storage Interface） 容器存储接口，提供存储资源\n Dapr  Dapr is a portable, serverless, event-driven runtime that makes it easy for developers to build resilient, stateless and stateful microservices that run on the cloud and edge and embraces the diversity of languages and developer frameworks.\nDapr vs Istio  Dapr is a distributed application runtime. Unlike a service mesh which is focused on networking concerns, Dapr is focused on providing building blocks that make it easier for developers to build microservices. Dapr is developer-centric versus service meshes being infrastructure-centric. Istio is not a programming model and does not focus on application level features such as state management, pub-sub, bindings etc. That is where Dapr comes in.  SMI (Service Mesh Interface) SMI is an abstraction layer that provides a common API surface across different service mesh technology.\nDapr can leverage any service mesh technology including SMI.\n参考： What’s the difference between Dapr and Istio?\n Actor 模型 Virtual Actors 当你在上层编程的时候，你可以永远假设和你通讯的 Actor 是活着的，这对于大大简化应用层的逻辑，不言而喻。\nakka/akka  Build highly concurrent, distributed, and resilient message-driven applications on the JVM https://akka.io\nAsynkronIT/protoactor-go  Proto Actor - Ultra fast distributed actors for Go, C# and Java/Kotlin http://proto.actor\ndotnet/orleans  Orleans is a cross-platform framework for building distributed applications with .NET\nhttp://dotnet.github.io/orleans\n参考：\n 如何评价微软的 orleans 框架？ 什么是 Actor? 为什么我觉得 Actor 很难用？   Baetyl  算法 KMP 参考：\n 如何更好地理解和掌握 KMP 算法？ KMP 算法详解 Knuth-Morris-Pratt algorithm  KMP：花 48 小时看懂了 KMP，想让你在 48 分钟内看懂    会议  经济 ROI abbr. 投资回收率（return on investment）；利润率（Rate of Interest）\n"});index.add({'id':46,'href':'/note/docs/live/diary/2020/06/24/','title':"2020-06-24",'content':"2020 年 6 月 24 日（星期三） 今日待办     编程 Ctrl + C vs Ctrl + D Ctrl + C tells the terminal to send a SIGINT to the current foreground process, which by default translates into terminating the application. Ctrl + D tells the terminal that it should register a EOF on standard input, which bash interprets as a desire to exit.\n参考：\n What\u0026rsquo;s the difference between ^C and ^D for UNIX/Mac OS X terminal?   MQTT.fx MQTT.fx 是目前主流的 MQTT 桌面客户端，它支持 Windows、 Mac、Linux 操作系统， 可以快速验证连接，并发布或订阅消息。\nCoAP Linux 重启 shutdown -r now 参考：\n “reboot” or “shutdown -r now”: what restart command is safer?  "});index.add({'id':47,'href':'/note/docs/live/diary/2020/05/','title':"5 月",'content':"2020 年 5 月 本月计划  百度月读帮  《人人都是产品经理 2.0》 2020.5.1 - 6.14 《卓有成效的管理者》 2020.6.15 - 7.26 《201 principles of software development》 2020.7.27 - 9.6    "});index.add({'id':48,'href':'/note/docs/social/history/country/','title':"国家",'content':"国家 "});index.add({'id':49,'href':'/note/docs/social/history/country/south-korea/','title':"韩国",'content':"韩国 "});index.add({'id':50,'href':'/note/docs/live/diary/2020/04/23/','title':"2020-04-23",'content':"2020 年 4 月 23 日（星期四） 今日待办     编程 边缘计算  物联网关类，用 edgex 容器场景  it 类应用多的，rancher/k3s ct 类应用多的 kubeedge   starlingx 适合继承 openstack 的，又有容器要求的边缘场景  "});index.add({'id':51,'href':'/note/docs/live/diary/2020/05/23/','title':"2020-05-23",'content':"2020 年 5 月 23 日（星期六） 今日待办     编程 VPS 文件下载服务器 Nginx server { listen 80; server_name vultr.kingye.me; set $php_upstream \u0026#39;unix:/run/php/php7.2-fpm.sock\u0026#39;; root /root/download; index index.php; location / { #try_files $uri $uri/ /index.php?$args;  add_header Content-disposition \u0026#34;attachment; filename=$1\u0026#34;; } location ~ \\.php$ { fastcgi_pass $php_upstream; fastcgi_index index.php; include fastcgi.conf; } location ~ /\\.(ht|svn|git) { deny all; } }  tampermonkey（chrome 插件） AC-baidu: 重定向优化百度搜狗谷歌搜索去广告_favicon双列 Endless_Google 豆瓣和 IMDb 互相显示评分 Mouseover Popup Image Viewer Search By Image 网页限制解除 (改) 一键 VIP 视频解析 Feedly filtering and sorting 视频网页全屏 迅雷、快车、QQ 旋风等专有链解密 新浪微博根据关键词、作者、话题、来源等过滤微博 百度网盘直接下载助手  英语 i.e. vs e.g. I.e. and e.g. are both Latin abbreviations.\nE.g. stands for exempli gratia and means \u0026ldquo;for example.\u0026rdquo;\nI.e. is the abbreviation for id est and means \u0026ldquo;in other words.\u0026rdquo;\n参考：https://www.grammarly.com/blog/know-your-latin-i-e-vs-e-g\n 翻译规范 中文文案排版指北  地理 中国有几个时区 中国目前其实有两个时区，除了中国标准时间（北京时间）之外，还有新疆时间（又称乌鲁木齐时间，TZ database 中为 Asia/Urumqi）。尽管官方角度来说中国只有北京时间，但新疆时间至少是半官方的（参见此答案：为什么中国只用一个标准时，而美国本土用四个标准时？）。\n只有 Asia/Chongqing 或 Asia/Chungking（重庆） 、 Asia/Harbin（哈尔滨）和 Asia/Kashgar（喀什），且只是因为历史因素（民国时的五时区）而存在，现在已链接到 Asia/Shanghai 或 Asia/Urumqi。\n所以 TZ database 里的中国时区（不算港澳台）就只有 2 个，Asia/Shanghai 和 Asia/Urumqi。其他几个是为历史因素保留。\n参考：为什么在中国只有一个时区，但是却有很多的时区代码？\n Stand-up comedy 单口喜剧即英文的「Stand-up comedy」。香港称为栋笃笑（粤语正字：戙𡰪笑，读：dukdungsīu），台湾称为独角喜剧 ^[2]^。又有单人喜剧、单人脱口秀、站立喜剧等名称。\n参考：\n https://www.wikiwand.com/zh-cn/棟篤笑 Stand-up Comedy 的科普，以及 25 位搞笑大佬评点  代表人物 Louis C.K. 参考：https://www.wikiwand.com/zh-cn/路易-C-K\n作品  【单口喜剧 / Netflix 官方中字】Louis CK: Hilarious 【路易 C.K. | 2017 单口】Louis C.K. 2017【电波字幕组】  Tina Fey 参考：https://www.wikiwand.com/zh-cn/蒂娜-菲\nAmy Schumer 参考：https://www.wikiwand.com/zh-cn/艾米-舒默\nKatherine Ryan 作品  【单口喜剧 / Netflix 官方中字】Katherine Ryan: In Trouble   动画 全世界评分最高动画 TOP 100  100、朝花夕誓——约定之花 99、樱花庄的宠物女孩 98、王牌投手 振臂高挥 97、幼女战记 96、花开伊吕波 95、我的青春恋爱物语果然有问题 94、全金属狂潮 校园篇 93、好想告诉你 92、悠久之翼 91、幸运星 90、TIGER \u0026amp; BUNNY 89、斩服少女 88、怪物 87、蓝色恐惧 86、来自风平浪静的明天 85、从零开始的异世界生活 84、声之形 83、鬼灭之刃 82、Angel Beats 81、莉兹与青鸟 80、百变之星 79、月刊少女野崎君 78、辉夜大小姐想让我告白 77、JOJO 的奇妙冒险 星尘斗士 76、空之境界 第五章 矛盾螺旋 75、刀语 74、夏日大作战 73、昭和元禄落语心中 第二季 72、游戏人生零 71、紫罗兰永恒花园 70、悠哉日常大王 69、黑之契约者 68、黑礁 67、男子高中生的日常 66、寒蝉鸣泣之时 解 65、秒速五厘米 64、狼与香辛料 63、轻音少女 第二季 62、狼的孩子雨和雪 61、排球少年 第三季 60、乒乓 59、吹响吧上低音号 2 58、为美好的世界献上祝福 2 57、十二国记 56、猎人 1999 55、无头骑士异闻录 54、钢之炼金术师 53、月色真美 52、棋魂 51、穿越时空的少女 50、心理测量者 49、只有我不在的街道 48、一拳超人 47、交响诗篇 46、混沌武士 45、来自新世界 44、龙猫 43、摇曳露营 42、冰菓 41、未闻花名 40、水星领航员 第三季 39、浪客剑心 追忆篇 38、数码兽大冒险 37、白兔糖 36、龙与虎 35、永生之酒 34、歌牌情缘 2 33、日常 32、夏目友人帐 参 31、海贼王 30、星空清理者 29、风之谷 28、进击的巨人 第三季 Part.2 27、四叠半神话大系 26、Fate Zero 25、死亡笔记 24、灌篮高手 23、物语系列 第二季 22、魔法少女小圆 21、天空之城 20、四月是你的谎言 19、你的名字 18、幽灵公主 17、千与千寻 16、虫师 15、来自深渊 14、比宇宙更远的地方 13、新世纪福音战士 12、天元突破 红莲螺岩 11、白箱 SHIROBAKO 10、3 月的狮子 第二季 9、反叛的鲁路修 第二季 8、凉宫春日的消失 7、银河英雄传说 6、攻壳机动队 第一季（2002） 5、银魂 4、命运石之门 3、星际牛仔 2、钢之炼金术师 FA 1、CLANNAD 第二季  出自：https://www.bilibili.com/video/av78273046\n"});index.add({'id':52,'href':'/note/docs/live/diary/2020/06/23/','title':"2020-06-23",'content':"2020 年 6 月 23 日（星期二） 今日待办     编程 Spring spring 事务 REQUIRED REQUIRES_NEW 区别  hyperkit moby/hyperkit HyperKit 是一种轻量级虚拟化方法，基于 MacOSX10.10 之后引入的 Hypervisor 框架。HyperKit 应用可以利用硬件虚拟化运行 VMs，但是并不需要特殊权限或者复杂管理工具栈。\nHyperKit 是基于 xHyve 和 vHyve 项目，与其他相关功能模块（例如：VPNKit 和 DataKit）合作使得运行更加有效。由于 HyperKit 架构与库之上，因此将其和 unikernel 库连接起来就显得很直接。例如，我们可以通过使用 MirageOS QCow 库（用 OCaml 编写），加入持久化块设备支持。\n k3s 安装 istio # 如果 curl 下载失败，可以直接访问 https://get.k3s.io，然后把 install 文本复制到本地文件（比如 install-k3s.sh） # 然后执行 INSTALL_K3S_EXEC=\u0026#34;--no-deploy traefik\u0026#34; K3S_KUBECONFIG_MODE=\u0026#34;644\u0026#34; sh install-k3s.sh curl -sfL https://get.k3s.io |INSTALL_K3S_EXEC=\u0026#34;--no-deploy traefik\u0026#34; K3S_KUBECONFIG_MODE=\u0026#34;644\u0026#34; sh - 参考：\n How to setup Istio on K3S platform 在 k3d 上快速安装 Istio，助你在本地灵活使用 K8S！   k8s Ingress controller containous/traefik  The Cloud Native Edge Router\n OpenWrt openwrt/openwrt  VOIP Voice over Internet Protocol\n基于 IP 的语音传输（英语：Voice over Internet Protocol，缩写为 VoIP ）是一种语音通话技术， 经由网际协议（IP）来达成语音通话与多媒体会议，也就是经由互联网来进行通信。 其他非正式的名称有 IP 电话（IP telephony）、互联网电话（Internet telephony）、宽带电话（broadband telephony）以及宽带电话服务（broadband phone service）。\nVoIP 可用于包括 VoIP 电话、智能手机、个人计算机在内的诸多互联网接入设备，通过蜂窝网络、 Wi-Fi 进行通话及发送 短信。\nVOIP 技术栈 相关协议框架 SIP/SDP/RTP/RTCP/MRCP, 各种 codec\n常用 VOIP 开源框架： freeSWITCH，Asterisk，Kamailio/Opensips、rtpproxy 等\nPSTN VOIP 就是网络电话，PSTN 就是传统公共电话。\nfreeSWITCH signalwire/freeswitch FreeSWITCH is a Software Defined Telecom Stack enabling the digital transformation from proprietary telecom switches to a versatile software implementation that runs on any commodity hardware. From a Raspberry PI to a multi-core server, FreeSWITCH can unlock the telecommunications potential of any device.\nFreeSWITCH 权威指南\nAsterisk  Sofia-SIP BelledonneCommunications/sofia-sip Sofia-SIP is an open-source SIP User-Agent library, compliant with the IETF RFC3261 specification. It can be used as a building block for SIP client software for uses such as VoIP, IM, and many other real-time and person-to-person communication services. The primary target platform for Sofia-SIP is GNU/Linux. Sofia-SIP is based on a SIP stack developed at the Nokia Research Center. Sofia-SIP is licensed under the LGPL.\n"});index.add({'id':53,'href':'/note/docs/live/diary/2020/04/','title':"4 月",'content':"2020 年 4 月 本月计划     本月总结 "});index.add({'id':54,'href':'/note/docs/study/docs/type/pdf/','title':"pdf",'content':"pdf "});index.add({'id':55,'href':'/note/docs/live/diary/2020/04/22/','title':"2020-04-22",'content':"2020 年 4 月 22 日（星期三） 今日待办     编程 DCDN "});index.add({'id':56,'href':'/note/docs/live/diary/2020/06/22/','title':"2020-06-22",'content':"2020 年 6 月 22 日（星期一） 今日待办     编程 MB 与 Mb  网络通信领域：  一般是 bps  b 是 bit   因为在传输过程中传输的是具体的 0 和 1 不宜换算成字节。通常数据传输率是不用字节来表示的。 k=10 的 3 次方, M=10 的 6 次方 在通信网络中是非常不建议用字节来表示速率的 运营商所谓的 4M 宽带，指的就是数据率为 4Mb/s  非要换算成字节表示应该是 500kB/s（请注意这里一定是小写的 k）     计算机领域：  一般是 B  B 是 Byte   K=2 的 10 次方, M=2 的 20 次方     K 单独出现时，代表 1000 或 1024 K 与 Ki 一起出现时，K 代表 1000，Ki 代表 1024 K 与 k 一起出现时，K 代表 1024，k 代表 1000  参考：\n 关于网络带宽中 MB 与 Mb 中大小写的 B 有严格的定义吗？ KB / KiB，MB / MiB，GB / GiB，… 的区别是什么？ 一文看懂 Mbps、Mb/s、MB/s 有什么区别   手机与基站通信 参考：\n 4G 手机跟基站是怎么 “交流” 的   CPU 密集型 vs IO 密集型  惊群 惊群效应（thundering herd）是指多进程（多线程）在同时阻塞等待同一个事件的时候（休眠状态）， 如果等待的这个事件发生，那么他就会唤醒等待的所有进程（或者线程）， 但是最终却只能有一个进程（线程）获得这个时间的 “控制权”，对该事件进行处理， 而其他进程（线程）获取 “控制权” 失败，只能重新进入休眠状态， 这种现象和性能浪费就叫做惊群效应。\n惊群效应就是当一个 fd 的事件被触发时，所有等待这个 fd 的线程或进程都被唤醒。\n一般都是 socket 的 accept () 会导致惊群（当然也可以弄成一堆线程 / 进程阻塞 read 一个 fd，但这样写应该没什么意义吧）， 很多个进程都 block 在 server socket 的 accept ()， 一但有客户端进来，所有进程的 accept () 都会返回， 但是只有一个进程会读到数据，就是惊群。\n实际上现在的 Linux 内核实现中不会出现惊群了，只会有一个进程被唤醒（Linux2.6 内核）。\n使用 mutex 锁住多个线程是不会惊群的，在某个线程解锁后，只会有一个线程会获得锁，其它的继续等待。\n惊群效应消耗了什么 Linux 内核对用户进程（线程）频繁地做无效的调度、上下文切换等使系统性能大打折扣。上下文切换（context switch）过高会导致 CPU 像个搬运工，频繁地在寄存器和运行队列之间奔波，更多的时间花在了进程（线程）切换，而不是在真正工作的进程（线程）上面。直接的消耗包括 CPU 寄存器要保存和加载（例如程序计数器）、系统调度器的代码需要执行。间接的消耗在于多核 cache 之间的共享数据。 为了确保只有一个进程（线程）得到资源，需要对资源操作进行加锁保护，加大了系统的开销。目前一些常见的服务器软件有的是通过锁机制解决的，比如 Nginx（它的锁机制是默认开启的，可以关闭）；还有些认为惊群对系统性能影响不大，没有去处理，比如 Lighttpd。\n还有些认为惊群对系统性能影响不大，没有去处理，比如 Lighttpd。\nLinux 解决方案之 Accept Linux 2.6 版本之前，监听同一个 socket 的进程会挂在同一个等待队列上，当请求到来时，会唤醒所有等待的进程。\nLinux 2.6 版本之后，通过引入一个标记位 WQ_FLAG_EXCLUSIVE，解决掉了 accept 惊群效应。\nLinux 解决方案之 Epoll epoll 场景下如何预防惊群 惊群问题出现场景  Linux2.6 内核版本之前系统 API 中的 accept 调用\n在 Linux2.6 内核版本之前，当多个线程中的 accept 函数同时监听同一个 listenfd 的时候，如果此 listenfd 变成可读，则系统会唤醒所有使用 accept 函数等待 listenfd 的所有线程（或进程），但是最终只有一个线程可以 accept 调用返回成功，其他线程的 accept 函数调用返回 EAGAIN 错误，线程回到等待状态，这就是 accept 函数产生的惊群问题。但是在 Linux2.6 版本之后，内核解决了 accept 函数的惊群问题，当内核收到一个连接之后，只会唤醒等待队列上的第一个线程（或进程），从而避免了惊群问题。 epoll 函数中的惊群问题\n如果我们使用多线程 epoll 对同一个 fd 进行监控的时候，当 fd 事件到来时，内核会把所有 epoll 线程唤醒，因此产生惊群问题。为何内核不能像解决 accept 问题那样解决 epoll 的惊群问题呢？内核可以解决 accept 调用中的惊群问题，是因为内核清楚的知道 accept 调用只可能一个线程调用成功，其他线程必然失败。而对于 epoll 调用而言，内核不清楚到底有几个线程需要对该事件进行处理，所以只能将所有线程全部唤醒。 线程池中的惊群问题\n在实际应用程序开发中，为了避免线程的频繁创建销毁，我们一般建立线程池去并发处理，而线程池最经典的模型就是生产者 - 消费者模型，包含一个任务队列，当队列不为空的时候，线程池中的线程从任务队列中取出任务进行处理。一般使用条件变量进行处理，当我们往任务队列中放入任务时，需要唤醒等待的线程来处理任务，如果我们使用 C++ 标准库中的函数 notify_all () 来唤醒线程，则会将所有的线程都唤醒，然后最终只有一个线程可以获得任务的处理权，其他线程在此陷入睡眠，因此产生惊群问题。  惊群问题解决办法  对于 epll 函数调用的惊群问题解决办法可以参考 Nginx 的解决办法，多个进程将 listenfd 加入到 epoll 之前，首先尝试获取一个全局的 accept_mutex 互斥锁，只有获得该锁的进程才可以把 listenfd 加入到 epoll 中，当网络连接事件到来时，只有 epoll 中含有 listenfd 的线程才会被唤醒并处理网络连接事件。从而解决了 epoll 调用中的惊群问题。 对于线程池中的惊群问题，我们需要分情况看待，有时候业务需求就是需要唤醒所有线程，那么这时候使用 notify_all () 唤醒所有线程就不能称为\u0026rdquo; 惊群问题 \u0026ldquo;，因为 CPU 并没有无谓消耗。而对于只需要唤醒一个线程的情况，我们需要使用 notify_one () 函数代替 notify_all () 只唤醒一个线程，从而避免惊群问题。  参考：\n 什么是惊群，如何有效避免惊群？   进程间的通信方式 http 2.0 相比 http 1.1 有哪些改进 列举常用的数据结构、各自的特点和使用场景 如何防范 SQL 注入 如何分析 core 文件 core dump 又叫核心转储，当程序运行过程中发生异常，程序异常退出时，由操作系统把程序当前的内存状况存储在一个 core 文件中，叫 core dump. (linux 中如果内存越界会收到 SIGSEGV (11) 信号，然后就会 core dump)\nfind core 文件 sudo find / -regex \u0026#34;.*/core\\.[0-9]*\u0026#34; 参考：\n linux core dump 文件 gdb 分析  如何发现在同一个家庭网络下的网络设备  医院排名 中国医院排行榜 （复旦版）医院排名  MacOS netstat # UDP 端口占用 netstat -tulnvp udp | head -n2 \u0026amp;\u0026amp; netstat -tulnvp udp | grep 5064 "});index.add({'id':57,'href':'/note/docs/live/diary/2020/03/','title':"3 月",'content':"2020 年 3 月 本月计划  Istio Handbook 开源电子书  Istio Handbook 编委会  会议（周五 2020-03-13 20:00-21:00）  Kickoff 文档 合作编辑 Handbook 目录       AI2B 研发   本月总结 "});index.add({'id':58,'href':'/note/docs/study/book/','title':"4.1 读书",'content':"读书 "});index.add({'id':59,'href':'/note/docs/live/diary/','title':"5.1 日记",'content':"叶王日记 "});index.add({'id':60,'href':'/note/docs/study/docs/note/codelabs/','title':"Codelabs",'content':"Codelabs 简介 Google Developers Codelabs 中国内地访问 clmirror.storage.googleapis.com\n Hello Istio Codelab(with Google Kubernetes Engine)  googlecodelabs/tools Codelabs management \u0026amp; hosting tools\n"});index.add({'id':61,'href':'/note/docs/study/docs/type/epub/','title':"epub",'content':"epub "});index.add({'id':62,'href':'/note/docs/study/docs/note/hugo/','title':"Hugo",'content':"Hugo 快速上手 简介 参考官网：https://gohugo.io\n"});index.add({'id':63,'href':'/note/docs/humanities/language/chinese/','title':"中文",'content':"中文 "});index.add({'id':64,'href':'/note/docs/study/docs/draw/','title':"作图",'content':"作图 "});index.add({'id':65,'href':'/note/docs/social/economic/insurance/','title':"保险",'content':"保险 普通家庭面对的主要风险  应该购买哪些保险 对于咱们平常人，只需要配置 1+4+X 即可。\n 1 指的是社保 4 指的是四大人身险，包括重疾险、医疗险、意外险、定期寿险 X 指的是一些比较合适的财产险，比如车险、家财险等。  至于保险公司的年金险、教育金、养老金种种，我虽然不能一棍子打死说不买，\n但是，很局限\u0026hellip;\u0026hellip;\n购买建议 务必配上社保，\n重疾险优先做高保额到 50 万，\n医疗险着重看续保条件\n意外险选一年期的\n寿险选定期的，\n家财险要看地区。\n慎买年金险，不买返还型。\n 保险分类 重疾险 所谓重疾险，保的是重大疾病，\n比如癌症，比如心脑血管疾病。\n一旦身患重疾，不仅治疗需要费用，而且可能几年无法工作，造成了很大损失。\n而重疾险是给付型，也就是某些销售人员口中的 \u0026ldquo;确诊即赔\u0026rdquo;。\n一旦某些疾病达到理赔标准，会把钱一次性给你， 买了 50 万保额的重疾险，保险公司会把 50 万的保额直接打到账上。\n这笔钱，不管是用来治疗疾病，还是康复护理，还是用来还得病期间的房贷、车贷，都可以。\n可以买多份。\n保额 保额先行，优先把保额做高到 50 万。\n成人和孩子都建议买上一份。\n老年人一般买不了重疾险，退而求其次买防癌险。\n保费 30 岁男，保终生，交 30 年，每年保费应该在\n 4300-5000 左右（轻症/中症，多次赔付，身故责任均不含）。 4800-5500 左右（包含轻症/中症）  附加轻症只需要多掏 25% 左右的钱    责任重要程度  百万医疗险 百万医疗险是报销制，花多少报销多少。\n它可以说是家庭最为实用的保险，人人都该买上一份。\n如果中老年人，身体条件不能买百万医疗险，也可以退而求其次买防癌医疗险。\n优良 如果能做到阶段性保证续保的，像是保证续保 6 年的，属于优良。\n包括支付宝上卖得好医保长期医疗和微信上卖得微医保长期医疗都在此列。\n次优的 次优的，还有一种产品，\n只要不停售，不管健康状况发生什么变化，都可以接着买，也不会单独提高保费。\n比如尊享一生、平安 E 生保等等。\n这类产品，也是过关的，可以放心购买。\n 意外险 所谓意外，一定要满足：外来的、突发的、非本意的非疾病这几个条件。\n像中暑（不是突发）、自残自杀（不是非本意）都不在保障范围。\n再像猝死，本来猝死大多是因疾病造成的，按照定义不该保的，但是现在很多意外险都加上了这一项。\n那什么是意外呢？\n大到交通事故、台风地震、溺水触电；\n小到跌打损伤，猫抓狗咬、割伤烫伤。\n都在意外险的射程范围以内。\n没必要买长期意外险 一年期的意外险，续保容易，保费便宜，50 万保额不超过 200 块，一年一买即可。\n完全没必要买长期意外险，切忌买返还型意外险，它们通常要贵几倍甚至几十倍。\n 定期寿险 寿险，保险责任非常简单，在保障期间内，身故或全残才会赔。\n一个家庭经济支柱，上有老下有下，这时候要是不在了，不仅不能给家庭带来收入，而且把债务都留给了家庭。\n寿险就是为了解决这个问题而生，寿险为的是哪怕有一天人没了，也能把未来该赚的钱留下来，作为遗产为家庭继续做贡献。\n寿险可分为三类：一年期寿险、定期寿险、终身寿险\n一年期寿险短期便宜，但中长期看保费较贵，而且续保还存在问题，不建议。\n终身寿险保终身，人固有一死，也就是说这笔钱迟早会拿回来，但是保费过高，不适用于普通家庭。\n对于 90% 以上的家庭来说，最适合买的是定期寿险。\n所谓定寿，就是在保障期限内身故，就会获得一笔赔付，这里的身故包括疾病、意外、自然身故，甚至投保两年后自杀也能获得赔付。\n定寿的保障期限一般到 60 岁 /70 岁即可。\n等到老了，孩子长大了，身上担子就轻了很多，家中的主要劳动力不是自己了，就没什么必要买寿险了。\n至于保额，重点考虑自己不在了会为家庭带来多少损失。\n一般来说，\n定期寿险保额 整个家庭寿险的总保额 = 家庭负债和贷款 + 子女教育费用 + 父母赡养费用 +5 年的家庭消费开支。\n家庭主要收入者买即可 孩子和老人家庭责任较轻，切忌给他们买。\n 家财险 现在的一套房子，动不动就是一家三代人的心血和汗水，金贵得很。\n火烧、水淹、炸毁、地震，无论发生哪种痛失家园，都是我们不想看到的。\n那就不妨配上一份家财险，每年一两百块的投入，就能覆盖上百万的损失。\n挑选家财险没有什么花头，建议针对自家区域有针对性的保障。\n在沿海地区的，重点看看台风保障够不够；\n住在山区的，重点看泥石流；\n在地震高发区的，重点看地震保障；\n如果小区频繁失窃，就重点看是否包含防盗责任。\n买了房屋险后，万一倒霉，就再也不用求爷爷告奶奶了，直接找保险公司理赔即可。\n几百块买个心安，非常划算。\n 保费构成  保险产品细节 买保险很简单，\n相同的责任，\n哪款便宜选哪款。\n疾病责任 重疾 保监会就是为了防止保险公司该赔的不赔，一刀给切了 25 种重疾，规范了这 25 种重疾的定义。 而这 25 种占到了实际理赔的 95%，覆盖了最主要的疾病。\n 对比了两种产品对 25 种重疾的定义\n由于 X 安福的购买年龄限定在 18-65 周岁，18 岁以下可以买的是少儿 X 安福。\n所以，双目失明、双耳失聪、语言能力丧失这三种病，超级 X 丽旗舰版和 X 安福的定义之间是没有任何差别的。\n那么，我们可以放心地说，这核心的 25 种病的定义是一模一样的，之间一点点差别都没有。\n注意，这只是个例子，\n不是说只有这两款产品没差别，\n而是说市面上所有产品，对这 25 种重疾的定义都没有差别。\n那么，对占到实际理赔 95% 的重疾定义，都是被严格控制住的。\n那么至于剩下的 5%，就是各家自由发挥了，\n没有谁比谁强。\n如果哪家产品说，我赔 100 种，你赔 80 种，我产品好。\n那就是在忽悠你。\n如果哪家产品说，我赔某病（如：艾格门森综合征），你们不赔。\n那也是在忽悠你。\n如果哪家产品说，我都某个疾病定义更宽松，持续 90 天就能赔，别人都是 180 天才会赔。\n那还是在忽悠你。\n这些东西，说破天去，最多也就 5% 的差别。\n轻症 / 中症 高发的轻症/中症\n即便银保监会没有统一规范的轻症/中症，其结果也是走上了同质化。\n为什么？\n因为 \u0026ldquo;市场的手\u0026rdquo;。\n还记得之前 X 安福不带高发的不典型心梗、冠状介入、微创冠状动脉搭桥术，被全网黑成翔。\nX 安福在新升级的版本里，也不得不带上了高发。\n只有同质化，保险公司省去试错的成本，也更容易得到市场更广泛的认可。\n死亡责任 这两款产品的死亡责任一模一样，连免责条款都一模一样。\n本来就是这样，\n所有牵扯到死亡责任的，区别非常非常非常小。\n除非买的是意外险，\n人家都叫意外险了，肯定只赔意外死亡啊。\n其他责任 也没太大差别\u0026hellip;\u0026hellip;\n正如我们前面提到的严监管背景下，\n产生的结果并不是 A 保险赔 B 保险不赔，\n而是非常严重的同质化。\n重疾险 / 重疾责任是这样，寿险 / 寿险责任是这样，意外险 / 意外责任也是这样，\n甚至连主打服务差异的医疗险，近年来也有趋同的倾向。\n如果两款产品是一模一样的，\n我们又凭什么多掏钱？\n接着说回纯保费和附加保费。\n纯保费在定价端其实是有差别的，但对于相同的责任，在咱老百姓眼里，就是没差别。\n可附加保费上的差异，真真的是肉眼可见。\n 保险相关知识 投保人豁免是什么 投保人豁免，就是一旦投保人发生条款约定的情形，经保险公司同意，即可免交后续保费，保险合同继续生效。\n健康告知宽松 对于健康的人来说，无所谓。\n对于有小毛病的人来说，涉及到能不能买的问题，还是很重要的。\n 注意点 保险公司大小无所谓 都很安全 保险是金融产品，要受银保监会的监管。 而银保监会可以提供八重保障，为我们保驾护航： 理赔率差不多 绝大多数的保险公司，理赔率都能达到 97% 以上，大小公司并不存在明显的差异。\n理赔速度差不多 投诉率差不多 服务评级 银保监会每年都会提供服务评级\n 意外险没必要买长期的 意外险健康告知宽松，基本不存在续保问题。\n而长期意外险比短期意外险贵不少。\n 50 万的保额的上海人寿小 X 蜂，每年 125 元。\n 不要买返还型保险 缴费期越长越好 对于同一款保险，缴费期越长越好，当然最后这笔钱还是要交的。\n 参考  一文揭露保险真相！95% 的家庭都买错了！ 今天，我把返还型保险的底裤扒下来了  "});index.add({'id':66,'href':'/note/docs/study/degree/masters-degree/on-job-postgraduate/','title':"在职硕士",'content':"在职硕士 非全日制硕士 流程  参加 12 月统考 完成学业、修满学分 论文答辩，拿到硕士学历证书与硕士学位证书   同等学力申硕 流程  直接入学 参加课程研修班，通过考试，拿到结业证书 参加五月同等学力申硕 论文答辩，拿到硕士学位证书  课程研修班 根据国务院学位委员会、教育部（2013）36 号文件，自 2014 年起，原 \u0026ldquo;在职研究生班\u0026rdquo; 更名为 \u0026ldquo;课程研修班\u0026rdquo;，在职人员申请硕士学位流程及要求不变\n"});index.add({'id':67,'href':'/note/docs/live/parenting/basic/practice/','title':"实践",'content':"实践 "});index.add({'id':68,'href':'/note/docs/study/domain/operate/tutorial/','title':"教程",'content':"教程 书籍 有哪些互联网运营方面的书值得推荐？\n"});index.add({'id':69,'href':'/note/docs/study/book/natural/math/','title':"数学",'content':"数学 "});index.add({'id':70,'href':'/note/docs/study/docs/type/','title':"文档类型",'content':"文档类型 "});index.add({'id':71,'href':'/note/docs/natural/','title':"第一部分 自然科学",'content':"自然科学 "});index.add({'id':72,'href':'/note/docs/study/book/natural/','title':"自然科学",'content':"自然科学 "});index.add({'id':73,'href':'/note/docs/study/course/natural/','title':"自然科学",'content':"自然科学 "});index.add({'id':74,'href':'/note/docs/study/book/natural/cs/','title':"计算机科学",'content':"计算机科学 "});index.add({'id':75,'href':'/note/docs/study/course/natural/cs/','title':"计算机科学",'content':"计算机科学 "});index.add({'id':76,'href':'/note/docs/live/diary/2020/04/21/','title':"2020-04-21",'content':"2020 年 4 月 21 日（星期二） 今日待办     编程 EdgeGallery EdgeGallery 是什么？ EdgeGallery 是华为联合运营商，垂直行业伙伴发起的一个 MEC 边缘计算开源项目。目的是打造一个符合电信产业 “联接 + 计算” 特点的边缘计算公共平台，实现网络能力（尤其是 5G 网络）开放的标准化和 MEC 应用开发、测试、迁移和运行等生命周期流程的通用化。\nEdgeGallery 可以作为 Akraino 的上游项目，在 Akraino 里面可以立项新的面向 5G MEC 的 BP，把 EdgeGallery 作为 MEC 的 PaaS 层，然后集成其他的组件，比如 OpenStack、K8S、ONAP 等来形成一个完成的解决方案堆栈。\nEdgeGallery 要解决什么问题？ EdgeGallery 要解决的是运营商 MEC 边缘计算平台的标准不统一带来的生态碎片化，产业规模做不大的问题。\nMEC 是 5G 时代运营商新的蓝海市场，通过 MEC 平台，运营商可以把 “联接 + 计算” 的能力开放给行业应用，获取行业数字化的价值红利。\nMEC 本质上是一个面向开发者的 ICT 基础设施市场，竞争力体现在为应用开发者提供的软件基础平台和工具链的丰富程度，市场结果体现在应用生态的丰富程度。\n运营商对软件平台的研发传统模式是采用联合 ISV 进行定制开发的模式，如果 MEC 平台也采用传统模式，自然会导致不同运营商的 MEC 平台接口不一致，工具链不兼容。全球运营商很多，每个运营商都是区域化运营，这就自然的形成很多碎片化市场。\n应用和解决方案往往需要针对不同平台进行应用的定制开发，这导致巨大的学习成本和开发成本，结果就是大部分开发者无法承受这样的成本而放弃，或者转到公有云的平台上。\n华为联合运营商一起，通过开源来打造一个公共的 MEC 平台和相关工具链，就是为了让整个电信产业形成统一的 MEC 标准，一起做大 MEC 的市场空间。\nEdgeGallery 的使命愿景是什么？ EdgeGallery 社区聚焦在运营商网络边缘 MEC 平台框架，通过开源协作构建起 MEC 边缘的资源、应用、安全、管理的基础框架和网络开放服务的事实标准，并实现同公有云的互联互通。在兼容边缘基础设施异构差异化的基础上，构建起统一的 MEC 应用生态系统。\nETSI MEC ISG ETSI MEC ISG 定义了 MEC 的概念、术语、参考架构和一些基本服务的 API，但是 ETSI 的相关标准是文档，不是具体的实现，也不会规定具体的软件架构和模块实现。另外 ETSI 的标准也是处于不断更新的过程中。\nEdgeGallery 是 ETSI MEC 的参考实现，EdgeGallery 在实现相关功能和 API 的过程中，会充分参考和借鉴 ETSI 的相关定义和标准。同时 EdgeGallery 也会根据实践过程中的场景需求，灵活调整和优化相关标准，并通过实践来验证这些修改。相关的修改会反过来提交到 ETSI 标准组织，促进 ETSI 标准的优化和成熟。\n参考：\n EdgeGallery 社区   LF Edge LF Edge 的 5 个项目包括\n Akraino Edge Stack EdgeX Foundry Open Glossary of Edge Computing Home Edge EVE  其中 Akraino Edge Stack，EdgeX Foundry 和 Open Glossary of Edge Computing 以前都是 Linux 基金会的独立项目。\nHome Edge 项目是由三星电子提供的一个新项目，该项目将为了收集智能家居设备的实时数据而创建的平台。ZEDEDA 提供了 EVE，一种新的硬件无关的边缘应用框架。\nAkraino Edge Stack Akraino Edge Stack 是一个 Linux 基金会项目，支持针对边缘计算系统和应用程序优化的高可用性云服务。\nEdgeX Foundry EdgeX Foundry 用一句话来介绍，就是 Linux 基金会下的硬件和操作系统无关的开源中立的边缘计算微服务框架，用于统一工业物联网边缘计算解决方案的生态系统。\n 深圳 5G 实验网 CAICT 中国信通院\n实验网\n 独立的承载网与核心网 共享基站  骨干实验网 端到端 100G\n覆盖 8 个城市\n"});index.add({'id':77,'href':'/note/docs/study/docs/type/mobi/','title':"mobi",'content':"mobi mobi vs azw3 "});index.add({'id':78,'href':'/note/docs/live/diary/2020/04/20/','title':"2020-04-20",'content':"2020 年 4 月 20 日（星期一） 今日待办     编程 TSN 时间敏感网络 参考：\n 实时物联网 RT-IoT 终于有了自己的专属通讯网络 TSN！ 下一代工业通信 —TSN（时间敏感网络），工业物联网的助推器  cloudvr， tsn，物联网\n5G 的大带宽，低时延，广连接\nCloud Native 云原生 什么是云原生 2018 年 CNCF 更新了云原生的定义。\n这是新定义中描述的代表技术，其中容器和微服务两项在不同时期的不同定义中都有出现，\n而服务网格这个在 2017 年才开始被社区接纳的新热点技术被非常醒目的列出来，和微服务并列，而不是我们通常认为的服务网格只是微服务在实施时的一种新的方式。\nCloud Native 翻译为云原生，是 Matt Stine 提出的一个概念，它是一个思想的集合，\n包括 DevOps、 持续交付（Continuous Delivery）、微服务（MicroServices）、敏捷基础设施（Agile Infrastructure）、康威定律（Conways Law）等，以及根据商业能力对公司进行重组。\nCloud Native 既包含\n 技术（微服务，敏捷基础设施）， 也包含管理（DevOps，持续交付，康威定律，重组等）。  Cloud Native 也可以说是一系列 Cloud 技术、企业管理方法的集合。\n参考：\n CNCF Cloud Native Definition v1.0  云原生代表技术 云原生的代表技术包括容器、服务网格、微服务、不可变基础设施和声明式 API。\n不可变基础设施 在传统的可变服务器基础架构中，服务器会不断更新和修改。\n使用此类基础架构的工程师和管理员可以通过 SSH 连接到他们的服务器，手动升级或降级软件包，逐个服务器地调整配置文件，以及将新代码直接部署到现有服务器上。\n换句话说，这些服务器是可变的；它们可以在创建后进行更改。\n不可变基础架构的好处包括基础架构中更高的一致性和可靠性，以及更简单，更可预测的部署过程。\n它可以缓解或完全防止可变基础架构中常见的问题，例如配置漂移和雪花服务器。\n宠物与牛群 pets 是独一无二，无法模仿，失去一个可能是毁灭性的。\n牛群中的众多群体中没有一个人是独一无二或不可或缺的。\n雪花服务器与凤凰服务器 snowflakes 服务器类似于宠物。它们是手工管理的服务器，经常更新和调整到位，从而形成独特的环境。\nPhoenix 服务器与牛类似。它们是始终从头开始构建的服务器，并且易于通过自动化过程重新创建（或 “从灰烬中升起”）。\n参考：\n 什么是不可变的基础设施？  Tutum tutum (now Docker)\n参考：\n 如何更好地使用容器技术实现不可变基础设施   云原生应用 理想的云原生应用应该是这个样子：业务需求的实现占主体，只有少量的非业务需求相关的功能。\n参考：\n 未来已来：云原生 Cloud Native  梳理后端架构演化史，回顾后端架构发展历程； 回顾云服务发展历程，探讨云原生概念； 梳理云原生实现方案 Service Mesh 的发展历程； 介绍 Service Mesh 的代表 Istio 的亮眼功能；   畅谈云原生（上）：云原生应用应该是什么样子？ 云原生与无服务器架构是云计算的未来吗？—— 云计算的演进   Service Mesh vs Serverless Service Mesh 技术和 Serverless 技术是工作在不同纬度的两个技术：\n Service Mesh 技术的关注点在于服务间通讯，其目标是剥离客户端 SDK，为应用减负，提供的能力主要包括安全性、路由、策略执行、流量管理等。 Serverless 技术的关注点在于服务运维，目标是客户无需关注服务运维，提供服务实例的自动伸缩，以及按照实际使用付费。  理论上 Service Mesh 技术和 Serverless 技术并没有冲突的地方，可以结合使用。事实上目前业界也开始出现这个趋势，而融合的方式有两种：\n在 Serverless 中引入 Service Mesh 典型如 Knative 项目和 Knative 的 Google Cloud 托管版本 Google Cloud Run，通过引入对容器的支持和使用 Istio，Knative 将 Serverless 的支持扩展到 Function 之外，在极大的扩展 Serverless 适用范围的前提下，也将服务间通讯的能力引入到 Serverless。\n在 Service Mesh 中引入 Serverless 典型如 Google Traffic Director 产品，在提供 Service Mesh 各种能力的同时，支持按照流量自动伸缩服务的实例数量，从而融入了部分 Serverless 的特性。\n对于 Serverless 和 Service Mesh 的结合，我们展望未来形态：\n未来应该会出现一种新型服务模式，Serverless 和 Service Mesh 合二为一。只要将服务部署上来，就自动可以得到 Service Mesh 的服务间通讯能力和 Serverless 的无服务器运维。\nService Mesh 发展趋势：云原生中流砥柱（下）\n Netflix OSS Netflix OSS 是一组框架和库，Netflix 为大规模解决一些有趣的分布式系统问题而编写的。\n今天，对于 Java 开发人员来说，它非常适合云环境中开发微服务。\n服务发现、负载平衡、容错等模式对于可扩展的分布式系统来说是非常重要的概念，Netflix 为此提供了很好的解决方案。\n参考：\n Spring Cloud、K8S、Netflix OSS 三者啥关系？   康威定律 康威定律 (康威法则，Conway\u0026rsquo;s Law) 是马尔文・康威 1967 年提出的： \u0026ldquo;设计系统的架构受制于产生这些设计的组织的沟通结构。\u0026rdquo;\n即系统设计本质上反映了企业的组织机构。\n系统各个模块间的接口也反映了企业各个部门之间的信息流动和合作方式。\n康威的原文中提出的各定律：\n 第一定律 组织沟通方式会通过系统设计表达出来 第二定律 时间再多一件事情也不可能做的完美，但总有时间做完一件事情 第三定律 线型系统和线型组织架构间有潜在的异质同态特性 第四定律 大的系统组织总是比小系统更倾向于分解  参考：\n 每个架构师都应该研究下康威定律  "});index.add({'id':79,'href':'/note/docs/live/diary/2020/05/20/','title':"2020-05-20",'content':"2020 年 5 月 20 日（星期三） 今日待办     编程 "});index.add({'id':80,'href':'/note/docs/live/diary/2020/06/20/','title':"2020-06-20",'content':"2020 年 6 月 20 日（星期六） 今日待办     编程 Ubuntu 版本    Version Code name Release date General support until Security support (ESM) until     14.04 LTS Trusty Tahr 2014-04-17 2019-04 2022-04   16.04 LTS Xenial Xerus 2016-04-21 2021-04 2024-04   18.04 LTS Bionic Beaver 2018-04-26 2023-04 2028-04   19.10 Eoan Ermine 2019-10-17 2020-07 n/a   20.04 LTS Focal Fossa 2020-04-23 2025-04 2030-04   20.10 Groovy Gorilla 2020-10-22 2021-07? n/a    "});index.add({'id':81,'href':'/note/docs/study/docs/type/azw3/','title':"azw3",'content':"azw3 azw3 vs azw "});index.add({'id':82,'href':'/note/docs/live/diary/2020/04/19/','title':"2020-04-19",'content':"2020 年 4 月 19 日（星期日） 今日待办     编程 github 周报 开发 probot https://github.com/probot/probot\nweekly-digest https://github.com/probot/weekly-digest\nrepo-report octokit github rest api 库\n参考文档  octokit docs github api docs  github api 限制 老是出现错误\nconnect ECONNREFUSED 13.250.168.23:443\n javascript print object // print object str = JSON.stringify(obj); console.log(`obj ============== : ${str}`); 星期几配置判断 根据给的周几的字符串（前缀就行），获取第几天\nfunction getNumDayFromLongDay(day) { if (typeof day === \u0026#34;number\u0026#34; \u0026amp;\u0026amp; day \u0026gt;= 0 \u0026amp;\u0026amp; day \u0026lt; 7) { return day; } else { const longDay = [ \u0026#34;sunday\u0026#34;, \u0026#34;monday\u0026#34;, \u0026#34;tuesday\u0026#34;, \u0026#34;wednesday\u0026#34;, \u0026#34;thursday\u0026#34;, \u0026#34;friday\u0026#34;, \u0026#34;saturday\u0026#34;, ]; for (let i = 0; i \u0026lt; 7; i++) { if (longDay[i].includes(String(day).toLowerCase())) { return i; } } } return undefined; } "});index.add({'id':83,'href':'/note/docs/live/diary/2020/05/19/','title':"2020-05-19",'content':"2020 年 5 月 19 日（星期二） 今日待办     编程 TLS rfc5246\nTLS 握手流程 TLS 是一个信道建立和信道的表达方式，向下依托于 TCP，向上对应用程序服务。\n 1994 年，NetScape 公司设计了 SSL 协议（Secure Sockets Layer）的 1.0 版，但是未发布。\n  1995 年，NetScape 公司发布 SSL 2.0 版，很快发现有严重漏洞。\n  1996 年，SSL 3.0 版问世，得到大规模应用。\n  1999 年，互联网标准化组织 ISOC 接替 NetScape 公司，发布了 SSL 的升级版 TLS 1.0 版。\n  2006 年和 2008 年，TLS 进行了两次升级，分别为 TLS 1.1 版和 TLS 1.2 版。最新的变动是 2018 年 TLS 1.3 的修订版。\n  DTLS 就是同样的 TLS 逻辑被应用于 UDP 业务之上\n OpenSSL 切换 openssl 版本 $ ls -l /usr/local/opt/openssl* lrwxr-xr-x 1 yewang admin 24 May 19 10:16 /usr/local/opt/openssl -\u0026gt; ../Cellar/openssl/1.0.2s lrwxr-xr-x 1 yewang admin 24 May 19 10:16 /usr/local/opt/openssl@1.0 -\u0026gt; ../Cellar/openssl/1.0.2s lrwxr-xr-x 1 yewang admin 28 May 18 20:25 /usr/local/opt/openssl@1.1 -\u0026gt; ../Cellar/openssl@1.1/1.1.1g $ brew switch openssl 1.0.2s Kubernetes configmap  ffmpeg linux 安装 ffmpeg\nhttps://www.tecmint.com/install-ffmpeg-in-linux/\nffmpeg -re -i car-brand.MOV -rtsp_transport tcp -vcodec h264 -f rtsp rtsp://localhost/test ffplay # 添加到 ~/.zshrc function rtsp() { ffplay -analyzeduration 1000000 -fflags nobuffer -probesize 32 -sync ext $@ } "});index.add({'id':84,'href':'/note/docs/live/diary/2020/06/19/','title':"2020-06-19",'content':"2020 年 6 月 19 日（星期五） 今日待办     编程 Go 类型转化\nnum := dat[\u0026#34;num\u0026#34;].(float64) 类型推断\nnewA, ok := a.(string) func checkType(i interface{}) { // 这里是通过 i.(type) 来判断是什么类型  // 下面的 case 分支匹配到了，则执行相关的分支  switch v := i.(type) { case int: fmt.Printf(\u0026#34;%v is an int\u0026#34;, v) case string: fmt.Printf(\u0026#34;%v is string\u0026#34;, v) case bool: fmt.Printf(\u0026#34;%v is bool\u0026#34;, v) } }  产品文档 需求分析文档 前期分析阶段中，需求方主要是与产品经理进行沟通，产出文档有三种：\nBRD 文档（Business Requirement Document） 商业需求文档，基于商业目标或价值所描述的产品需求内容文档（报告）。\nMRD 文档（Market Requirement Document） 市场需求文档，该文档在产品项目过程中属于「过程性」文档，由产品经理或者市场经理编写的一个产品说明需求的文档。\nPRD 文档（Product Requirement Document） 产品需求文档是将商业需求文档（BRD）和市场需求文档（MRD）用更加专业的语言进行描述。\n 系统设计文档 总体设计文档 详细设计文档 数据库表设计文档  用户手册 API 文档 "});index.add({'id':85,'href':'/note/docs/live/diary/2020/06/18/','title':"2020-06-18",'content':"2020 年 6 月 18 日（星期四） 今日待办     编程 ZLMediaKit 开发 安装依赖库 MacOS cd ZLMediaKit mkdir build cd build # 查看 openssl 的路径 cmake .. -DOPENSSL_ROOT_DIR=/usr/local/Cellar/openssl@1.1/1.1.1g/ make -j4 Debian Debian 系 (包括 ubuntu）\n# 除了openssl,其他其实都可以不安装 sudo apt-get install libssl-dev sudo apt-get install libsdl-dev sudo apt-get install libavcodec-dev sudo apt-get install libavutil-dev sudo apt-get install ffmpeg Windows  构建和编译 MacOS cd ZLMediaKit mkdir build cd build cmake .. -DOPENSSL_ROOT_DIR=/usr/local/Cellar/openssl@1.1/1.1.1g/ make -j4 Linux Windows  FFmpeg # 推流操作 ffmpeg -f x11grab -i :0.0+0,0 -s 640x480 -r 10 -vcodec libx264 -preset ultrafast -acodec libmp3lame -ar 44100 -ac 1 -f flv rtmp://*** # 拉流播放 ffplay rtmp://*** 拉流 vs 推流  推流：客户端（发起） -\u0026gt; 服务器 拉流：服务器 -\u0026gt; 客户端（发起）   "});index.add({'id':86,'href':'/note/docs/live/diary/2020/04/17/','title':"2020-04-17",'content':"2020 年 4 月 17 日（星期五） 今日待办     编程 TSF (Tencent Service Framework) 腾讯微服务平台\nTSF Serverless Serverless 微服务平台\nTSF Mesh Mesh 微服务平台\n 互联网巨头常用词汇 腾讯 精品、微创新、正能量、打法、发力、精细化、闭环、布局、商业模式、联动、泛娱乐、场景、痛点、减法、落地、聚焦、我们查下、跟进、不忘初心、方法论、迭代、快速响应、影响力、全栈、价值、细分、大数据、垂直领域、维度、颗粒、定性定量、聚焦、去中心化、关键路径、干货、接地气、梳理、输出、格局、生态、沉淀、结果导向、套路、用户体验、眼界、话术、体系、对齐、同步、认知、分享、面交、去中心化、勾兑、流程、感知度、赞、加速、用户画像、打磨、摸索、提炼、玩法、反哺、阈值。\n阿里巴巴 价值观、颠覆、拥抱、改变、相信、基础设施、电子商务生态系统、企业社会责任、造福社会、理想主义、阿里云、技术、第五大经济体、促进进口、阿里人、野心、鲶鱼、DT 战略、全球化、营业额、改变世界、团队精神、知识产权、打假、情怀、挣一块钱、脱贫、平台公益、利益共同体、生态化发展、引爆消费力、农村经济、赋能、把控能力、专业化人才、战略踩空、无人区、练兵场、倒逼、互联网下半场。\n百度 人工智能、无人驾驶、交互、刷脸、车、永久免费、更懂你、革新、迎接、技术创新、梦想、生态链、未来已来、智能营销、降维攻击、转变、可能性、搜索场景、AI 思维、洞察、开放能力、深度学习、人脸识别、万物互联、数字化、风口、精准识别、云端仿真、共享、感知、海量数据、赋能、开发者。\n今日头条 独立发展、不上市、连接、用户体验、粉丝分发、跨越式机遇、新责任、未来、用户需求、概念推导、内容生态、国际化、体量、创作者、规模效应、平台属性、数字经济、估值、融资、智能社交、超级内容平台、颗粒度、价值创造、视频化、增长点、出海、流量红利、产品渗透率、拥抱 AI、模式重构、信息分发、人工智能实验室、算法、技术、数据挖掘、趋势、变革、内容创业、涨粉、赚钱、自媒体人、用户、创作者、构建、打击低俗信息、覆盖、粘性、精准、内容分发、产品体验、反馈、平台级公司、回馈、版权保护。\n网易 猪厂、养猪、一日五餐、考拉上新货了、严选上新货了、代购、我们公司自己做的、我们公司自己养的、我们公司自己卖的、创新、品味、精品、工匠精神、匠心、新消费、泛中产、生活家、正品、世界级品质、用户体验、模式创新、中国智造、美好生活、丁磊同款、非典型、网易特色、走心、有毒营销、IP 营销、戏精、扎心、套路、竞争壁垒、差异化、价值、公益、企业家精神、有态度、各有态度、好的老板、广告公司、段子手、又双叒震荡了、工资回收计划、丁爸爸喊你 XXX。\n京东 电商、亏损、商品流通、综合零售、物流网、供应链、智能商业体、技术转型、短链、成本管控、正道成功、世界 500 强、B2C、智慧化、重构、产业链、共生、品牌附加值、白条、无人仓、无界零售、一体化、倒三角战略、一体化、整合、流量端、竞争求异、盟国思维、赋能、O2O、云端服务、一锤子买卖、终端、库房、产业价值、最后一公里。\n滴滴出行 小桔人、合理定价、用户价值、我要打车、神器、美好出行、智能派单、服务、足迹、系安全带、车主和司机、线上、打破价格僵局、尊享五星级出行服务、平台、智能交通、全球领先、随叫随到、将你安全带向爱、网约车、竞争壁垒、创新、包容性、出租车产业转型升级、私家车保有量、挑战、共享汽车、大数据。\n参考：\n 腾讯阿里等互联网巨头常用词汇，泄露了哪些商业机密？   产品经理必知词汇 UCD User Centered Design\n是一种设计思维、模式，指以用户为中心的设计。\n在设计过程中以用户体验为设计决策的中心，强调用户优先的设计模式。\n先不要考虑盈利，先让用户用的爽再说。\nAIOT 智联网 (AIOT，是 AI + IOT 物联网的结合) 2018 年开始崛起，核心是能够运用大量传感设备，综合语音、视觉、动作、温度等数据，实现 IOT 设备的全自然化的人机交互。\n物联网喊了好多年；体验提升太有限；如今终于有突破；人机交互成关键。\nAM 敏捷开发 agile management\n以用户的需求进化为核心，采用迭代、循序渐进的方法进行软件开发。在敏捷开发中，软件项目在构建初期被切分成多个子项目，各个子项目的成果都经过测试，具备可视、可集成和可运行使用的特征。换言之，就是把一个大项目分为多个相互联系，但也可独立运行的小项目，并分别完成，在此过程中软件一直处于可使用状态。\nPLC Product Life Cycle\n产品生命周期，即一种新产品从开始进入市场到被市场淘汰的整个过程。\n这个过程其实就是经历了一个从 “启动、成长、成熟一直到衰退” 的阶段。\n一个产品四阶段；阶段策略各不同；快速验证和开发；尽力延长成熟期。\n可用性测试 让一群具有代表性的用户对产品进行典型操作，同时观察员和开发人员在一旁观察，聆听，做记录。\n观察用户使用产品。\n商业闭环 商业闭环是围绕着顾客一系列关联性消费需求，逐一提供相应的产品予以满足的商业模式。\n主要在商业体系中营造循环圈，各个环节都可以相互依靠，既可以作为个体支撑点也可以协同合作。\n互联网上半场 / 下半场 互联网上半场即消费互联网时代，注重的是入口和流量，线上打造；\n而下半场即产业互联网时代，注重的是服务和价值，线上线下充分融合。\n用户任务的闭环 指的是一系列帮助用户完成任务的环节，这些环节可以应对任务可能出现的各种情况。\n就是用户做一件事情要能做完。\n参考：\n 产品经理必知词汇  "});index.add({'id':87,'href':'/note/docs/live/diary/2020/06/17/','title':"2020-06-17",'content':"2020 年 6 月 17 日（星期三） 今日待办     编程 最大传输单元 Maximum Transmission Unit，MTU\n用来通知对方所能接受数据服务单元的最大尺寸，说明发送方能够接受的有效载荷大小。\n是包或帧的最大长度，一般以字节记。如果 MTU 过大，在碰到路由器时会被拒绝转发，因为它不能处理过大的包。如果太小，因为协议一定要在包 (或帧) 上加上包头，那实际传送的数据量就会过小，这样也划不来。大部分操作系统会提供给用户一个默认值，该值一般对用户是比较合适的。\n  以太网 MTU 是 1500 字节\n  802.3 MTU 是 1492 字节。\n  UDP MTU 是 1400\n  最大分节大小 maximum segment size，MSS\n为 TCP 数据包每次传输的最大数据分段大小，一般由发送端向对端 TCP 通知对端在每个分节中能发送的最大 TCP 数据。\nMSS 值为 MTU 值减去 IPv4 Header（20 Byte）和 TCP header（20 Byte）。\nIP 分片 (fragmentation) ts 包 ts 包的大小是 188， 最大传输单元是 1500，所以最多可以传输 188 * 7 个字节，加上 12 字节 rtp 头，所以每次发送 1328 字节数据。\n Go 优雅重启  重启：kill -HUP pid 或 kill -HUP pid 退出：kill -QUIT pid  参考：\n gracehttp: 优雅重启 Go 程序（热启动 - Zero Downtime） fevin/gracehttp    RTP RTP 是位于传输层的协议，其可以基于 UDP、TCP 等协议传输，通常使用较多的是 UDP，主要为了降低延时等。\nRTP 支持的负载格式一般是分开的，也就是说音频和视频是通过独立的 RTP 协议传输的。 RTP 支持 H264、HEVC、AAC 等常见音视频的格式（更详细的 RTP 支持格式可参考 RTP profile），其广泛应用于视频会议及 IP 电话中。\nrtp 不需要 server 接收 # rtsp 需要 server (tcp://localhost:2352) 接收 ffmpeg -re -stream_loop -1 -i carbrand.MOV -c copy -an -f rtsp rtsp://localhost:2352/mystream # rtp 不需要 server ffmpeg -re -stream_loop -1 -i carbrand.MOV -c copy -an -f rtp rtp://localhost:2355/mystream  解析 ps 流 坑一：解析完以后播放有花屏问题\n 原因：pes 有丢包现象，如果通过 wireshark 能够抓到包，但程序没有读取，很有可能是程序里没有设置缓存  坑二：解析完以后开始播放有一层白雾，人走过就能清晰\n 原因：pes 包没有完全解析，很多 rtp 中会含有两个 pes 包，此时要根据 pes 包的长度进行控制  坑三：一开始播放正常，过一会儿就开始断断续续【我这边是由于 sip 服务器每隔一段时间会注册一次导致的混流现象】\n 原因：很有可能是多个 rtp 会话向一个端口发送信息，此时可以在程序中将 rtp 包的编号输出到文件，然后在文件中查看编号的连续性，再通过 wireshark 进行抓包分析，查看包的连续性。  参考：\n 解析海康摄像机推送的 PS 流（节目流）   硬解码 / 软解码 硬解码 在 Android 中使用硬件解码直接使用 MediaCodec 就可以了， 虽然 MediaPlayer 也是硬件解码，但是被封装得太死了，支持的协议很少。 而 MediaCodec 就很好拓展，我们可以根据流媒体的协议和设备硬件本身来自定义硬件解码， 代表播放器就是 Google 的 ExoPlayer 。\n软解码 软解码即通过软件让 CPU 来对视频进行解码处理，就是通过 CPU 来运行视频编解码代码，我们最最常见的视频软解码开源看就是 FFmpeg 。\n目前基于 FFmpeg 的开源播放器有 B 站的 ijkplayer 。\n 手机 GPU Graphic Processing Unit\n图形处理器，通常也叫显卡\n手机没有独立显卡，手机 GPU 都是集成到 SoC\nSoC / 单片系统 System on a Chip\n对于 android 设备，目前用得比较多的 SoC 就是高通、海思和联发科， 这些 SoC 大都集成了很多的功能，CPU、GUP、DSP、ISP，包括视频解码、音频解码等等，所以我们说的是 SoC 而不是直接说 CPU\n参考：\n 手机处理器的 GPU 谁最强？ 智能手机中的视频解码 Android 视频播放软解与硬解的区别 什么是手机的 SoC？你真的了解吗？详解手机的 SoC 手机 SoC 和电脑 CPU 有哪些异同？手机 SoC 能魔改成电脑 CPU 吗？   obsproject/obs-studio  OBS Studio - Free and open source software for live streaming and screen recording\n参考：\n 如何搭建一个完整的视频直播系统？  "});index.add({'id':88,'href':'/note/docs/live/diary/2020/06/16/','title':"2020-06-16",'content':"2020 年 6 月 16 日（星期二） 今日待办     编程 IOT 物管理 物影子 物影子反映物理世界中的一个物（设备），是物在云端的映射。 运行时，物将监控值上报给物影子，物影子会用一个 json 文档存储设备的最后一次上报的状态，可以直接通过 MQTT 或 HTTP 访问。 同时，物影子也提供反控功能。\n物模型 物模型由一个或多个属性构成，可以用他来表示一类（或同一型号的一批）设备。 基于物模型可以创建物影子。\n物模型可以选择开启 ota 服务，这样使用这个物模型创建的物影子就可以使用 ota 服务，并通过这个物模型做统一的管理。\n 常见直播协议  RTMP: 底层基于 TCP，在浏览器端依赖 Flash。 HTTP-FLV: 基于 HTTP 流式 IO 传输 FLV，依赖浏览器支持播放 FLV。 WebSocket-FLV: 基于 WebSocket 传输 FLV，依赖浏览器支持播放 FLV。 WebSocket 建立在 HTTP 之上，建立 WebSocket 连接前还要先建立 HTTP 连接。 HLS: Http Live Streaming，苹果提出基于 HTTP 的流媒体传输协议。HTML5 可以直接打开播放。 RTP: 基于 UDP，延迟 1 秒，浏览器不支持。  HTML5 FLV Player\nflv.js 在获取到 FLV 格式的音视频数据后将 FLV 文件流转码复用成 ISO BMFF（MP4 碎片）片段，再通过 Media Source Extensions API 传递给原生 HTML5 Video 标签进行播放。\nflv.js 是使用 ECMAScript 6 编写的，然后通过 Babel Compiler 编译成 ECMAScript 5，使用 Browserify 打包。\nflv.js 从服务器获取 FLV 再解封装后转给 Video 标签的原因如下：\n 兼容目前的直播方案：目前大多数直播方案的音视频服务都是采用 FLV 容器格式传输音视频数据。 flv 格式简单，相比于 MP4 格式转封装简单、性能上也占优势，解析起来更快更方便。   Linux 服务开机自动启动 /etc/rc.d/rc.local crontab crontab -e\n@reboot /home/auto_run_script.sh /etc/init.d systemd chkconfig  Shadowsocks gwuhaolin/lightsocks  shadowsocks/shadowsocks  参考：\n 你也能写个 Shadowsocks why-do-shadowsocks-deprecate-ota   可用的直播流地址 RTMP 协议直播源  香港卫视：rtmp://live.hkstv.hk.lxdns.com/live/hks 香港财经，rtmp://202.69.69.180:443/webcast/bshdlive-pc 韩国 GoodTV,rtmp://mobliestream.c3tv.com:554/live/goodtv.sdp 韩国朝鲜日报，rtmp://live.chosun.gscdn.com/live/tvchosun1.stream 美国 1,rtmp://ns8.indexforce.com/home/mystream 美国 2,rtmp://media3.scctv.net/live/scctv_800 美国中文电视，rtmp://media3.sinovision.net:1935/live/livestream 湖南卫视 rtmp://58.200.131.2:1935/livetv/hunantv  RTSP 协议直播源  珠海过澳门大厅摄像头监控：rtsp://218.204.223.237:554/live/1/66251FC11353191F/e7ooqwcfbqjoo80j.sdp 大熊兔（点播）：rtsp://184.72.239.149/vod/mp4://BigBuckBunny_175k.mov  HTTP 协议直播源  香港卫视：http://live.hkstv.hk.lxdns.com/live/hks/playlist.m3u8 CCTV1 高清：http://ivi.bupt.edu.cn/hls/cctv1hd.m3u8 CCTV3 高清：http://ivi.bupt.edu.cn/hls/cctv3hd.m3u8 CCTV5 高清：http://ivi.bupt.edu.cn/hls/cctv5hd.m3u8 CCTV5 + 高清：http://ivi.bupt.edu.cn/hls/cctv5phd.m3u8 CCTV6 高清：http://ivi.bupt.edu.cn/hls/cctv6hd.m3u8 苹果提供的测试源（点播）：http://devimages.apple.com.edgekey.net/streaming/examples/bipbop_4x3/gear2/prog_index.m3u8  参考：\n 常用的 RTMP、RTSP、HTTP 协议流常用直播流地址   直播  RTSP/RTP 推流 \u0026ndash;\u0026gt; ffmpeg, EasyPusher RTSP/RTP 转发 \u0026ndash;\u0026gt; EasyDarwin, wowza RTSP/RTP 拉流与播放 \u0026ndash;\u0026gt; ffplay, ijkplayer, EasyPlayer  ffmpeg 推送，EasyDarwin 转发，vlc 播放 实现整个 RTSP 直播\n趋势 将安防的 PS 存储改成了 TS 存储，将 RTSP 回放改成了 HLS 回放\n PS 流的包结构是可变长度的  信道环境较好，传输误码较低时   TS 流的包结构是固定长度的  信道环境较为恶劣，传输误码较高时     播放器 Bilibili/flv.js  bilibili/ijkplayer  Android/iOS video player based on FFmpeg n3.4, with MediaCodec, VideoToolbox support.\n L1 Cache Cache（L1 Cache、L2 Cache、L3 Cache）本质上是 CPU 内部高速、昂贵、小尺寸的寄存器与外部低速、偏移、大尺寸的 SDRAM 之间的妥协的产物。\nL1 Cache 会被划分成指令 Cache 和数据 Cache，分别用于存储指令和数据，而 L2 Cache、L3 Cahce 等则是指令和数据混合存储。\n目前的 CPU 架构基本上都是改进的哈佛架构。 也就是说，指令和数据存储在不同的 Cache 中，使得 CPU 内核在执行时可以同时取指令和访问数据，提高效率； 同时，由于指令通常情况下不会动态修改，而数据则需要频繁的修改，因此可以进一步优化指令 Cache 的设计，提高执行效率。 只有在 CPU 无法从 L1 Cache 找到需要的指令或数据时（术语叫做 “未命中” 或者 \u0026ldquo;Miss\u0026rdquo;）或者需要对修改过的数据进行同步时，才会进一步访问 L2 Cache、L3 Cahce、SDRAM 等。\n参考：\n 数据 cache 和指令 cache 的区别？  "});index.add({'id':89,'href':'/note/docs/live/diary/2020/04/15/','title':"2020-04-15",'content':"2020 年 4 月 15 日（星期三） 今日待办     编程 Service Mesh 南北流量 vs 东西流量 南北流量（NORTH-SOUTH traffic）\n东西流量（EAST-WEST traffic）\n在云计算和 SDN 下，我们经常听到流量的东西南北向概念，简单来说从外部 Internet 等到数据中心内部的流量走向被称为南北流量，数据中心内部的 VM 之间的流量被称为东西流量。\n南北流量：client - server\n东西流量：server 之间\n智慧城市  平安城市是一个综合性的安防系统，包含子系统较多； 天网工程和雪亮工程偏向于视频监控系统。  三者都是分级建设，平安城市和天网工程主要利用政府资源，而雪亮工程鼓励警民结合、资源互补。\n按工程的建设规模排序，平安城市 ＞ 天网工程 ＞ 雪亮工程。\n平安城市 平安城市就是通过三防系统（技防系统、物防系统、人防系统）建设城市的平安和谐。它是一个特大型、综合性非常强的管理系统，不仅需要满足治安管理、城市管理、交通管理、应急指挥等需求，而且还要兼顾灾难事故预警、安全生产监控等方面对图像监控的需求，同时还要考虑各系统之间的联动。\n天网工程 天网工程是指为满足城市治安防控和城市管理需要，利用图像采集、传输、控制、显示等设备和控制软件组成，对固定区域进行实时监控和信息记录的视频监控系统。天网工程整体按照部级 - 省厅级 - 市县级平台架构部署实施，具有良好的拓展性与融合性。\n雪亮工程 雪亮工程是以县、乡、村三级综治中心为指挥平台、以综治信息化为支撑、以网格化管理为基础、以公共安全视频监控联网应用为重点的 “群众性治安防控工程”。它通过三级综治中心建设把治安防范措施延伸到群众身边，发动社会力量和广大群众共同监看视频监控，共同参与治安防范，从而真正实现治安防控 “全覆盖、无死角”。\n从平安城市到智慧城市 平安城市是现代城市信息化建设的第一步，随着物联网技术的发展，平安城市在未来会进一步在物联网的基础上向数字城市、智慧城市发展。\n在不久前召开的北京安防技术应用论坛上，就探讨了平安城市建设与物联网技术应用。平安城市将从传统安防到平安城市大安防体系、数字城市、智慧城市方向发展。展望未来，平安城市将与城市应急、水体与气体检测、垃圾处理等，数字城管、智能建筑、工业与自动化控制、城市一卡通等各个方面涵盖，届时，将全面服务居民的生活。\n平安城市与数字城市、智慧城市和感知中国随着技术不断发展，不断向前发展的城市管理模式，所涵盖技术各不相同，所使用目的也各不相同，但其重要部分视频监控技术都在发挥重要作用。\n从功能上区分，平安城市的主体就是利用现代信息通信技术，构建城市综合预警系统和应急指挥体系，达到指挥统一、反应及时、作战有效的目的。实现对城市的有效管理和打击违法犯罪，加强中国城市安全防范能力，加快城市安全系统建设，建设平安城市和谐社会。\n数字城市作为一个城市发展的战略目标，它主要是以计算机技术、多媒体技术和大规模存储技术为基础，利用信息技术手段把城市的过去、现状和未来的全部内容在网络上进行数字化虚拟实现。数字城市的建设涉及城市建设、规划、运行、管理、服务等各个方面，包括政府、交通、医疗、消防等等。\n智慧城市是未来城市发展演进的必然趋势，不管是绿色城市，环保城市等等，智慧城市的加强是顺应当前全球技术变革及新一轮产业发展的时代潮流。每一个城市都要充分发挥信息技术带给他的优势，来建设好这个城市。所以，信息资源应该成为建设社会的重要要素，信息世界与物理世界的融合已经成为城市的支撑。\ndocker 上传到 私有仓库 docker build -t human-attribute:20200415_1585818439123 . docker tag human-attribute:20200415_1585818439123 ote-harbor.baidu.com/aiedge/human-attribute:20200415_1585818439123 docker push ote-harbor.baidu.com/aiedge/human-attribute:20200415_1585818439123 "});index.add({'id':90,'href':'/note/docs/live/diary/2020/06/15/','title':"2020-06-15",'content':"2020 年 6 月 15 日（星期一） 今日待办     编程 URL vs URI vs URN  URI 在于 I (Identifier) 是统一资源标示符，可以唯一标识一个资源 URL 在于 Locater，一般来说（URL）统一资源定位符，可以提供找到该资源的路径 URL 是 URI 的特例  apache/zookeeper  Mirror of Apache Hadoop ZooKeeper\nsamuel/go-zookeeper  "});index.add({'id':91,'href':'/note/docs/live/diary/2020/04/14/','title':"2020-04-14",'content':"2020 年 4 月 14 日（星期二） 今日待办     编程 豆瓣 API 文档 zce/douban-api-docs  英文 basic vs basis basic: 以什么为基础，进行再加工创造\nbasic: 基础内容\nBasis = foundation of something. The basis of multiplication is serial addition, for example.\nBasics = the core concepts. Multiplication tables are part of the basics because understanding them allows students to do higher order arithmetic much more efficiently.\nSo no, they are really not interchangeable. You might use a paragraph from a book as the basis for your thesis because your thesis builds upon that paragraph. Whereas you might say, \u0026ldquo;The English alphabet and punctuation are the basics you should learn in your first language lesson.\u0026rdquo;\n参考：\n What is the difference between basicand basis?  "});index.add({'id':92,'href':'/note/docs/live/diary/2020/05/14/','title':"2020-05-14",'content':"2020 年 5 月 14 日（星期四） 今日待办     编程 Go Go Module goproxy 阿里云 Go Module 代理仓库服务\n  使用 go1.11 以上版本并开启 go module 机制\n  导出 GOPROXY 环境变量\n  export GOPROXY=https://mirrors.aliyun.com/goproxy/ go-yaml/yaml  YAML support for the Go language.\npackage main import ( \u0026#34;io/ioutil\u0026#34; \u0026#34;gopkg.in/yaml.v2\u0026#34; \u0026#34;fmt\u0026#34; ) func main() { var c conf conf:=c.getConf() fmt.Println(conf.Host) } //profile variables type conf struct { Host string `yaml:\u0026#34;host\u0026#34;` User string `yaml:\u0026#34;user\u0026#34;` Pwd string `yaml:\u0026#34;pwd\u0026#34;` Dbname string `yaml:\u0026#34;dbname\u0026#34;` } func (c *conf) getConf() *conf { yamlFile, err := ioutil.ReadFile(\u0026#34;conf.yaml\u0026#34;) if err != nil { fmt.Println(err.Error()) } err = yaml.Unmarshal(yamlFile, c) if err != nil { fmt.Println(err.Error()) } return c } 参考：\n golang 几种常用配置文件使用方法总结（yaml、toml、json、xml、ini）  GPU GPU 利用率统计 nvidia-smi --format=csv,noheader,nounits --query-gpu=timestamp,index,memory.total,memory.used,memory.free,utilization.gpu,utilization.memory -lms 500 -f gup.log # 筛选 gpu2 awk -F\u0026#34;,\u0026#34; \u0026#39;{ if($2==2){print $0} } \u0026#39; smi-1-90s-instance.log \u0026gt; gpu2.log # 计算 gpu 平均利用率 cat gpu2.log| awk \u0026#39;{sum7+=$7;count++} END {print sum7/count}\u0026#39; "});index.add({'id':93,'href':'/note/docs/live/diary/2020/06/14/','title':"2020-06-14",'content':"2020 年 6 月 14 日（星期日） 今日待办     编程 Istio 向 pod 中注入 Istio sidecar istioctl 手动注入 使用 istioctl 手动注入\nIstio sidecar 注入器自动注入 启用 pod 所属命名空间的 Istio sidecar 注入器自动注入\n区别于手动注入，自动注入发生在 pod 层面。 你将看不到 deployment 本身有任何更改。 取而代之，需要检查单独的 pod（使用 kubectl describe）来查询被注入的代理。\n Kubernetes kubectl get 结果排序 --sort-by= ##### pod # name kubectl --sort-by=.metadata.name get pod # status kubectl --sort-by=.status.phase get pod # restarts kubectl --sort-by=.status.containerStatuses[0].restartCount get pod # age kubectl --sort-by=.status.startTime get pod # ip kubectl --sort-by=.status.podIP get pod # node kubectl --sort-by=.spec.nodeName get pod ##### deployment # name kubectl --sort-by=.metadata.name get deployment # age kubectl --sort-by=.metadata.creationTimestamp get deployment # uptodate kubectl --sort-by=.status.updatedReplicas get deployment # available kubectl --sort-by=.metadata.availableReplicas get deployment # containers kubectl --sort-by=.spec.template.spec.containers[*].name get deployment # images kubectl --sort-by=.spec.template.spec.containers[*].image get deployment ##### service # name kubectl --sort-by=.metadata.name get service # age kubectl --sort-by=.metadata.creationTimestamp get service # type kubectl --sort-by=.spec.type get service # clusterip kubectl --sort-by=.spec.clusterIP get service # port kubectl --sort-by=.spec.ports[*].port get service AATHITH/kubesort  This a Bash Script that will help you forget the kubectl\u0026rsquo;s default, difficult to remember, sorting feature by making it simpler.\n 历史 正一品 太师，太傅，太保，中和殿、保和殿、武英殿、文华殿、文渊阁、体仁阁、东阁大学士，领侍卫内大臣，銮仪卫掌卫事大夫，建威将军，子爵、衍圣公（孔子后代，文臣之首）。\n正一品，中国古代官品等级的最高级别。古代官职分为九品，由正一品到从九品，共计十八级。其中，正三品分正三品堂上和正三品堂下。正一品至正三品堂上，称为堂上官。正三品堂下到正七品，称为堂下官或参上官。正七品以下为参下官。\n清乾隆十年（公元 1745 年）以后，大学士专以三殿（保和殿、文华殿、武英殿）三阁（文渊阁、体仁阁、东阁）入衔，满、汉各二人；协办大学士满、汉各一人。均为文臣最高官位，汉人一般非翰林出身不授此官。\n衍圣公 孔子第 80 代嫡长孙 孔佑仁于 2006 年出生\n"});index.add({'id':94,'href':'/note/docs/live/diary/2020/04/13/','title':"2020-04-13",'content':"2020 年 4 月 13 日（星期一） 今日待办     编程 Git merge vs squash vs rebase merge 不能保持 master 分支干净，但是保持了所有的 commit history，大多数情况下都是不好的，个别情况挺好 squash 也可以保持 master 分支干净，但是 master 中 author 都是 maintainer，而不是原 owner rebase 可以尽可能保持 master 分支干净整洁，并且易于识别 author\nsquash merge # 切换到目标分支 $ git checkout master # 以 squash 的形式 merge $ git merge --squash devel # it does not produce a commit right away: you need an additional commit $ git commit -m \u0026#34;squash branch\u0026#34;  你会发现，在 master 分支上居然有未提交的修改，然后你就需要在 master 上主动提交了修改， 注意，这里是你 commit 的，也就是改变了 commit 的 author。 git merge has a \u0026ndash;commit option, but it cannot be used with \u0026ndash;squash. It was never possible to use \u0026ndash;commit and \u0026ndash;squash together.  参考：\n In git, what is the difference between merge \u0026ndash;squash and rebase?  rebase merge # 先切换到 devel 分支（不一样咯） $ git checkout devel # 变基 $ git rebase -i master # 切换回目标分支 $ git checkout master # 合并 $ git merge  我们在 devel 里面对照 master 进行了变基  所谓的变基其实就是找到两个分支共同的祖先   然后在当前分支上合并从共同祖先到现在的所有 commit  会选择怎么处理这些 commit   然后我们就得到了一个从公共 commit 到现在的单个 commit 这个时候别人将我们这个 commit 合并到 master 也只会在 master 上留下一个 commit 记录  合并 git commit 参考：\n Trimming Git Commits/Squashing Git History   CDN CDN：Content Delivery Network 内容分发网络\nCDN 的基本思路  尽可能避开互联网上有可能影响数据传输速度和稳定性的瓶颈和环节， 使内容传输的更快、更稳定。 它是通过网络各处放置节点服务器所构成的现有互联网基础之上的一层智能虚拟网 CDN 实时根据网络流量以及各节点的连接、负载状况以及到用户的距离和响应时间等综合信息 重新导向用户的请求到最近的服务节点上  CDN 解决的问题  解决高流量、大并发 解决南北互联问题 访问加速（CDN 有缓存技术） 降低运营成本（源站放在 BGP 机房，缓存服务器放在费用较低的地方） 提高网站的可用性 防 DDoS（因为攻击被分配到了不同的物理服务器  CDN 的组成部分  源站 缓存服务器（核心缓存服务器 + 边缘缓存服务器） 智能 DNS（核心）：根据用户的来源，重新导向到较近 / 合适的缓存服务器 客户端  APM Application Performance Management\nNew Relic\nUptime is everything\nObservability is critical for today’s business infrastructure\nGMV GMV：Gross Merchandise Volume，是成交总额（一定时间段内）的意思。多用于电商行业，一般包含拍下未支付订单金额。\n"});index.add({'id':95,'href':'/note/docs/live/diary/2020/06/13/','title':"2020-06-13",'content':"2020 年 6 月 13 日（星期六） 今日待办     编程 求最大公约数  暴力枚举法：时间复杂度是 O (min (a, b))) 辗转相除法：时间复杂度不太好计算，可以近似为 O (log (max (a, b)))，但是取模运算性能较差。 更相减损术：避免了取模运算，但是算法性能不稳定，最坏时间复杂度为 O (max (a, b))) 更相减损术与移位结合：不但避免了取模运算，而且算法性能稳定，时间复杂度为 O (log (max (a, b)))  辗转相除法 辗转相除法， 又名欧几里得算法（Euclidean algorithm）， 目的是求出两个正整数的最大公约数。 它是已知最古老的算法， 其可追溯至公元前 300 年前。\n这条算法基于一个定理： 两个正整数 a 和 b（a\u0026gt;b），它们的最大公约数等于 a 除以 b 的余数 c 和 b 之间的最大公约数。\n比如 10 和 25，25 除以 10 商 2 余 5, 那么 10 和 25 的最大公约数，等同于 10 和 5 的最大公约数。\n大整数取模 存在性能问题\n更相减损术 出自于中国古代的《九章算术》，也是一种求最大公约数的算法。\n他的原理更加简单： 两个正整数 a 和 b（a\u0026gt;b），它们的最大公约数等于 a-b 的差值 c 和较小数 b 的最大公约数。\n比如 10 和 25，25 减去 10 的差是 15, 那么 10 和 25 的最大公约数，等同于 10 和 15 的最大公约数。\n求最小公倍数 两数乘积除以最大公约数\nusing LL = long long; LL MCM(LL a, LL b){ LL Multi = a * b; while (b \u0026gt; 0) { LL tmp = a % b; a = b; b = tmp; } return Multi / a; } "});index.add({'id':96,'href':'/note/docs/natural/math/','title':"1.2 数学",'content':"数学 "});index.add({'id':97,'href':'/note/docs/humanities/language/','title':"2.2 语言",'content':"语言 语言\n语言学 Linguistics\n"});index.add({'id':98,'href':'/note/docs/live/diary/2020/04/12/','title':"2020-04-12",'content':"2020 年 4 月 12 日（星期日） 今日待办  Istio Handbook 周报  周一发布到钉钉群     编程 GitHub 周报 probot/weekly-digest  配置\n# Configuration for weekly-digest - https://github.com/apps/weekly-digest publishDay: sun canPublishIssues: true canPublishPullRequests: true canPublishContributors: true canPublishStargazers: true canPublishCommits: true "});index.add({'id':99,'href':'/note/docs/live/diary/2020/05/12/','title':"2020-05-12",'content':"2020 年 5 月 12 日（星期二） 今日待办     编程 Redis redis-cli -h host -p port -a password 设置密码 打开文件 /etc/redis.conf， 找到其中的 # requirepass foobared，去掉前面的 #， 并把 foobared 改成你的密码。\nps: 如果 redis 没有启用密码，我使用 redis-cli -a xxx 可以访问吗？ 答案是：可以\n为什么 Redis 默认端口是 6379 6379 在是手机按键上 MERZ 对应的号码，而 MERZ 取自意大利歌女 Alessia Merz 的名字。 MERZ 长期以来被 antirez 及其朋友当作愚蠢的代名词。\n参考：http://oldblog.antirez.com/post/redis-as-LRU-cache.html\n5G 开源 5G 核心网 free5gc/free5gc  https://www.free5gc.org/\nDocker docker logs --follow\ncopy vs add add 是 copy 的超集\n进入容器 jpetazzo/nsenter  Starting from Docker 1.3 you can use Docker exec to enter a Docker container. Example:\ndocker exec -it CONTAINER_NAME /bin/bash There are differences between nsenter and docker exec; namely, nsenter doesn\u0026rsquo;t enter the cgroups, and therefore evades resource limitations. The potential benefit of this would be debugging and external audit, but for remote access, docker exec is the current recommended approach.\n ActivityPub  ActivityPub is a decentralized social networking protocol based on the ActivityStreams 2.0 data format and is being developed as part of the W3C Social Web Working Group.\n Ip2region  ip2region - 准确率 99.9% 的离线 IP 地址定位库，0.0x 毫秒级查询，ip2region.db 数据库只有数 MB，提供了 java,php,c,python,nodejs,golang,c# 等查询绑定和 Binary,B 树，内存三种查询算法。\ntcpdump sudo tcpdump -i any host 172.246.4.79 -w ai-dump Go nil nil is only a valid value for pointer, slices, and maps.\nYou cannot have a nil struct value, for example.\n"});index.add({'id':100,'href':'/note/docs/live/diary/2020/06/12/','title':"2020-06-12",'content':"2020 年 6 月 12 日（星期五） 今日待办     编程 Go tab vs 空格  Indentation\nWe use tabs for indentation and gofmt emits them by default. Use spaces only if you must.\n 参考：\n Effective Go   Kubernetes 查一段时间的日志 --since-time 查一段时间的日志\nk logs pedestrian-count-wrapper-5b7cb44c79-k4z6n --since-time=2020-06-12T14:00:00+08:00 \u0026gt; pedestrian-count.log 查看多个 pod 日志 传统来说，Kubernetes 环境下的日志都是靠 FluentD + ElasticSearch + Kibana 的组合实现的， 这一组合的功能和强大，所以成为一个事实标准来使用， 但是在一些比较简陋的测试集群中，或者不具备浏览器条件的自动化 / 控制台环境下， 归并多个 Pod 的日志进行集中的查看和处理还是很有用的。\nKubetail 是一个 Bash 脚本，功能类似 kubectl -f logs pod-name，但是不同的是，他同时对多个 Pod 工作，并把日志合并到一个流中。\njohanhaleby/kubetail  Bash script to tail Kubernetes logs from multiple pods at the same time\n K8s 日志定期清理和回卷 logrotate/logrotate  The logrotate utility is designed to simplify the administration of log files on a system which generates a lot of log files.\n参考：\n 在腾讯云容器服务中对容器实例日志设置定期清理和回卷   Linux less less 与 more 类似，但使用 less 可以随意浏览文件，而 more 仅能向前移动，却不能向后移动，而且 less 在查看之前不会加载整个文件。\n用空格显示下一页，按键 b 显示上一页\n Node.js PM2 PM2 是 node 进程管理工具，可以利用它来简化很多 node 应用管理的繁琐任务，如性能监控、自动重启、负载均衡等，而且使用非常简单。\nnpm install -g pm2  URL 以双斜杠 // 开头的 URL 如\n\u0026lt;img src=\u0026#34;//image.studyofnet.com/upfileImages/20161008/20161008222856974.gif\u0026#34; /\u0026gt;  它会判断当前的页面协议是 http 还是 https 来决定请求 url 的协议 用于处理 网站使用的协议和 网页中请求的外网资源不一致的问题。 这种写法，也使用于 CSS，例如：.omgomg { background: url (//image.studyofnet.com/upfileImages/20161008/20161008222856974.gif); }  URL 中的双斜杠 // 如：\nhttps://github.com/alex-shpak/hugo-book/issues # 两个 // https://github.com/alex-shpak/hugo-book//issues 几乎没区别，大部分 Web 框架都可以正常处理\n 127.0.0.1 vs localhost localhost 是域名 一般指向指向 127.0.0.1 （通过 hosts 文件配置）\n127.0.0.1\tlocalhost 255.255.255.255\tbroadcasthost # ipv6 格式 ::1 localhost 127.0.0.1 localhost.localdomain localhost4 localhost4.localdomain4 127.0.0.1 是 IP 地址 一般会通过 ping 127.0.0.1 来测试某台机器上的网络设备是否正常工作。\n回环地址 Loop back address 凡是以 127 开头的 IP 地址，都是回环地址（Loop back address）， 其所在的回环接口一般被理解为虚拟网卡，并不是真正的路由器接口。\n我们在主机上发送给 127 开头的 IP 地址的数据包会被发送的主机自己接收，根本传不出去，外部设备也无法通过回环地址访问到本机。\n 正常的数据包会从 IP 层进入链路层，然后发送到网络上；而给回环地址发送数据包，数据包会直接被发送主机的 IP 层获取，后面就没有链路层他们啥事了。\n  localhost 不经过网卡传输，不受网络防火墙和网卡相关的的限制 127.0.0.1 是通过网卡传输，依赖网卡，并受到网络防火墙和网卡相关的限制。   localhost 不会解析成 ip，也不会占用网卡、网络资源。  0.0.0.0 0.0.0.0 是不能被 ping 通的。\n在服务器中，0.0.0.0 并不是一个真实的的 IP 地址，它表示本机中所有的 IPV4 地址。\n监听 0.0.0.0 的端口，就是监听本机中所有 IP 的端口。\n参考：\n 访问 localhost 和 127.0.0.1 是否完全一样？ What is the difference between 127.0.0.1 and localhost What Is Localhost and How Is It Different from 127.0.0.1?   查看 Mac 主机名 zsh 执行：\nexport PROMPT='%{$fg[magenta]%}%(?..%?%1v)%n@%{$fg[green]%}%M:%{$fg[cyan]%}%c%{$reset_color%} $(git_prompt_info)' 就可以看的 user@hostname\n 回环网卡 回环网卡（Loopback adaptor），是一种特殊的网络接口，不与任何实际设备连接，而是完全由软件实现。 与回环地址（127.0.0.0/8 或 ::1/128）不同，回环网卡对系统 “显示” 为一块硬件。 任何发送到该网卡上的数据都将立刻被同一网卡接收到。 例子有 Linux 下的 lo 接口和 Windows 下的 Microsoft Loopback Interface 网卡。\n"});index.add({'id':101,'href':'/note/docs/social/history/','title':"3.2 历史",'content':"历史 "});index.add({'id':102,'href':'/note/docs/study/course/','title':"4.2 课程",'content':"课程 "});index.add({'id':103,'href':'/note/docs/live/parenting/','title':"5.2 养育",'content':"养育 "});index.add({'id':104,'href':'/note/docs/study/docs/draw/draw.io/','title':"Draw.io",'content':"Draw.io "});index.add({'id':105,'href':'/note/docs/humanities/language/english/','title':"English",'content':"English "});index.add({'id':106,'href':'/note/docs/study/docs/draw/latex/','title':"LaTeX",'content':"LaTeX Mathpix Mathpix 允许你截取复杂数学方程式的截图，并立即将其转换为 LaTeX 可编辑文本。\n参考  自学 LaTeX 可以读什么书入门？ 如何在 1 小时内快速入手 LaTeX？ 有哪些好的 LaTeX 编辑器？ 用这个漂亮的工具将方程式截图迅速转换为 LaTeX KaTeX/KaTeX  TeX wiki  "});index.add({'id':107,'href':'/note/docs/study/docs/draw/mermaid/','title':"Mermaid",'content':"Mermaid "});index.add({'id':108,'href':'/note/docs/study/docs/note/onenote/','title':"OneNote",'content':"OneNote "});index.add({'id':109,'href':'/note/docs/study/docs/draw/processon/','title':"ProcessOn",'content':"ProcessOn "});index.add({'id':110,'href':'/note/docs/study/docs/draw/visio/','title':"Visio",'content':"Visio "});index.add({'id':111,'href':'/note/docs/social/economic/insurance/product/','title':"产品",'content':"产品 产品推荐 重疾险  我的选择    保险类型 优先级 保险产品 费用 所属公司 备注     社保 ★★★★★ - - - 五险一金   重疾险 ★★★★       百万医疗险 ★★★★       一年期意外险 ★★★★       定期寿险 ★★★★       车险 ★★★★       家财险 ★★★★                 参考  全面测评 135 款重疾险，选出九月的性价比之王 全面测评 65 款少儿重疾险，选出九月的性价比之王 全面测评 113 款百万医疗险，选出九月的性价比之王  "});index.add({'id':112,'href':'/note/docs/study/book/humanities/','title':"人文科学",'content':"人文科学 "});index.add({'id':113,'href':'/note/docs/study/course/humanities/','title':"人文科学",'content':"人文科学 "});index.add({'id':114,'href':'/note/docs/study/degree/doctorate/on-job-doctor/','title':"在职博士",'content':"博士分类 "});index.add({'id':115,'href':'/note/docs/study/docs/storage/','title':"存储",'content':"存储 "});index.add({'id':116,'href':'/note/docs/humanities/language/english/tutorial/','title':"教程",'content':"英语教程 听写 CoachShane - 每日英语听写 Daily English Dictation 1-400  表达 CoachShane - Daily Easy English Expression 1-899 "});index.add({'id':117,'href':'/note/docs/humanities/','title':"第二部分 人文科学",'content':"人文科学 "});index.add({'id':118,'href':'/note/docs/social/history/posthumous-name/','title':"谥号",'content':"谥号 "});index.add({'id':119,'href':'/note/docs/live/diary/2020/04/11/','title':"2020-04-11",'content':"2020 年 4 月 11 日（星期六） 今日待办  Istio Handbook 周报  周一发布到钉钉群     编程 架构设计 HA 高可用 High Availability\nLB 负载均衡 Load Balance\n产品设计 POC 概念验证 Proof Of Concept\nMVP 最小化可行产品 Minimum Viable Product\n需求管理 KANO 模型 价值 vs 复杂度矩阵 分布式一致性 Paxos Raft https://raft.github.io\n由于 Paxos 难以理解，所以才有了 Raft\nRaft 以可理解性和易于实现为目标：\n Leader 选举（Leader election） 日志同步（Log replication） 安全性（Safety） 日志压缩（Log compaction） 成员变更（Membership change）  shell top htop\nbrew install htop\n排序：\n Linux:  CPU：大写字母 P 内存：大写字母 M   Mac:  cpu: o cpu 内存：o vsize    显示数据是所有 cpu 的平均值，如果想看每一个 cpu 的处理情况，按 1 即可；\n参考：\n Linux 命令工具 top 详解  Kubernetes 使用 CRD (CustomResourceDefinitions) 扩展 Kubernetes API\nk8s 自定义 controller 三部曲之一：创建 CRD（Custom Resource Definition）\nk8s 自定义 controller 三部曲之二：自动生成代码\nk8s 自定义 controller 三部曲之三：编写 controller 代码\nkafka 序列化 StringSerializer 序列化，写入时使用 dest.kafka.1\u0026amp;key.serializer=org.apache.kafka.common.serialization.StringSerializer dest.kafka.1\u0026amp;value.serializer=org.apache.kafka.common.serialization.StringSerializer\nStringDeserializer 反序列化，读出时使用 source.kafka.2\u0026amp;key.deserializer=org.apache.kafka.common.serialization.StringDeserializer source.kafka.2\u0026amp;value.deserializer=org.apache.kafka.common.serialization.StringDeserializer\ntomcat 入口文件\nIn any web application, there will be a web.xml in the WEB-INF/ folder. If you dont have one in your web app, as it seems to be the case in your folder structure, the default Tomcat web.xml is under TOMCAT_HOME/conf/web.xml Either way, the relevant lines of the web.xml are\n\u0026lt;welcome-file-list\u0026gt; \u0026lt;welcome-file\u0026gt;index.html\u0026lt;/welcome-file\u0026gt; \u0026lt;welcome-file\u0026gt;index.htm\u0026lt;/welcome-file\u0026gt; \u0026lt;welcome-file\u0026gt;index.jsp\u0026lt;/welcome-file\u0026gt; \u0026lt;/welcome-file-list\u0026gt; so any file matching this pattern when found will be shown as the home page. In Tomcat, a web.xml setting within your web app will override the default, if present.\nFurther Reading How do I override the default home page loaded by Tomcat?\n 读书 书评 Goodreads\nLibraryThing\nShelfari\n音乐 碧昂丝 Beyonce Beyonce Giselle Knowles\n碧昂丝·吉赛尔·诺斯\n1981 年 9 月 4 日生于美国德克萨斯州休斯顿。\n1993 年与拉塔薇亚·罗伯森、凯莉·罗兰成立组合“天命真女”。 2003 年，推出了首张个人专辑《Dangerously in Love》。 2006 年 9 月 4 日，推出专辑《B\u0026rsquo;Day》登上公告牌二百强专辑榜的榜首。 2008 年 4 月 4 日与 Jay-Z 两人完婚。 2008 年 11 月 18 日，发售第三张个人专辑《双面碧昂丝》获最佳当代 R\u0026amp;B 专辑。 2012 年 1 月 7 日生下女儿 Blue Ivy Carter。\nfeat feat 是 Featuring 简写，\n指的是后面这个歌手（或者组合）他在这首单曲里面或者这张专辑里面并不是主角，前面那个人才是这首歌的灵魂或者主人。\nKaty Perry 水果姐 凯蒂·佩里 水果姐 1984 年 10 月 25 日出生于美国加利福尼亚州圣巴巴拉，美国流行女歌手、演员兼词曲创作者。\n2007 年凭借歌曲《Ur So Gay》成名。 2008 发行首张专辑《One of the Boys》。 2010 年发行第二张专辑《Teenage Dream》，专辑包括《California Gurls》、《Firework》、《E.T》等歌曲，成为首位在美国公告牌热门单曲榜中有 5 首冠军单曲来自同一专辑的女歌手。 2012 年发行专辑《Teenage Dream》的改版专辑《Teenage Dream：TCC》，获得美国公告牌该年年度女性和全美音乐奖最受欢迎流行女歌手奖，专辑单曲《Part Of Me》空降公告牌冠军，成为美国公告牌上第十九支空降冠军单曲。 2013 年 10 月 22 日发行第三张录音室专辑《PRISM》。\n凯蒂·佩里为什么叫“水果姐” 尽管听起来有些奇怪，但你一定知道人们谈论的是哪位明星。中国人说的“水果姐”就是凯蒂·佩里。原因是凯蒂非常喜欢水果元素的服装，有时登台表演也要带上巨型水果道具。她还透露自己亲自种水果然后把它们吃掉。这样看来，“水果姐”倒是个非常贴切的昵称。\n空降冠军 第一次上榜就是冠军！\n歌手绰号 “臀王”珍妮弗·洛佩兹。洛佩兹在中国很多地区被称为“洛霸”，对应的英文“Lord of Butt”翻译过来就是“臀王”。这个昵称一语双关。“洛霸”与汉语直译的“洛佩兹”中的“洛”发音一致。对这位在自己歌曲的 MV 中大秀电臀的超级明星来说，“洛霸”再合适不过。 “大表姐”詹妮弗·劳伦斯。2011 年奥斯卡颁奖礼前夕，数百名中国网友开玩笑地提前“揭晓”获奖名单，且都宣称自己从“美国电影艺术与科学学院的表姐”那里知道的结果。一名网友更夸张，称自己的表姐就是劳伦斯，并透露她将“封后”。虽然劳伦斯最终未能拿到最佳女主角大奖，但“大表姐”这个昵称就此流传开。 “皮卡丘”莱昂纳多·迪卡普里奥。中国台湾的民众把迪卡普里奥叫做“皮卡丘”。这个昵称来自 2011 年的一个笑话，当时一名台湾主播把“莱昂纳多·迪卡普里奥”口误读成“李奥纳多·皮卡丘”。直到现在，充满娱乐精神的台湾媒体以及香港同行依然用《口袋妖怪》里的这个名字称呼迪卡普里奥。\n 文化 最古老的姓氏 中国最古老的姓氏起源是怎样的？\n僭 [jiàn] 僭越，指超越本份，古时指地位低下的冒用在上的名义或器物等等， 尤指用皇家专用的。\n诺贝尔文学奖  经济 中石油和中石化的区别   中石油\n 中石油的原油是国内开采的， 中石油重点业务是上游板块，也就是勘探与生产。    中石化\n 中石化的原油是国外进口的。 中石化重点业务是下游板块，也就是炼化与销售。    基金定投 基金定投是定期定额投资基金的简称，是指在固定的时间（如每月 8 日）以固定的金额（如 500 元）投资到指定的开放式基金中，类似于银行的零存整取方式。人们平常所说的基金主要是指证券投资基金。证券投资的分析方法主要有如下三种：基本分析、技术分析、演化分析，其中基本分析主要应用于投资标的物的选择上，技术分析和演化分析则主要应用于具体投资操作的时间和空间判断上，作为提高投资分析有效性和可靠性的重要补充。\n等额配比基金 一种捐赠形式。2006 年 9 月，段永平将 3000 万美元捐给浙江大学。其中有一项 1000 万美元的等额配比基金，即凡有人在浙江大学投入一笔钱，不管用于哪一方面，等额捐赠基金中就会抽出相同数量的钱，同时投入浙大。不管对方捐多少，基金单笔支出不超过 100 万美元，时间跨度为 10 年。\n企业融资和投资银行 法律 美国宪法修正案 宪法修正案是美国宪法规定的唯一正式改变宪法的形式，是美国宪法的重要组成部分，代表了美国宪法制度的基本发展方向。其中具有重大影响的是关于公民权利的宪法前 10 条修正案（即“权利法案”）。 自宪法签署完成后，已有二十七项修正案经批准，其中前十项统称权利法案。对美国宪法的修正程序受美国宪法第五条所规定。另有其他许多已向国会提议，但是未向各州提交的美国宪法修正提议。\n 历史 朱元璋的祖辈 朱仲八\n朱百六\n朱四九\n朱初一\n朱世珍，朱五四\n朱元璋，朱重八\n中国历史 如何理清  如何理清春秋战国的历史？ 如何理清五胡十六国的脉络关系？ 怎样理清魏晋南北朝那段的历史？ 如何理清五代十国的历史？ 如何理清民国时军阀混战的历史？ 怎么有效的区分和理顺历史上中国北方的各游牧民族？  欧洲史  欧洲中世纪史的脉络或结构图是怎么样的？ 如何清晰梳理古希腊、罗马史？   生物 生命科学的四大基础学科 细胞生物学 细胞生物学(cell biology)是在显微、亚显微和分子水平三个层次上，研究细胞的结构、功能和各种生命规律的一门科学。细胞生物学由 Cytology 发展而来，Cytology 是关于细胞结构与功能(特别是染色体)的研究。现代细胞生物学从显微水平、超微水平和分子水平等不同层次研究细胞的结构、功能及生命活动。在我国基础学科发展规划中，细胞生物学与分子生物学、神经生物学和生态学并列为生命科学的四大基础学科。\n生命科学的学习方法：一、认识细胞生物学课程的重要性，正如原子是物理性质的最小单位，分子是化学性质的最小单位，细胞是生命的基本单位。50 年代以来诺贝尔生理与医学奖大都授予了从事细胞生物学研究的科学家，可见细胞生物学的重要性。如果你将来打算从事生物学相关的工作，学好细胞生物学能加深你对生命的理解。二、明确细胞生物学的研究内容，即：结构、功能、生活史。生物的结构与功能是相适应的，每一种结构都有特定的功能，每一种功能的实现都需要特定的物质基础。如肌肉可以收缩、那么动力是谁提供的、能量从何而来的？三、从显微、超微和分子三个层次来认识细胞的结构与功能。一方面每一个层次的结构都有特定的功能，另一方面各层次之间是有机地联系在一起的。四、将所学过的知识关联起来，多问自己几个为什么。细胞生物学涉及分子生物学、生物化学、遗传学、生理学等几乎所有生物系学过的课程，将学过的知识与细胞生物学课程中讲到的内容关联起来，比较一下有什么不同，有什么相同，为什么？尽可能形成对细胞和生命的完整印象，不要只见树木不见森林。另一方面细胞生物学各章节之间的内容是相互关联的，如我们在学习线粒体与叶绿体的时候，要联想起细胞物质运输章节中学过的 DNP、FCCP 等质子载体对线粒体会有什么影响，学习微管结构时要问问为什么 β 微管蛋白是一种 G 蛋白，而 α 微管蛋白不是，学习细胞分裂时要想想细胞骨架在细胞分裂中起什么作用，诸如此类的例子很多。五、紧跟学科前沿，当前的热点主要有“信号转导”、“细胞周期调控”、“细胞凋亡”等。细胞生物学是当今发展最快的学科之一，知识的半衰期很短（可能不足 5 年），国内教科书由于编撰周期较长，一般滞后于学科实际水平 5-10 年左右，课本中的很多知识都已是陈旧知识。有很多办法可以使你紧跟学科前沿：一是选择国外的最新教材，中国图书进出口公司读者服务部那里可以买到很多价廉物美的正宗原版教材（一般 200-400 元，只相当于国外价格的 1/5）；二是经常读一些最新的期刊资料，如果条件所限查不到国外资料，可以到中国期刊网、万方数据等数据库中查一些综述文章，这些文章很多是国家自然科学基金支助的，如在中国期刊网的检索栏输入关键词“细胞凋亡”，二次检索输入关键词“进展”，你会发现一大堆这样的文章，都是汉字写的比读英文省事。六、学一点科技史，尤其是生物学史，看看科学家如何开展创造发明，学习他们惊人的毅力、锐敏的眼光和独特的思维。牛顿说过：“我之所以比别人看得更远，是因为站在巨人的肩膀上。”\n遗传学 遗传学研究生物起源、进化与发育的基因和基因组结构、功能与演变及其规律，经历了孟德尔经典遗传学、分子遗传学而进入了系统遗传学研究时期。\n发育生物学 发育生物学（developmentalbiology）是生物科学重要的基础分支学科之一，研究内容是和许多其他学科内容相互渗透、错综联系，特别是和遗传学、细胞生物学、分子生物学的关系最为紧密。其应用现代科学技术和方法，从分子水平、亚显微水平和细胞水平来研究分析生物体从精子和卵的发生、受精、发育、生长直至衰老死亡的过程及其机理。\n生物化学 生物化学: 运用化学的理论和方法研究生命物质的边缘学科。其任务主要是了解生物的化学组成、结构及生命过程中各种化学变化。从早期对生物总体组成的研究，进展到对各种组织和细胞成分的精确分析。目前正在运用诸如光谱分析、同位素标记、X 射线衍射、电子显微镜以及其他物理学、化学技术，对重要的生物大分子（如蛋白质、核酸等）进行分析，以期说明这些生物大分子的多种多样的功能与它们特定的结构关系。\n 游戏 魔兽系列 "});index.add({'id':120,'href':'/note/docs/live/diary/2020/05/11/','title':"2020-05-11",'content':"2020 年 5 月 11 日（星期一） 今日待办     编程 Linux curl / wget wget -c http://xxxx curl -Lo filename http://xxxx # Write output to a file named as the remote file curl -LO http://xxxx Docker # stop all containers sudo docker stop $(sudo docker ps -aq) # rm all containers sudo docker rm $(sudo docker ps -aq) docker system prune This docker system prune clean the following stuff:\nall stopped containers all networks not used by at least one container all dangling images all dangling build cache\nDocker compose networks Compose 默认给你的 app 设置一个网络， 默认是你 docker-compose.yml 文件存放的那个目录的名字， 比如，目录名叫 db，那么默认情况下会创建一个叫 db_default 的网络。 你可以使用 \u0026ndash;project-name 或 COMPSE_PROJECT_NAME 环境变量来设置名称。\nservice 中的每个容器默认都加入这个网络，容器之间彼此是互通的。并且，可以利用容器名字识别到。\nservices 下级的服务中 networks 指定的网络不是指要创建的网络，而是这个服务要加入的网络。 如果你指定了一个不存在的网络，就会报错。\nversion: \u0026#34;2.1\u0026#34; services: mongodb: image: mongo:4 container_name: devops-mongo # 容器名 ports: - \u0026#34;27017:27017\u0026#34; volumes: - \u0026#34;/data/docker_local/mongo/configdb:/data/configdb\u0026#34; - \u0026#34;/data/docker_local/mongo/data/db:/data/db\u0026#34; command: --auth # 开启授权验证 networks: - mongo_net networks: mongo_net: # 没有指定名称，会创建名为 db_mongo_net 的网络 networks: mongo_net: # service 下层指定的 networks 需要和这里一致 name: mongo_net_xxx # name 这个标签，这样的用法需要在 Compose 2.1 版本及以上才能使用 links 参考：\n Networking in Compose Docker Compose 方式下的容器网络基础知识点   Redis MySQL 和 Redis 如何保持数据的一致性？ MySQL binlog 增量订阅消费 + 消息队列 + 处理并把数据更新到 redis\n参考：\nliukelin/canal_mysql_nosql_sync  alibaba/canal  阿里巴巴 MySQL binlog 增量订阅 \u0026amp; 消费组件\n 分布式的环境下， MySQL 和 Redis 如何保持数据的一致性？   Python Python 标准库 参考：\n Python HOWTOs The Python Standard Library Python 3 Module of the Week 应该怎样系统的学习 Python 标准库？   Kubernetes CoreDNS 如果 CoreDNS 异常，如何访问外网？\n运营 日活 / 月活  七麦数据。 这个网站可以查找 app 的下载榜单、搜索指数、微信公众号榜单等，更新速度也都是实时的。 AppGrowing。 提供了广告追踪、榜单数据、ASO 优化服务等。 ASO114。这个网站还可以查看 app 的下载量、进行竞品分析等，功能更强大一些。 艾瑞数据。不仅仅有 app 相关指数还有 pc web 指数、网络影视指数、移动设备指数等，但是这个网站的数据更新速度较慢，不是最新的数据。 易观数据。日活无法查看，但是这里可以查看月活。 百度指数。通过百度指数，然后添加关键词对比，也可以查看其搜索的活跃程度。 QuestMobile。目前来说这个网站上的数据指标最为全面，但是需要付费才能查看，很多大公司会使用。 AppAnnie。国际化产品一般都通过这个网站来查看数据，需要付费使用。 阿拉丁指数。查看小程序相关的榜单网站。  参考：\n 有没有什么工具可以查 App 的日活？  "});index.add({'id':121,'href':'/note/docs/live/diary/2020/06/11/','title':"2020-06-11",'content':"2020 年 6 月 11 日（星期四） 今日待办     编程 VLC VLC media player (previously the VideoLAN Client and commonly known as simply VLC)\nLAN: Local Area Network\n library vs package 常见的 C/C# 等语言中的 library，一般指的就是：\n 静态的库文件：xxx.a 动态的库文件：xxx.dll  Python  module 就是 Python 文件 package 是一堆（相关的）module 组合而成的  Haskell A module is a set of functions, types, classes, \u0026hellip; put together in a common namespace.\nA library is a set of modules which makes sense to be together and that can be used in a program or another library.\nA package is a unit of distribution that can contain a library or an executable or both. It\u0026rsquo;s a way to share your code with the community.\n参考：\n What is the difference between a library and a package? What\u0026rsquo;s the difference between module, package and library in Haskell?   图片网站  Iconfont - 阿里巴巴矢量图标库 Free stock photos · Pexels 地图选择器   EasyDarwin vs SRS vs ZLMediaKit ossrs/srs  xiongziliang/ZLMediaKit  EasyDarwin/EasyDarwin  FFmpeg/FFmpeg  Fast Forward Moving Picture Experts Group\nFFmpeg is a collection of libraries and tools to process multimedia content such as audio, video, subtitles and related metadata.\nffmpeg.exe -i rtsp://admin:root123@192.168.66.119/ -vcodec copy -acodec copy -rtsp_transport tcp -f rtsp rtsp://127.0.0.1/test.sdp # 音视频转码后推送 ffmpeg.exe -i rtsp://admin:root123@192.168.66.119/ -vcodec libx264 -acodec libvo_aacenc -rtsp_transport tcp -f rtsp rtsp://127.0.0.1/test.sdp ffmpeg -re -i ./car-brand.MOV -stream_loop -1 -vcodec libx264 -acodec aac -f rtsp rtsp://10.159.11.167:8194/car-brand ffmpeg -re -i ./car-brand.MOV -rtsp_transport tcp -vcodec h264 -f rtsp rtsp://localhost/test ffmpeg -re -i ./car-brand.MOV -rtsp_transport udp -vcodec h264 -f rtsp rtsp://localhost/test ffmpeg 参数\n-f fmt force format Video options: -r rate set frame rate (Hz value, fraction or abbreviation) -vcodec codec force video codec (\u0026#39;copy\u0026#39; to copy stream) Audio options: -acodec codec force audio codec (\u0026#39;copy\u0026#39; to copy stream)  git git status # 当前 repository 的状态 $ git status # 当前目录的状态 $ git status .  块作用域  PHP  没有块作用域   Java  有块作用域   JavaScript  var 没有块作用域 let 有块作用域     软件测试 测试过程  Alpha 测试 Beta 测试  封闭测试（Closed Beta，常简作封测或 CB） 公开测试（Open Beta，常简作公测或 OB）   Gamma 测试  测试方法  黑盒测试 （black-box testing，也叫黑箱测试） 白盒测试 （white-box testing，也叫白箱测试 或 透明盒测试 glass box testing 或 结构测试 structural testing）   Boolean True/False  Haskell  true/false  JavaScript   homebrew  brew 是从下载源码解压然后 ./configure \u0026amp;\u0026amp; make install ，同时会包含相关依存库。并自动配置好各种环境变量，而且易于卸载。 brew cask 是 已经编译好了的应用包 （.dmg/.pkg），仅仅是下载解压，放在统一的目录中（/opt/homebrew-cask/Caskroom），省掉了自己去下载、解压、拖拽（安装）等蛋疼步骤，同样，卸载相当容易与干净。这个对一般用户来说会比较方便，包含很多在 AppStore 里没有的常用软件。   并行数据结构 并行数据结构分为两大类，并行查找数据结构（Concurrent Search Data Structure, CSDS）和非查找数据结构。并行数据结构的实现可以基于锁，也可以基于无锁算法，但是目标是一样的：高性能。\nCSDS 包括链表（linked list），跳表（skip list），哈希表（hash table）和查找树（search tree）。CSDS 可以抽象为 key-value 容器，提供三个接口：查找，插入和删除。查找就是找到用户指定的 key，返回对应的 value 或者返回一个布尔值表示 key 是否存在。查找操作的核心是对数据结构进行搜索，比如遍历链表。插入和删除操作可以分为两阶段：首先也是对数据结构进行搜索，找到正确的位置，然后完成插入或者删除的动作。一个好的 CSDS 应该具有如下特征 [David15]：\n搜索快。对数据结构的搜索不仅仅是查找操作的核心，也是插入和删除操作的第一阶段，是插入和删除操作的瓶颈。搜索快意味着：搜索过程应该尽量避免（最好完全避免）耗时的操作（写操作，memory barrier，原子操作），等待和重试。 细粒度。如果插入或者删除操作进入第二阶段，需要对数据结构进行修改，修改应该尽可能涉及较小范围。如果 CSDS 采用锁来实现，就意味着细粒度锁。这样，不同的插入和删除操作可以打散到数据结构的不同部分，彼此不影响，提高并行性。 非查找数据结构包括队列（queue）和栈（stack），它们有比较固定的冲突点，冲突不能打散到数据结构的不同部分，因此特性和 CSDS 不同。\n单链表（singly-linked list） 单链表要解决五个问题：1）插入和删除冲突；2）删除和删除冲突；3）内存管理问题（节点从链表摘除后还在被访问）；4）ABA 问题；5）线性化。关于线性化，我们只要求单链表提供三个操作（符合 CSDS 的定义）：任意位置的插入、任意位置的删除和全链表范围内的查找，并且保证这三个操作是线性化的。我们不要求单链表对外提供线性化的链表遍历操作（因为做不到）。线性化是正确性的基础，下面这些单链表都是线性化的。\nPugh List [Pugh90b] 是一个基于细粒度锁的实现，解决上述问题 1 和 2，没有讨论问题 3 和 4。论文中给出了推理，但是比较难懂。后续使用这种方法的人很少。[Herlihy07] 指出 [Pugh90b] 不仅非常复杂，而且没有被证明是正确的。\n[Valois95a, Valois95b] 首次提出无锁单链表，指出无锁单链表要解决的五个问题，可以作为学习的起点。但是该算法需要增加很多辅助节点，既消耗内存，又带来复杂性，不是好的解决方法。[Michael02a] 干脆认为 [Valois95a] 不是无锁的。另外 [Harris01] 指出 [Valois95a] 提出的算法存在若干错误，后来被修正。\nHarris List [Harris01] 是解决上述问题 1 和 2 比较实用的方法。Harris List 采用 \u0026ldquo;两阶段\u0026rdquo; 的方法删除节点：1）标记被删除节点的 next 指针（不允许 next 指针被修改）；2）修改前驱节点的 next 指针，使之指向后继节点。Harris List 在指针中取 1 比特作为标志（pointer marking），由于指针和标志位于同一个整数中，对指针和标志的读写可以做到原子。但是 Harris List 对上述问题 3 和 4 没有贡献。它只是简单地采用类似 RCU 的方法（论文 Section 6 尾部）来解决问题 3。问题 4 则没有讨论。Harris List 不是无锁单链表的完整解。参考 [Michael02a] 对 Harris List 的评论。\nMichael List [Michael02a] 是 Harris List 的改进版，解决上述问题 3 和 4。它有两个算法：1）使用 tagged pointer 来解决问题 4。采用 freelist 解决问题 3，实际上就是永远不释放内存。如果内存永远不释放，节点从链表摘除后依然可以访问，这时就只需要解决 ABA 问题。2）采用风险指针来解决问题 3 和 4（不需要 tagged pointer）。\nFomitchev List [Fomitchev04] 也是 Harris List 的改进版，它解决在插入和删除冲突中，插入节点得从链表头重新开始搜索的问题，解决的方法是被删除的节点要记住它原来的前驱节点，由此提出了三阶段删除法。\nLazy List [Heller05] 是一个基于细粒度锁的实现，实现简单，易于推理。它在 Harris List 两阶段删除的基础上又添加了两个阶段，形成四阶段删除：1）对被删除节点和它的前驱节点加锁；2）检查被删除节点和它的前驱节点没有被标记，且前驱节点的 next 指针指向被删除节点；3）标记被删除节点的 next 指针；4）修改前驱节点的 next 指针，使之指向后继节点。后两步和 Harris List 相同。锁和标记一起解决上述问题 1、2 和 4。内存管理利用 Java 的 GC；如果没有 GC，论文作者建议采用风险指针。\nShared_ptr List [Sutter14a, Sutter14b, Sutter14c (第 5 章 Appendix)] 是一个基于 atomic shared_ptr 的实现，它是否无锁，取决于 atomic shared_ptr 能否做到无锁。Shared_ptr List 每个节点的 next 指针是一个 atomic shared_ptr。在给出的版本里，要求插入和删除只发生在链表头部，因此不符合 CSDS 的定义，但是猜想 Shared_ptr List 可以结合 Harris List，扩展到符合 CSDS 定义的程度。对 Shared_ptr List 的批评有三点：1）在遍历链表时，每走过一个节点，都需要引用计数加 1，离开时需要引用计数减 1，而原子操作比较慢，违反了 CSDS 要求搜索快的原则。2）采用递归方式释放整个链表，或者链表中的一段，有可能导致栈溢出。3）如果一个线程获得一个节点的引用计数，但是被卡住，等了好久才释放这个引用计数，那么该节点的所有后继节点都会被延迟释放。 总结：\n在不考虑内存管理的情况下，Lazy List 是目前最好的并行单链表 [David15, David16]，基于 tagged pointer 的 Michael List 是最好的无锁单链表。最好的并行单链表是有锁的（操作可以打散，细粒度锁的实际冲突率很低），这给我们一个启示：简单的算法其实很好。这里传递了一个正确的价值观。这个结论可以用在如下场景：用户指定链表最大长度，链表创建时一次性分配这么多空间，之后不再分配和释放内存；或者用户允许链表节点只分配，不释放。由于内存不释放，就没有内存管理的问题。 在考虑内存管理的情况下，目前没有工程上比较实用的解法：RCU 和风险指针实现复杂，使用也不友好。我们等待它们被标准化到 C++ 标准库，并且采用 sys_membarrier 优化，这样才具备在工程上广泛使用的基础。引用计数虽然使用方便，但是性能不好，违反了搜索快的原则。我们等待引用计数将来能够采用类似 \u0026ldquo;weighted reference counting\u0026rdquo; 之类的优化，解决性能问题。内存管理是个共性问题，所有 CSDS 都有这个问题，而且结论是一样的。所以在后续的讨论中，我们不再单独讨论各个算法的内存管理问题。 松散链表（unrolled linked list） 松散链表是把普通链表中多个相邻节点聚合成一个大节点，从而减少链表长度，提高搜索速度。汇聚在一个大节点中的 key-value 不必按照 key 的顺序摆放，这样有利于插入。同时，在一个大节点中的 key-value 由于连续存放，可以较好的利用 cache locality（要求每个 key 占用的内存空间小）。在插入和删除的过程中，大节点需要进行分裂和合并，这是松散链表特有的动作。本文主要关心单链表在多线程环境下的实现，即如何解决上述提到的 5 个问题，松散链表不是我们关心的重点。但是有些研究工作把并行链表和松散链表相结合，实现并行松散链表，这里简单罗列一下。\nLocality-Conscious List [Braginsky11] 是基于 Michael List 实现的松散链表。\nPlatz List [Platz14] 是基于 Lazy List 实现的松散链表。 跳表（skip list） 并行跳表有两种实现：第一种是直面并行性的问题，硬解各种冲突。由于跳表可以看成是多个链表的集合，所以每种并行单链表算法都能衍生出一个并行跳表算法。代表算法是：Fraser Skip List, Fomitchev Skip List 和 Lazy Skip List；第二种是规避并行性，把塔的升降交给单独线程来管理，代表算法是：No-Hot-Spot Skip List 和 Rotating Skip List。\n[Pugh89, Pugh90a, Pugh90c] 最早提出跳表，只支持单线程。[Pugh90b] 支持多线程，是基于 Pugh List 的跳表。[Herlihy07] 指出 [Pugh90b] 不仅非常复杂，而且没有被证明是正确的。\nFraser Skip List [Fraser04] 是基于 Harris List 的跳表，它是无锁的。Java SE 6 中的 ConcurrentSkipListMap 是基于 Fraser Skip List [Herlihy07]。因此，Fraser Skip List 是一个优秀的算法。\nFomitchev Skip List [Fomitchev04] 是基于 Fomitchev List 的跳表。\nHerlihy Skip List [Herlihy06, Herlihy07] 是基于 Lazy List 的跳表，它采用细粒度锁，性能和 Fraser Skip List 相当，但是实现简单，易于推理。\nNo-Hot-Spot Skip List [Crain12, Crain13] 的思路是：新节点只插入到最底层，塔升高和降低由单独线程完成，避免线程间冲突。但是，引入额外的线程是有开销的。另外，跳表通常用数组来实现塔，No-Hot-Spot Skip List 用链表来实现塔，很费内存，而且不利于提高 CPU cache 命中率，参考 [Dick16] 的评论。\nRotating Skip List [Dick16] 是 No-Hot-Spot Skip List 的简单改进版，解决了 No-Hot-Spot Skip List 用链表实现塔结构的问题，改用循环数组替代了链表。\nPlatz Skip List [Platz19] 是基于 Platz List 的跳表，采用了松散链表技术，不是我们关心的重点。 总结：在第一种实现方法中（不引入额外线程），Herlihy Skip List 是最好的并行跳表 [David15, David16]，Fraser Skip List 是最好的无锁跳表。\n树（tree） Bw-tree [Levandoski16]\n先进先出队列（FIFO queue) 先进先出队列的基本功能是从一头插入和从另外一头取出，严格保序。队列的实现可以基于数组、链表或者混合两者。基于数组的实现需要在创建队列时指明队列的最大容量，队列在初始化时会在内部创建一个足够大的数组用于存储队列中的元素。基于数组的实现比较简单，而且性能高（不需要在插入时创建节点，不需要在取出时释放节点），但是比较浪费内存（必须预分配数组）。基于链表的实现可以较为灵活的管理内存，但是实现难度相对较大。如果实现的好（比如采用内存池），基于链表的队列也可以避免在插入和取出时的内存分配和释放，因此也可以实现高性能，但相比基于数组的队列，获得这种高性能需要付出更多的编码代价。混合使用数组和链表难度更大。\n队列的性能是不可扩展的（多线程不提升性能），因为队列头和尾是固定的冲突点。学术界有些研究通过绕道走的方法来使得队列性能可扩展，比如：不严格保序，采用消除的方法（elimination，插入和取出直接在队列外部解决，不进入队列），对操作进行批处理等，这些不是本文关心的重点。\n1）基于数组\n[Valois94] 提出了基于数组的队列实现。\n2）基于链表\n基于链表的队列需要解决 2 个问题：1）空队列；2）ABA 问题。队列都是线性化的（因为功能简单），而且由于不涉及查找操作，没有内存管理的问题。\n[Valois94] 提出了一种基于链表的无锁队列，[Michael95] 修改了 [Valois94] 的错误，[Michael96] 又进一步指出 [Valois94] 的缺陷，最终发展成为 MS-queue。MS-queue 和 [Valois94] 的主干代码很像，区别是 MS-queue 在 dequeue 时做了检查，防止 head 超过 tail 的情况；另外 MS-queue 用 tagged pointer 防止 ABA 问题，而 [Valois94] 采用引用计数的方法。\nMS-queue [Michael96, Michael98] 是一种基于链表的无锁队列，已经由 boost library 实现，并且包含在 Java Concurrency Package 中 [Mozes08]，它是一个优秀的算法。MS-queue 通过保留一个 dummy node 来解决空队列问题，通过 tagged pointer 来防止 ABA 问题。Tagged pointer 不能彻底解决 ABA 问题（tag rolling-over problem，参考 [Mozes08] 章节 3.4 对 rolling-over 问题的讨论），只能让 ABA 发生的可能性变小。为了减少 ABA 的可能性，需要增加 tag 所占用的比特位，这样指针中用于表示地址的比特位就会减少，指针就越不可能直接指向一个真实的内存地址。Boot library 提供两种方法：1）tag 用 16 位，地址用 48 位，地址指向真实的内存地址，要求新分配的节点的地址必须小于 2^48。这勉强能够办到，但是 16 位的 tag 显得有些少，ABA 的风险并非足够小。2）使用更多位用于 tag，剩下的位不用于地址，而是作为一个下标，在一个预分配的节点池中定位节点。但是这样一来就退化成基于数组的队列了。另外，[Morrison13] 指出 MS-queue 依赖 CAS，而 CAS 重试导致性能损失很大。\nTwo-Lock Queue [Michael96, Michael98] 是一种基于链表的有锁队列，实现简单，易于推理，在中等负载强度下性能也不错。如果综合考虑复杂度和性能，Two-Lock Queue 是不错的选择。[Michael98] 指出，Two-Lock Queue 的主要问题是线程切换可能发生在临界区内，导致 spinlock 被长时间抓住。如果排除这个问题，Two-Lock Queue 的性能和 MS-queue 是接近的（\u0026ldquo;two safe locks\u0026rdquo; in Fig.6 of [Michael98]）。\nMozes Queue [Mozes08] 是一种基于双向链表的无锁队列。它赋予 tagged pointer 新含义，其中的 tag 记录链表的 “总长度”。这里 “总长度” 是包含目前已经在链表中的节点，也包含之前被删除的节点，因此 “总长度” 只增不减。相比 MS-queue，Mozes Queue 花了很大力气少用了一个 CAS 操作。但是链表修复操作需要遍历链表，引入了内存管理的问题（队列本来是没有内存管理问题的）。最后，Mozes Queue 走上了不释放内存的老路。所以，Mozes Queue 在工程上的意义不大，但是利用 tag 来记录 “总长度” 和对反向（prev）指针的分析可见作者对该问题理解是有深度的。 3）混合型\nLCRQ [Morrison13] 把多个数组链起来，链接的方式还是 MS-queue，但是每个单元是数组。大部分插入在数组内部完成，用 fetch-and-add（F\u0026amp;A） 替代 CAS。因为 F\u0026amp;A 不会失败重试，避免了 MS-queue 因为 CAS 重试带来的性能损失。 总结：MS-queue 是目前最好的基于链表的无锁队列。\n内存管理 内存管理有三种方法：Reference Counting, Hazard Pointers 和 RCU-like solutions [Mckenney13] 。Java 程序有自动 GC 功能，也是一种内存管理方法。由于 C++ 没有自动 GC 功能，因此自动 GC 不在本文中讨论。\nPaul E. Mckenney and John D. Slingwine. \u0026ldquo;Read-copy update: using execution history to solve concurrency problems.\u0026rdquo;\n风险指针（hazard pointers）[Michael02b, Michael04, Michael17]。风险指针最大的问题是很难用，用户需要标记正在被访问的对象，即：风险指针侵入用户逻辑。C++ 委员会在讨论风险指针标准化的问题 [Michael17]，这有助于提高风险指针的易用性，但是用户依然需要去标记对象。性能问题依赖于 sys_membarrier [Michael17]。如果没有 sys_membarrier，读者在设置风险指针时需要添加 memory barrier，影响 CSDS 搜索性能，违反了 CSDS 要求搜索快的原则。总之，如果 C++ 标准库能支持风险指针，并且基于 sys_membarrier 实现，风险指针是可用的。\nRCU-like solutions 把一个节点移除数据结构后并不马上释放其内存，而是等到所有相关线程达到一个安全点，即：所有相关线程都不再访问被移除的节点，然后再删除该节点。一个简单的实现是基于 epoch 或者 timestamp。节点移除时记住当前的 epoch 或者 timestamp，称为移除时刻。每个线程在开始访问数据结构时记住当前的 epoch 或者 timestamp，称为该线程的起始时刻。线程不再访问该数据结构时清空自己的起始时刻。一个节点的内存可以被释放的条件是它的移除时刻小于所有线程的起始时刻。 参考文献 [Braginsky11] Anastasia Braginsky, et al. \u0026ldquo;Locality-conscious lock-free linked lists\u0026rdquo;, ICDCN'11, pp. 107–118. [Crain12] Tyler Crain, Vincent Gramoli and Michel Raynal. \u0026ldquo;A contention-friendly, non-blocking skip list\u0026rdquo;, Technical Report RR-7969, IRISA, May 2012. [Crain13] Tyler Crain, Vincent Gramoli and Michel Raynal. \u0026ldquo;No hot spot non-blocking skip list\u0026rdquo;, ICDCS'13, July 2013. [David15] Tudor David, et al. \u0026ldquo;Asynchronized concurrency: the secret to scaling concurrent search data structures\u0026rdquo;, ASPLOS'15, March 2015, Turkey. [David16] Tudor David, et al. \u0026ldquo;Concurrent Search Data Structures Can Be Blocking and Practically Wait-Free\u0026rdquo;, SPAA'16, July 11-13, 2016, California. [Dick16] Ian Dick, Alan Fekete and Vincent Gramoli. \u0026ldquo;A skip list for multicore\u0026rdquo;, Concurrency and Computation: Practice and Experience, 29(4), 1-20. 27 May 2016. [Fomitchev04] Mikhail Fomitchev, et al. \u0026ldquo;Lock-free linked lists and skip lists\u0026rdquo;, PODC'04, July 25-28, 2004, Canada. [Fraser04] Keir Fraser. \u0026ldquo;Practical lock-freedom\u0026rdquo;, Technical Report UCAM-CL-TR-579, Cambridge University Computer Laboratory, 2004. (Section 4.3.3) http://www.cl.cam.ac.uk/techreports/UCAM-CL-TR-579.pdf [Harris01] Tim Harris. \u0026ldquo;A pragmatic implementation of non-blocking linked lists\u0026rdquo;, DISC'01, pp. 300-314, October 2001. [Heller05] Steve Heller, et al. \u0026ldquo;A lazy concurrent list-based set algorithm\u0026rdquo;, OPODIS'05, pp. 3-16, Dec. 12-14, 2005, Italy. [Herlihy06] Maurice Herlihy, et al. \u0026ldquo;A provably correct scalable concurrent skip list\u0026rdquo;, OPODIS'06. [Herlihy07] Maurice Herlihy, et al. \u0026ldquo;A simple optimistic skiplist algorithm”, SIROCCO, pp. 124-138, 2007. [Levandoski16] Justin J. Levandoski, et al. \u0026ldquo;The Bw-Tree: A B-tree for New Hardware Platforms\u0026rdquo;, ICDE'13, pp. 302-313, Apr. 8-11, 2013, Australia. [Mckenney13] Paul E. McKenney. \u0026ldquo;Structured deferral: synchronization via procrastination\u0026rdquo;, Communications of the ACM, 56(7):40–49, July 2013. [Michael95] Maged M. Michael, et al. \u0026ldquo;Correction of a Memory Management Method for Lock-Free Data Structures\u0026rdquo;, TR599, University of Rochester, 1995. [Michael96] Maged M. Michael, et al. \u0026ldquo;Simple, fast, and practical non-blocking and blocking concurrent queue algorithms\u0026rdquo;, PODC'96 [Michael98] Maged M. Michael, et al. \u0026ldquo;Non-blocking algorithms and preemption-safe locking on multiprogrammed shared memory multiprocessors\u0026rdquo;, Journal of Parallel and Distributed Computing, 51(1), 1-26, May 1998. [Michael02a] Maged M. Michael. \u0026ldquo;High performance dynamic lock-free hash tables and list-based sets\u0026rdquo;, SPAA'02, pp. 73-82, August 2002, Canada. [Michael02b] Maged M. Michael. \u0026ldquo;Safe memory reclamation for dynamic lock-free objects using atomic reads and writes\u0026rdquo;, PODC'02, pp. 21-30, July 2002, California. [Michael04] Maged M. Michael. \u0026ldquo;Hazard Pointers: Safe Memory Reclamation for Lock-Free Objects\u0026rdquo;, IEEE Transactions on Parallel and Distributed Systems, vol. 15, no. 6, June 2004. [Michael17] Maged M. Michael, et al. \u0026ldquo;Hazard pointers: safe resource reclamation for optimistic concurrency\u0026rdquo;, P0233R6, 2017. http://open-std.org/JTC1/SC22/WG21/docs/papers/2017/p0233r6.pdf [Morrison13] Adam Morrison, et al. \u0026ldquo;Fast Concurrent Queues for x86 Processors\u0026rdquo;. PPoPP'13, pp. 103-112, Feb. 23-27, 2013, China. [Mozes08] Edya Ladan Mozes, et al. \u0026ldquo;An optimistic approach to lock-free FIFO queues\u0026rdquo;, Distributed Computing, 20(5), Feb. 2008. [Platz14] Kenneth Platz, et al. \u0026ldquo;Practical Concurrent Unrolled Linked Lists Using Lazy Synchronization\u0026rdquo;, POPDIS'14, pp. 388-403. [Platz19] Kenneth Platz, et al. \u0026ldquo;Concurrent Unrolled Skiplist\u0026rdquo;, ICDCS'19, pp. 1579-1589. [Pugh89] William Pugh. \u0026ldquo;Skip lists: a probabilistic alternative to balanced trees\u0026rdquo;, Algorithms and Data Structures: Workshop WADS ’89, Ottawa, Canada, August 1989, Springer-Verlag Lecture Notes in Computer Science 382, 437-449. (revised version to appear in Comm. ACM). [Pugh90a] William Pugh. \u0026ldquo;Skip list: a probabilistic alternative to balanced trees\u0026rdquo;, Communications of the ACM, 33(6), 668-676, June 1990. [Pugh90b] William Pugh. \u0026ldquo;Concurrent maintenance of skip list\u0026rdquo;, Technical Report CS-TR-2222, Department of Computer Science, University of Maryland, June 1990. [Pugh90c] William Pugh. \u0026ldquo;A skip list cookbook\u0026rdquo;, Technical Report CS-TR-2286.1, Department of Computer Science, University of Maryland, June 1990. [Sutter14a] Herb Sutter. “Lock-Free Programming (or, Juggling Razor Blades), Part I”, 2014. https://www.youtube.com/watch?v=c1gO9aB9nbs (58:30) [Sutter14b] Herb Sutter. “Lock-Free Programming (or, Juggling Razor Blades), Part II”, 2014. https://www.youtube.com/watch?v=CmxkPChOcvw (18:15) [Sutter14c] Herb Sutter. “Atomic Smart Pointers, rev. 1”, N4162, 2014. http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2014/n4162.pdf [Valois94] John D. Valois. \u0026ldquo;Implementing lock-free queues\u0026rdquo;, PDCS'94. [Valois95a] John D. Valois. \u0026ldquo;Lock-free linked lists using compare-and-swap\u0026rdquo;. PODC'95, pp. 214-222, August 1995, Canada. [Valois95b] John D. Valois. \u0026ldquo;ERRATA Lock-free linked lists using compare-and-swap\u0026rdquo;, 1995.\n"});index.add({'id':122,'href':'/note/docs/live/diary/2020/04/10/','title':"2020-04-10",'content':"2020 年 4 月 10 日（星期五） 今日待办  Istio Handbook 编委会双周会 21:00-22:00   编程 mosquitto (mqtt) mosquitto_pub mosquitto_pub [-d] [-h hostname] [-i client_id] [-I client id prefix] [-p port number] [-q message QoS] [--quiet] [-r] { -f file | -l | -m message | -n | -s} [-u username [-P password] ] [ --will-topic topic [--will-payload payload] [--will-qos qos] [--will-retain] ] -t message-topic mosquitto_pub -t \u0026lsquo;application/1/device/ffffff100000d143/rx\u0026rsquo; -m \u0026lsquo;{\u0026ldquo;applicationID\u0026rdquo;:\u0026ldquo;1\u0026rdquo;,\u0026ldquo;applicationName\u0026rdquo;:\u0026ldquo;0000000000000001\u0026rdquo;,\u0026ldquo;deviceName\u0026rdquo;:\u0026ldquo;d143-K5-out\u0026rdquo;,\u0026ldquo;devEUI\u0026rdquo;:\u0026ldquo;ffffff100000d143\u0026rdquo;,\u0026ldquo;txInfo\u0026rdquo;:{\u0026ldquo;frequency\u0026rdquo;:481700000,\u0026ldquo;dr\u0026rdquo;:2},\u0026ldquo;adr\u0026rdquo;:false,\u0026ldquo;fCnt\u0026rdquo;:68570,\u0026ldquo;fPort\u0026rdquo;:44,\u0026ldquo;data\u0026rdquo;:\u0026ldquo;BQEA\u0026rdquo;}\u0026rsquo;\nmosquitto_sub mosquitto_sub -t \u0026lsquo;application/1/device/ffffff100000d143/rx\u0026rsquo;\n Github Github star 历史 timqian/star-history  https://star-history.t9t.io/\nvesoft-inc/github-statistics  A react static app for displaying github repo statistiscs like Star History, Fork History and more.\nhttps://vesoft-inc.github.io/github-statistics/\nantonmedv/spark  \nseladb/startrack-js  GitHub star history and stats - based on JavaScript only!\nhttps://seladb.github.io/StarTrack-js/\nelliotreborn/github-stars  技术栈的 star 趋势数据\n Github PR 统计 开源相关工作岗位 t9tio/open-source-jobs A list of Open Source projects offering jobs. https://oo.t9t.io/organizations\n"});index.add({'id':123,'href':'/note/docs/live/diary/2020/06/10/','title':"2020-06-10",'content':"2020 年 6 月 10 日（星期三） 今日待办     编程 尾递归 Consider a simple function that adds the first N natural numbers. (e.g. sum(5) = 1 + 2 + 3 + 4 + 5 = 15).\n// 普通递归 function recsum(x) { if (x === 1) { return x; } else { return x + recsum(x - 1); } } // 尾递归 function tailrecsum(x, running_total = 0) { if (x === 0) { return running_total; } else { return tailrecsum(x - 1, running_total + x); } } 怎么写尾递归 形式上只要最后一个 return 语句是单纯函数就可以。\n// yes return tailrec(x + 1); // no return tailrec(x + 1) + x; 尾递归优化 尾递归和一般的递归不同在对内存的占用，普通递归创建 stack 累积而后计算收缩，尾递归只会占用恒量的内存（和迭代一样）。\nTail-call optimization is where you are able to avoid allocating a new stack frame for a function because the calling function will simply return the value that it gets from the called function.\nThe most common use is tail-recursion, where a recursive function written to take advantage of tail-call optimization can use constant stack space.\n如何优化尾递归：\n 在编译器处理过程中生成中间代码（通常是三地址代码），用编译器优化。  Python, Java 不支持尾递归优化 There are many languages who are doing TCO like (JavaScript, Ruby and few C) whereas Python and Java do not do TCO.\n参考：\n Tail call optimization in ECMAScript 6 What is tail recursion? What is tail call optimization?   alpine 镜像的 libc musl libc 1.1\\1.2\n如果编译的程序动态依赖 libc，就不能在使用到 alpine，所以关键点在于，编译的二进制不能动态链接 libc。\nlinux 上启用 CGO_ENABLED 会动态链接到标准 C 库，可以通过以下命令强制静态\ngo build -o xxx -ldflags \u0026#39;-linkmode \u0026#34;external\u0026#34; -extldflags \u0026#34;-static\u0026#34;\u0026#39; xxx.go 只要使用了 plugin，在 mac 和 linux 下编译的二进制都不能在 alpine 上运行，存在以下解决方案。\n   方法 优点 缺点     使用 debian:jessie 镜像 debian 使用 glibc，可以直接使用 centos 编译的二进制 镜像 129M   在 alpine 上编译 镜像 5M 可能无法编译   alpine 安装 glibc 镜像 5M， 可以直接使用 centos 编译的二进制 可行，镜像 16M， 无法兼容反调试工具    需要带 glibc 的 alpine 可以直接使用镜像 frolvlad/alpine-glibc\nlibc 版本 libc 版本查看 ldd sudo ldd --version otool Mac OS X 下二进制可执行文件的动态链接库是 dylib 文件。 所谓 dylib，就是 bsd 风格的动态库。\n基本可以认为等价于 windows 的 dll 和 linux 的 so。 mac 基于 bsd，所以也使用的是 dylib。\notool -L output/openapi/bin/openapi output/openapi/bin/openapi: /System/Library/Frameworks/CoreFoundation.framework/Versions/A/CoreFoundation (compatibility version 150.0.0, current version 1575.17.0) /System/Library/Frameworks/Security.framework/Versions/A/Security (compatibility version 1.0.0, current version 58286.255.3) /usr/lib/libSystem.B.dylib (compatibility version 1.0.0, current version 1252.250.1) 参考：\n iOS 逆向（八）逆向工具 otool 介绍 macOS 常用二进制工具   Go 报告 gojp/goreportcard  generates a report on the quality of an open source go project.\n 泛型 Go 不支持泛型，如果你的程序或者数据类型有需要，通常的做法是提供函数集。\n MacOS 打开两个 Wireshark # 使用 -n 可以打开多个 open -n /Applications/Wireshark.app 参考：\n Open Multiple Instances of Wireshark on MacOS   视频编码 码流 一个图像或者一个视频序列进行压缩，产生码流\n 对图像的处理: 帧内预测编码 对视频序列的处理: 帧间预测编码  场、帧、图像  场：隔行扫描的图像，  偶数行成为顶场行 奇数行成为底场行 所有顶场行称为顶场 所有底场行称为底场   帧：逐行扫描的图像。 图像：场和帧都可认为是图像。  宏块、片  宏块（MB）：一个宏块由一个 16×16 亮度块、一个 8×8Cb 和一个 8×8Cr 组成。 片（slice）：一个图像可以划分成一个或多个片，一个片由一个或多个宏块组成。  宏块组成片，片组成图像\n SRS (Simple RTMP Server) SRS（Simple RTMP Server）分发 RTMP 是核心功能，srs 的主要定位就是分发 RTMP 低延时流媒体，同时支持分发 HLS 流。\nRTMP 和 HLS 的优势参考：HLS\nRTMP 和 HLS 的比较参考：RTMP PK HLS\n部署 RTMP 的实例参考：Usage: RTMP\n"});index.add({'id':124,'href':'/note/docs/live/diary/2020/04/09/','title':"2020-04-09",'content':"2020 年 4 月 9 日（星期四） 今日待办  编程  熟悉基本算法  排序算法（时间 / 空间复杂度） 大数据查找 / 排序   CORS     编程 基本算法 排序算法  插入排序类  直接插入排序 希尔排序 二分法插入排序   选择排序类  直接选择排序 堆排序   交换排序类  冒泡排序 快速排序   归并排序 基数排序  时间 / 空间复杂度 排序大的分类可分为内排序和外排序，不需要访问外存就能进行排序的叫做内排序。\n   排序方法 时间复杂度（平均） 时间复杂度（最坏) 时间复杂度（最好) 空间复杂度 稳定性 复杂性     希尔排序 O(nlog2n) O(n2) O(n) O(1) 不稳定 较复杂   堆排序 O(nlog2n) O(nlog2n) O(nlog2n) O(1) 不稳定 较复杂   快速排序 O(nlog2n) O(n2) O(nlog2n) O(nlog2n) 不稳定 较复杂   归并排序 O(nlog2n) O(nlog2n) O(nlog2n) O(n) 稳定 较复杂   直接插入排序 O(n2) O(n2) O(n) O(1) 稳定 简单   直接选择排序 O(n2) O(n2) O(n2) O(1) 不稳定 简单   冒泡排序 O(n2) O(n2) O(n) O(1) 稳定 简单   基数排序 O(d(n+r)) O(d(n+r)) O(d(n+r)) O(n+r) 稳定 较复杂    稳定排序与不稳定排序 稳定排序：假设在待排序的文件中，存在两个或两个以上的记录具有相同的关键字，在用某种排序法排序后，若这些相同关键字的元素的相对次序仍然不变，则这种排序方法是稳定的。\n若 a[i] = a[j], a[i] 在 a[j] 之前，经过排序后 a[i] 依然在 a[j] 之前。\n 稳定排序  冒泡排序 直接插入排序 二分插入排序 归并排序 基数排序   不稳定排序  直接选择排序 堆排序 快速排序 希尔排序 猴子排序    参考：\n 常见排序算法以及对应的时间复杂度和空间复杂度  快速排序  字符串倒转 大数据查找 / 排序 多大的内存能够表示 10 亿的数 一个 int 型占 4 字节，10 亿就是 40 亿字节，也就是 4GB\n位图法（Bitmap） 位图法：用一个 bit 位来标识一个 int 整数。\n一般来说 Bit-Map 可作为数据的查找、去重、排序等操作。\n 在 3 亿个整数中找出重复的整数个数，限制内存不足以容纳 3 亿个整数 对没有重复元素的整数进行排序  对于非重复的整数排序 BitMap 有着天然的优势，它只需要将给出的无重复整数扫描完毕，组装成为 BitMap 之后，那么直接遍历一遍 Bit 区域就可以达到排序效果了。   已知某个文件内包含一些电话号码，每个号码为 8 位数字，统计不同号码的个数 2.5 亿个整数中找出不重复的整数的个数，内存空间不足以容纳这 2.5 亿个整数  将 bit-map 扩展一下，用 2bit 表示一个数即可：0 表示未出现；1 表示出现一次；2 表示出现 2 次及以上，即重复    分治法 分治法：分批处理这 10 亿的数。\n哈希分桶（Hash Buckets） 哈希分桶的思想是先遍历一遍，按照 hash 分 N 桶（比如 1000 桶），映射到不同的文件中。这样平均每个文件就 10MB，然后分别处理这 1000 个文件，找出没有重复的即可。一个相同的数字，绝对不会夸文件，有 hash 做保证。\n归并排序 找出 1 亿个整数中最大的 1000 个 有 1 亿个整数，找出最大的 1000 个，要求时间越短越好，空间占用越少越好\n思路：\n 读入前 1000 个整数，建立最小堆。O (1) 然后接着读入剩下的整数，将每个读入的整数与该最小堆中的最小值进行比较（与堆顶进行比较），如果比最小值还要小，则继续读入剩下的数据。O (N) 如果读入的数据比最小值大，则删除最小值，并将该数据插入到最小堆的合适位置。O (log1000) 重复步骤 2，直到将剩下的数据全部读完。 按中序遍历输出该最小堆中的数据，也就是按从小到大输出最大的 1000 个数据。 该算法的时间复杂度为 O (N)，空间复杂度为 1000，其实是常数。  最小堆  1TB 的数据排序 如果有 1TB 的数据需要排序，但只有 32GB 的内存如何排序处理？\n 把磁盘上的 1TB 数据分割为 40 块（chunks），每份 25GB。（注意，要留一些系统空间！） 顺序将每份 25GB 数据读入内存，使用 quick sort 算法排序。 把排序好的数据（也是 25GB）存放回磁盘。 循环 40 次，现在，所有的 40 个块都已经各自排序了。（剩下的工作就是如何把它们合并排序！） 从 40 个块中分别读取 25G/40=0.625G 入内存（40 input buffers）。 执行 40 路合并，并将合并结果临时存储于 2GB 基于内存的输出缓冲区中。当缓冲区写满 2GB 时，写入硬盘上最终文件，并清空输出缓冲区；当 40 个输入缓冲区中任何一个处理完毕时，写入该缓冲区所对应的块中的下一个 0.625GB，直到全部处理完成。  外排序 传统的排序算法一般指内排序算法，针对的是数据可以一次全部载入内存中的情况。但是面对海量数据，即数据不可能一次全部载入内存，需要用到外排序的方法。\n外排序采用分块的方法（分而治之），首先将数据分块，对块内数据按选择一种高效的内排序策略进行排序。然后采用归并排序的思想对于所有的块进行排序，得到所有数据的一个有序序列。\n 参考：\n 10 亿 int 型数，统计只出现一次的数 面试题之 10 亿正整数问题续–关于多通道排序的问题 利用位映射原理对大数据排重   PHP PHP 是单进程单线程的  Mysql 长连接 与 短连接 too many connections  高并发 分布式系统 伸缩性 扩展性 火焰图  Web Content-Type 用于定义用户的浏览器或相关设备如何显示将要加载的数据，或者如何处理将要加载的数据\n application/x-www-form-urlencoded  浏览器的原生 form 表单 提交的数据按照 key1=val1\u0026amp;key2=val2 的方式进行编码，key 和 val 都进行了 URL 转码   multipart/form-data  常见的 POST 数据提交的方式 我们使用表单上传文件时，必须让 form 的 enctype 等于这个值。   text/plain  将文件设置为纯文本的形式，浏览器在获取到这种文件时并不会对其进行处理。   application/json  消息主体是序列化后的 JSON 字符串   text/xml  使用 HTTP 作为传输协议，XML 作为编码方式的远程调用规范   text/html  意思是将文件的 content-type 设置为 text/html 的形式， 浏览器在获取到这种文件时会自动调用 html 的解析器对文件进行相应的处理。    MIME MIME 类型就是设定某种扩展名的文件用一种应用程序来打开的方式类型，当该扩展名文件被访问的时候，浏览器会自动使用指定应用程序来打开。多用于指定一些客户端自定义的文件名，以及一些媒体文件打开方式。\nCORS  CORS 是一个 W3C 标准，全称是 \u0026ldquo;跨域资源共享\u0026rdquo;（Cross-origin resource sharing）。  它允许浏览器向跨源服务器，发出 XMLHttpRequest 请求，从而克服了 AJAX 只能同源使用的限制。 整个 CORS 通信过程，都是浏览器自动完成，不需要用户参与。   CORS 需要浏览器和服务器同时支持。  目前，所有浏览器都支持该功能，IE 浏览器不能低于 IE10。 对于前端开发者来说，CORS 通信与同源的 AJAX 通信没有差别，代码完全一样。浏览器一旦发现 AJAX 请求跨源，就会自动添加一些附加的头信息，有时还会多出一次附加的请求，但用户不会有感觉。 实现 CORS 通信的关键是服务器。只要服务器实现了 CORS 接口，就可以跨源通信。    简单请求与非简单请求 简单请求（simple request） 非简单请求（not-so-simple request）\n只要同时满足以下两大条件，就属于简单请求。\n1. 请求方法是以下三种方法之一： HEAD GET POST 2. HTTP 的头信息不超出以下几种字段： Accept Accept-Language Content-Language Last-Event-ID Content-Type：只限于三个值 application/x-www-form-urlencoded、multipart/form-data、text/plain 凡是不同时满足上面两个条件，就属于非简单请求。\n简单请求   对于简单请求，浏览器直接发出 CORS 请求。具体来说，就是在头信息之中，增加一个 Origin 字段。\n Origin 字段用来说明，本次请求来自哪个源（协议 + 域名 + 端口）。服务器根据这个值，决定是否同意这次请求。    如果 Origin 指定的源，不在许可范围内，服务器会返回一个正常的 HTTP 回应。\n 浏览器发现，这个回应的头信息没有包含 Access-Control-Allow-Origin 字段，就知道出错了，从而抛出一个错误，被 XMLHttpRequest 的 onerror 回调函数捕获。 注意，这种错误无法通过状态码识别，因为 HTTP 回应的状态码有可能是 200。    如果 Origin 指定的域名在许可范围内，服务器返回的响应，会多出几个头信息字段。\n# 有三个与 CORS 请求相关的字段，都以 Access-Control- 开头 # 该字段是必须的。它的值要么是请求时 Origin 字段的值，要么是一个 *，表示接受任意域名的请求。 Access-Control-Allow-Origin: http://api.bob.com Access-Control-Allow-Credentials: true Access-Control-Expose-Headers: FooBar Content-Type: text/html; charset=utf-8    CORS 请求默认不发送 Cookie 和 HTTP 认证信息。 如果要把 Cookie 发到服务器：  服务器同意，指定 Access-Control-Allow-Credentials 字段 # Access-Control-Allow-Credentials 只能是 true，或者不存在 Access-Control-Allow-Credentials: true  在 AJAX 请求中打开 withCredentials 属性 var xhr = new XMLHttpRequest(); xhr.withCredentials = true;     非简单请求   非简单请求是那种对服务器有特殊要求的请求，\n 比如请求方法是 PUT 或 DELETE， 或者 Content-Type 字段的类型是 application/json    非简单请求的 CORS 请求，会在正式通信之前，增加一次 HTTP 查询请求，称为 \u0026ldquo;预检\u0026rdquo; 请求（preflight）。\n  \u0026ldquo;预检\u0026rdquo; 请求用的请求方法是 OPTIONS，表示这个请求是用来询问的。\n  头信息里面，关键字段是 Origin，表示请求来自哪个源。\n  \u0026ldquo;预检\u0026rdquo; 请求的头信息包括两个特殊字段：\n1. Access-Control-Request-Method 该字段是必须的，用来列出浏览器的 CORS 请求会用到哪些 HTTP 方法，比如 PUT。 2. Access-Control-Request-Headers 该字段是一个逗号分隔的字符串，指定浏览器 CORS 请求会额外发送的头信息字段，比如 X-Custom-Header。     服务器收到 \u0026ldquo;预检\u0026rdquo; 请求以后，检查了 Origin、Access-Control-Request-Method 和 Access-Control-Request-Headers 字段以后\n 允许跨源请求，就可以做出回应： Access-Control-Allow-Origin: http://api.example.com # 星号 表示同意任意跨源请求 # Access-Control-Allow-Origin: *  如果浏览器否定了 \u0026ldquo;预检\u0026rdquo; 请求，会返回一个正常的 HTTP 回应，但是没有任何 CORS 相关的头信息字段。  浏览器就会认定，服务器不同意预检请求，因此触发一个错误，被 XMLHttpRequest 对象的 onerror 回调函数捕获。      JSONP CORS 与 JSONP 的使用目的相同，但是比 JSONP 更强大。\nJSONP 只支持 GET 请求，CORS 支持所有类型的 HTTP 请求。JSONP 的优势在于支持老式浏览器，以及可以向不支持 CORS 的网站请求数据。\n参考：\n 跨域资源共享 CORS 详解   Github 徽章 比如 https://github.com/ikingye/ote-stack\n版本：  panjf2000/gnet  gnet 是一个基于事件驱动的高性能和轻量级网络框架。它直接使用 epoll 和 kqueue 系统调用而非标准 Go 网络包：net 来构建网络应用，它的工作原理类似两个开源的网络库：netty/netty 和 libuv/libuv 。\ngnet 设计开发的初衷不是为了取代 Go 的标准网络库：net，而是为了创造出一个类似于 antirez/redis 、haproxy/haproxy 能高效处理网络包的 Go 语言网络服务器框架。\ngnet 的卖点在于它是一个高性能、轻量级、非阻塞的纯 Go 实现的传输层（TCP/UDP/Unix Domain Socket）网络框架，开发者可以使用 gnet 来实现自己的应用层网络协议 (HTTP、RPC、Redis、WebSocket 等等)，从而构建出自己的应用层网络应用：比如在 gnet 上实现 HTTP 协议就可以创建出一个 HTTP 服务器 或者 Web 开发框架，实现 Redis 协议就可以创建出自己的 Redis 服务器等等。\ngnet 衍生自另一个项目：tidwall/evio ，但拥有更丰富的功能特性，且性能远胜之。\n参考：\n 最快的 Go 网络框架 gnet 来啦！  "});index.add({'id':125,'href':'/note/docs/live/diary/2020/05/09/','title':"2020-05-09",'content':"2020 年 5 月 9 日（星期六） 备注： 法定加班（五一调休）\n今日待办     编程 中文排版 sparanoid/chinese-copywriting-guidelines  Chinese copywriting guidelines for better written communication／中文文案排版指北\nmzlogin/chinese-copywriting-guidelines  Chinese Copywriting Guidelines：中文文案排版指北（简体中文版）\nhttps://mazhuang.org/wiki/chinese-copywriting-guidelines/\n参考：\n 中英文混排时中文与英文之间是否要有空格？ 写给大家看的中文排版指南   Docker Dockerfile 目标:\n 更快的构建速度 更小的 Docker 镜像大小 更少的 Docker 镜像层 充分利用镜像缓存 增加 Dockerfile 可读性 让 Docker 容器使用起来更简单  做法：\n  编写.dockerignore 文件\n  容器只运行单个应用\n  将多个 RUN 指令合并为一个\n  基础镜像的标签不要用 latest\n 如果你的确需要使用最新版的基础镜像，可以使用 latest 标签，否则的话，最好指定确定的镜像标签    每个 RUN 指令后删除多余文件\n# 假设我们更新了 apt-get 源，下载，解压并安装了一些软件包，它们都保存在 /var/lib/apt/lists/ 目录中 RUN apt-get update \\  \u0026amp;\u0026amp; apt-get install -y nodejs \\  # added lines \u0026amp;\u0026amp; rm -rf /var/lib/apt/lists/*   选择合适的基础镜像 (alpine 版本最好)\n alpine 是一个极小化的 Linux 发行版，只有 4MB，这让它非常适合作为基础镜像    设置 WORKDIR 和 CMD\nFROM node:7-alpine # WORKDIR 指令可以设置默认目录，也就是运行 RUN / CMD / ENTRYPOINT 指令的地方。 WORKDIR /app ADD . /app RUN npm install # CMD 指令可以设置容器创建是执行的默认命令。另外，你应该讲命令写在一个数组中，数组中每个元素为命令的每个单词。 CMD [\u0026#34;npm\u0026#34;, \u0026#34;start\u0026#34;]     使用 ENTRYPOINT (可选)\n  在 entrypoint 脚本中使用 exec\n  优先使用 COPY，不使用 ADD\n  合理调整 COPY 与 RUN 的顺序\n 把变化最少的部分放在 Dockerfile 的前面，这样可以充分利用镜像缓存  # 源代码会经常变化，则每次构建镜像时都需要重新安装 NPM 模块，这显然不是我们希望看到的。 # 因此我们可以先拷贝 package.json，然后安装 NPM 模块，最后才拷贝其余的源代码。 # 这样的话，即使源代码变化，也不需要重新安装 NPM 模块 FROM node:7-alpine WORKDIR /app COPY package.json /app RUN npm install COPY . /app ENTRYPOINT [\u0026#34;./entrypoint.sh\u0026#34;] CMD [\u0026#34;start\u0026#34;]    设置默认的环境变量，映射端口和数据卷 使用 LABEL 设置镜像元数据 添加 HEALTHCHECK  参考：\n 如何编写最佳的 Dockerfile  "});index.add({'id':126,'href':'/note/docs/live/diary/2020/06/09/','title':"2020-06-09",'content':"2020 年 6 月 9 日（星期二） 今日待办     编程 export PATH 使用 ~ 不生效 # 不生效 # export PATH=\u0026#34;$PATH:~/code/study/cc/istio/istio-1.6.1/bin\u0026#34; # 必须使用完整路径 export PATH=\u0026#34;$PATH:/Users/yewang/code/study/cc/istio/istio-1.6.1/bin\u0026#34;  IoT LPWA Low power wide area, 低功耗广域技术，使用较低功耗实现远距离的无线信号传输。 相较于熟悉的低功耗蓝牙（BLE）、Zigbee 和 Wifi 等技术，LPWA 的传输距离更远，一般在公里级， 其链接预算（link budget）可达 160dBm，而 BLE 和 Zigbee 等一般在 100dBm 以下。\n和传统的蜂窝网络技术（2G、3G）相比，LPWA 的功耗更低，电池供电的设备使用寿命可达数年。\n基于这两个显著特点，LPWA 可以真正使能物物互联，助力和引领物联网（IoT）革命。\nLoRa、SigFox、NB-IOT 这些都属于 LPWA\nLPWAN LPWAN – Low power wide area network，低功耗广域网络，即使用 LPWA 技术搭建的无线连接网络。\nLPWAN 的网络连接形式可以多种多样，\n典型 LPWA 网络连接\nPLC 工业总线 "});index.add({'id':127,'href':'/note/docs/live/diary/2020/03/08/','title':"2020-03-08",'content':"2020 年 3 月 8 日（星期日） 今日待办  陪闵子玩 Istio 1.5 发布了，学习一个   编程 算法教程 今天看到一个算法教程还不错，推荐一下，labuladong 的算法小抄。\n Istio 1.5 Istio 1.5 于 2020-03-05 发布了。\n引入 Istiod 将控制平面整合为一个新的二进制文件 Istiod，简化了安装、运行和升级。所有 API 和运行时特性均与以前的组件一致。\n参考：官网 1.5 change note\n可扩展性的新模型 Istio 一直是最可扩展的服务网格，其 Mixer 插件允许自定义策略和遥测支持，而 Envoy 扩展则允许数据平面自定义。Istio 1.5 带来了了一个新模型，该模型使用 WebAssembly（Wasm）将 Istio 的可扩展性模型与 Envoy 的统一。Wasm 使开发人员能够安全地在 Envoy 代理中分发和执行代码，以便与遥测系统和策略系统集成，并控制路由，甚至转换消息正文。它将更加灵活和高效，从而无需单独运行 Mixer 组件（这也简化了部署）。\n更容易使用 现在，使用 istioctl 的 Istio 命令行安装已进入 beta 阶段。istioctl 也有十几项改进，包括分析新项目、更好的验证规则，以及更好的与 CI 系统集成的能力等。它已经成为了解 Istio 的系统运行状态并确保配置更改安全的必要工具。\nIstio 的安全性也得到了许多增强，更易于使用。Beta 版自动 mTLS 的启动，简化了 mTLS 的配置并使其自动化。\n更安全 在 1.5 版中，所有安全策略，包括自动 mTLS、AuthenticationPolicy（对等身份验证和 RequestAuthentication）和授权现在都处于 Beta 版。SDS 已经处于稳定版。授权（Authorization）现在支持 \u0026ldquo;拒绝\u0026rdquo; 语义，以强制执行不可覆盖的强制性控件。此外，Node 代理和 Istio 代理已组合到一个二进制文件中，这意味着不再需要配置 PodSecurityPolicy。\n改进不止于此。现在不再需要在每个 Pod 上安装证书，也不必在证书更改时重新启动 Envoy。证书直接从 Istiod 交付到每个 pod。而且，每个 pod 都有唯一的证书。\n更好的可观察性 Telemetry v2 现在报告了原始 TCP 连接（除了 HTTP）的度量标准，并且还通过在遥测和日志中添加响应状态代码来增强了对 gRPC 工作负载的支持。现在默认使用 Telemetry v2。新的遥测系统将等待时间缩短了一半，90％ 的等待时间从 7 毫秒减少到 3.3 毫秒。不仅如此，消除 Mixer 还使总 CPU 消耗减少了 50％，降至每秒每 1,000 个请求 0.55 个 vCPU。\n 生活 陪闵子玩  大部分时间，她还是像以往一样，对着小度播的儿歌，左右摇摆  闵子现在挺会跳了 下午陪闵子画画（乱画）  闵子很喜欢笑，笑起来很可爱，像她妈妈   "});index.add({'id':128,'href':'/note/docs/live/diary/2020/04/08/','title':"2020-04-08",'content':"2020 年 4 月 8 日（星期三） 今日待办     编程 依赖注入 可以通过多种方式为实例提供必要的依赖关系：\n 构造函数注入 属性注入 方法注入  构造函数注入 构造函数注入是许多依赖注入框架的首选方法，常受依赖注入框架的青睐。\n它清楚地告诉我们创建特定组件所需的所有依赖关系，并且这些依赖不是可选的，这些依赖关系在整个组件中应该都是必需的。\npublic class DataProcessor { private final DbManager manager; private final Calculator calculator; public DataProcessor(DbManager manager, Calculator calculator) { this.manager = manager; this.calculator = calculator; } // ... }  优点：  不变性：依赖关系始终如初。   缺点  必须在初始化时提供所有依赖项。  有时，我们无法自己初始化一个组件，或者在某个时刻我们无法提供组件的所有依赖关系。或者我们需要使用另外一个构造函数。一旦设置了依赖项，我们就无法再改变它们了。      属性注入 属性注入更适合可选参数，例如监听或委托。又或是我们无法在初始化时提供依赖关系。\n其它编程语言，例如 Swift，大量使用了带属性的 委托模式。因此，使用属性注入将使其它语言的开发人员更熟悉我们的代码。\npublic class DataProcessor { // 外部要提前进行 属性注入，否则调用会出现 NullPointerException  public DbManager manager = null; public Calculator calculator = null; // ...  public void processData() { // WARNING: Possible NPE  this.manager.processData(); } public BigDecimal calc(BigDecimal input) { // WARNING: Possible NPE  return this.calculator.expensiveCalculation(input); } } 有时，我们无法访问类型实际的初始化方法，只能访问一个已经初始化的实例。或者在初始化时，所需要的依赖关系并不像之后那样明确。\n在这些情况下，我们可以使用属性注入而不是依赖于构造函数。\n 优点  可以通过构造方法注入，也可以通过实例注入 随时注入   缺点  易变性，调用前要注入，否则会出现 NullPointerException    方法注入 如果在每次调用时依赖项可能不同，那么使用方法注入最好不过了。方法注入进一步解耦组件，它使方法本身持有依赖项，而非整个组件。\npublic class DataProcessor { // ...  public BigDecimal calc(Calculator calculator, BigDecimal input) { return calculator.expensiveCalculation(input); } }  优点  进一步解耦组件，它使方法本身持有依赖项，而非整个组件 每次调用时依赖项可以不同   缺点  每次调用都需要传依赖的实例    参考：\n [译] 用依赖注入解耦你的代码   发布策略 蓝绿部署 (Blue-green Deployments) 蓝绿部署的目的是减少发布时的中断时间、能够快速撤回发布。\n蓝绿部署中，一共有两套系统：\n 一套是正在提供服务系统，标记为 “绿色”； 另一套是准备发布的系统，标记为 “蓝色”。  两套系统都是功能完善的，并且正在运行的系统，只是系统版本和对外服务情况不同。\n金丝雀发布 (Canary Releases) 金丝雀发布和国内常说的灰度发布是同一类策略。\n蓝绿部署是准备两套系统，在两套系统之间进行切换，金丝雀策略是只有一套系统，逐渐替换这套系统。\n譬如说，\n 目标系统是一组无状态的 Web 服务器，但是数量非常多，假设有一万台 这时候，蓝绿部署就不能用了，因为你不可能申请一万台服务器专门用来部署蓝色系统  在蓝绿部署的定义中，蓝色的系统要能够承接所有访问   可以想到的一个方法是：  只准备几台服务器，在上面部署新版本的系统并测试验证。测试通过之后，担心出现意外，还不敢立即更新所有的服务器。 先将线上的一万台服务器中的 10 台更新为最新的系统，然后观察验证 确认没有异常之后，再将剩余的所有服务器更新     什么时候可以用蓝绿，不能用金丝雀呢？  整个系统只有一台服务器的时候。    A/B 测试 (A/B Testing) 蓝绿部署和金丝雀是发布策略，目标是确保新上线的系统稳定，关注的是新系统的 BUG、隐患。 A/B 测试关注的是不同版本的服务的实际效果，譬如说转化率、订单情况等。\nA/B 测试是效果测试，同一时间有多个版本的服务对外服务，这些服务都是经过足够测试，达到了上线标准的服务，有差异但是没有新旧之分（它们上线时可能采用了蓝绿部署的方式）。\n在 A/B 测试中，需要能够控制流量的分配，譬如说，为 A 版本分配 10% 的流量，为 B 版本分配 10% 的流量，为 C 版本分配 80% 的流量。\n流量切分  譬如说，给最初更新的 10 台服务器设置较低的权重、控制发送给这 10 台服务器的请求数，然后逐渐提高权重、增加请求数。 既可以用于金丝雀发布，也可以用于 A/B 测试。   nginx 配置问题  nginx 在配置 \u0026ldquo;不启用 keep-alive\u0026rdquo; 时，会在 http 请求结束时主动断开连接  尝试开启 http 的 keep-alive  keepalive_timeout 65;  nginx 与 fast-cgi 的默认连接是短连接  修改 nginx 配置使其与 fastcgi 的连接使用长连接  upstream phpserver{ server 127.0.0.1:9000 weight=1; # upstream 中的 keepalive 指定 nginx 每个 worker 与 fastcgi 的最大长连接数 keepalive 100 }  若 nginx 与 fast-cgi 在同一台服务器上，则使用 unix 域 会更为高效，同时避免了 TIME_WAIT 的问题  proxy_pass 与 fastcgi_pass 的区别 客户端 --http--\u0026gt; 前端负载均衡 Nginx --proxy_pass--\u0026gt; 业务服务器 Nginx --fastcgi_pass--\u0026gt; 业务服务器 php-fpm  我的 MacOS Apps 通用    软件 类型 评分 说明     iTerm 终端 ★★★★★    zoom.us IM - 视频 ★★★★    draw.io 作图 ★★★★    PicGo 图床 ★★★★    Dropbox 备份 - 同步 ★★★★    Keyboard Maestro 快捷键 ★★★★    Alfred 4 搜索 ★★★★    Google Chrome 浏览器 ★★★★    OmniDiskSweeper 系统 - 磁盘管理 ★★★★    ShiftIt 系统 - 窗口移动 ★★★★    Telegram IM ★★★    QQ IM ★★★    Skype for Business IM ★★★    Slack IM ★★★    DingDing IM ★★★    WeChat IM ★★★    WeChat Work IM ★★★    Keynote Office ★★★    Microsoft Excel Office ★★★    Microsoft OneNote Office ★★★    Microsoft Outlook Office ★★★    Microsoft PowerPoint Office ★★★    Microsoft Word Office ★★★    Numbers Office ★★★    Pages Office ★★★    SwitchHosts! host 管理 ★★★    Axure RP 8 产品 ★★★    Sketch 产品 - UI ★★★    V2RayX 代理 ★★★    OmniGraffle 作图 ★★★    Typora 写作 - Markdown ★★★    OneDrive 备份 ★★★    百度网盘 备份 ★★★    Anki 学习 ★★★    LICEcap 录屏 - GIF ★★★    CheatSheet 快捷键显示 ★★★    XMind 思维导图 ★★★    截图 截图 ★★★    OBS 直播 ★★★    Kindle 看书 ★★★    Tencent Lemon 系统 - 磁盘清理 ★★★    InsomniaX 系统 - 禁用休眠 ★★★ 禁用 MacBook 上的合盖休眠   Scroll Reverser 系统 - 鼠标反转 ★★★    IINA 视频 ★★★    The Unarchiver 解压缩 ★★★    NeteaseMusic 音乐 ★★★     编程    软件 类型 评分 说明     Visual Studio Code 编辑器 ★★★★★    Docker  ★★★★    GoLand IDE - Go ★★★★    IntelliJ IDEA IDE - Java ★★★★    PhpStorm IDE - PHP / 前端 ★★★★    Multipass 虚拟机管理 ★★★★    Sublime Text 编辑器 ★★★★    nteract jupyter ★★★    Postman HTTP ★★★    CLion IDE - C++ ★★★    Robo 3T IDE - MongoDB ★★★ 轻量级 Studio 3T   Studio 3T IDE - MongoDB ★★★    Racket v7.2 IDE - Racket ★★★    MIT/GNU Scheme IDE - Scheme ★★★    Xcode IDE - iOS ★★★    微信开发者工具 IDE - 微信 ★★★    Anaconda-Navigator Python ★★★    Beyond Compare diff ★★★    Sourcetree git 管理 ★★★    Dash 定义文档 ★★★    GitHub Desktop 开源 ★★★    Progress Telerik Fiddler 抓包 ★★★ Fiddler   Wireshark 抓包 ★★★    DataGrip 数据库 ★★★    Sourcetrail 源码阅读 ★★★    TeX 编辑器 - LaTeX ★★★    VirtualBox 虚拟机 ★★★     参考：\n nteract/nteract The interactive computing suite for you!   物理 红外光栅传感器 光栅 由大量等宽等间距的平行狭缝构成的光学器件称为光栅（grating）。\n一般常用的光栅是在玻璃片上刻出大量平行刻痕制成，刻痕为不透光部分，两刻痕之间的光滑部分可以透光，相当于一狭缝。\n精制的光栅，在 1cm 宽度内刻有几千条乃至上万条刻痕。\n 利用透射光衍射的光栅称为透射光栅 利用两刻痕间的反射光衍射的光栅，称为反射光栅  如在镀有金属层的表面上刻出许多平行刻痕，两刻痕间的光滑金属面可以反射光    红外光栅 遮挡检测 红外光栅，（又叫电子光栅或红外栅栏）（也叫 “红外栏杆”）是主动红外对射的一种，\n采用多束红外光对射，发射器向接收器以 “低频发射、时分检测” 方式发出红外光，一旦有人员或物体挡住了发射器发出的任何相邻两束以上光线超过 30ms 时，接收器立即输出报警信号，当有小动物或小物体挡住其中一束光线时，报警器不会输出报警信号。\n"});index.add({'id':129,'href':'/note/docs/live/diary/2020/05/08/','title':"2020-05-08",'content':"2020 年 5 月 8 日（星期五） 今日待办  servicemesher/istio-handbook 发周报   编程 Kubernetes node  Name Labels Taints Conditions  MemoryPressure DiskPressure PIDPressure Ready    Name: njjs-sys-jomo14d34c80103718120200110164857.njjs.baidu.com Roles: \u0026lt;none\u0026gt; Labels: aiedge-web=1 beta.kubernetes.io/arch=amd64 beta.kubernetes.io/os=linux gpuenable=1 kubernetes.io/hostname=njjs-sys-jomo14d34c80103718120200110164857.njjs.baidu.com Annotations: node.alpha.kubernetes.io/ttl: 0 volumes.kubernetes.io/controller-managed-attach-detach: true CreationTimestamp: Wed, 04 Mar 2020 14:44:57 +0800 Taints: \u0026lt;none\u0026gt; Unschedulable: false Conditions: Type Status LastHeartbeatTime LastTransitionTime Reason Message ---- ------ ----------------- ------------------ ------ ------- MemoryPressure False Fri, 08 May 2020 20:32:14 +0800 Tue, 14 Apr 2020 19:18:50 +0800 KubeletHasSufficientMemory kubelet has sufficient memory available DiskPressure False Fri, 08 May 2020 20:32:14 +0800 Tue, 14 Apr 2020 19:18:50 +0800 KubeletHasNoDiskPressure kubelet has no disk pressure PIDPressure False Fri, 08 May 2020 20:32:14 +0800 Tue, 14 Apr 2020 19:18:50 +0800 KubeletHasSufficientPID kubelet has sufficient PID available Ready True Fri, 08 May 2020 20:32:14 +0800 Wed, 29 Apr 2020 15:34:10 +0800 KubeletReady kubelet is posting ready status Addresses: InternalIP: 10.173.199.23 Hostname: njjs-sys-jomo14d34c80103718120200110164857.njjs.baidu.com Capacity: cpu: 80 ephemeral-storage: 3783079296Ki hugepages-1Gi: 0 hugepages-2Mi: 0 memory: 263774184Ki nvidia.com/gpu: 4 pods: 110 Allocatable: cpu: 80 ephemeral-storage: 3486485873422 hugepages-1Gi: 0 hugepages-2Mi: 0 memory: 263671784Ki nvidia.com/gpu: 4 pods: 110 System Info: Machine ID: e315a2d0664448eda1f929d7060ce22a System UUID: FDBF926C-DC4C-03E2-B211-D21D00713A1A Boot ID: ff02faa9-473f-467d-a273-70228d44e902 Kernel Version: 4.14.0_1-0-0-16 OS Image: CentOS Linux 7 (Core) Operating System: linux Architecture: amd64 Container Runtime Version: docker://18.9.6 Kubelet Version: v1.13.8 Kube-Proxy Version: v1.13.8 PodCIDR: 10.0.0.0/24 Non-terminated Pods: (8 in total) Namespace Name CPU Requests CPU Limits Memory Requests Memory Limits AGE --------- ---- ------------ ---------- --------------- ------------- --- default fg-car-det-8676b6684-4vr7d 200m (0%) 0 (0%) 4000Mi (1%) 4000Mi (1%) 24d default human-detect-5995f554bd-rc6ck 10m (0%) 0 (0%) 100Mi (0%) 100Mi (0%) 32h default vehicle-det-service-1-68c67c986b-84z76 100m (0%) 0 (0%) 2000Mi (0%) 4000Mi (1%) 9d kube-system ai2b-gateway-j25xt 0 (0%) 0 (0%) 0 (0%) 0 (0%) 151m kube-system calico-node-cx8mq 250m (0%) 0 (0%) 0 (0%) 0 (0%) 65d kube-system nvidia-device-plugin-daemonset-jrdm2 0 (0%) 0 (0%) 0 (0%) 0 (0%) 65d kube-system ote-mysql-0 0 (0%) 0 (0%) 0 (0%) 0 (0%) 24d kube-system web-frontend-nginx-67d7555958-dzq6h 0 (0%) 0 (0%) 0 (0%) 0 (0%) 24d Allocated resources: (Total limits may be over 100 percent, i.e., overcommitted.) Resource Requests Limits -------- -------- ------ cpu 560m (0%) 0 (0%) memory 6100Mi (2%) 8100Mi (3%) ephemeral-storage 0 (0%) 0 (0%) nvidia.com/gpu 3 3 Events: \u0026lt;none\u0026gt; 调度 Kubernetes 资源模型\n在 Kubernetes 里，Pod 是最小的原子调度单位。 所有跟调度和资源管理相关的属性都应该是属于 Pod 对象的字段。 最重要的部分，就是 Pod 的 CPU 和内存配置。\n可压缩资源 CPU 当可压缩资源不足时，Pod 只会 “饥饿”，但不会退出。\n不可压缩资源 当不可压缩资源不足时，Pod 就会因为 OOM（Out-Of-Memory）被内核杀掉。\n由于 Pod 可以由多个 Container 组成，所以 CPU 和内存资源的限额，是要配置在每个 Container 的定义上的。这样，Pod 整体的资源配置，就由这些 Container 的配置值累加得到。\n docker 删除所有容器，包括正在运行的容器\ndocker rm -f `docker ps -a -q` docker rpm 下载地址\n Linux sudo 免密码   切换到 root 用户\n  添加 sudo 文件的写权限，命令是:\n  chmod u+w /etc/sudoers 编辑 sudoers 文件  vi /etc/sudoers 找到这行 root ALL=(ALL) ALL, 在他下面添加 xxx ALL=(ALL) ALL (这里的 xxx 是你的用户名)\nps: 这里说下你可以 sudoers 添加下面四行中任意一条\n# 允许用户 youuser 执行 sudo 命令 (需要输入密码). youuser ALL=(ALL) ALL # 允许用户组 youuser 里面的用户执行 sudo 命令 (需要输入密码). %youuser ALL=(ALL) ALL # 允许用户 youuser 执行 sudo 命令，并且在执行的时候不输入密码. youuser ALL=(ALL) NOPASSWD: ALL # 允许用户组 youuser 里面的用户执行 sudo 命令，并且在执行的时候不输入密码. %youuser ALL=(ALL) NOPASSWD: ALL 撤销 sudoers 文件写权限，命令:  chmod u-w /etc/sudoers "});index.add({'id':130,'href':'/note/docs/live/diary/2020/06/08/','title':"2020-06-08",'content':"2020 年 6 月 8 日（星期一） 今日待办     编程 git git clone --depth 1 什么时候用？\ngit clone --depth 1 之后，想拉取所有\ngit pull --unshallow 参考：\n Pull updates with git after cloned with \u0026ndash;depth 1   CPU amd64 386 arm64 arm_v7 arm_v6 arm_v5 mips64le mips64 mipsle mips  操作系统内核 linux freebsd darwin windows ios android npc_sdk npc_syno  linux top 排序\nMacOS  cpu 排序： 先输入 o，然后输入 cpu 内存排序： 先输入 o，然后输入 rsize  Linux  P：按照 cpu 使用率排序 M：按照内存使用率排序 l：切换显示平均负载和启动时间信息 m：切换显示内存信息 t：切换显示进程和 cpu 状态信息 c：切换显示命令名称和完成命令行信息    git github gitlab gitcafe GitCafe 已被 http://Coding.net 收购\ngitee https://gitee.com 码云， 开源中国出品\ncode.csdn.net 于 2018 年 10 月 31 日关闭，建议用户迁移到码云\n参考：\n 码云 CSDN CODE 一键迁移功能使用说明  "});index.add({'id':131,'href':'/note/docs/live/diary/2020/04/07/','title':"2020-04-07",'content':"2020 年 4 月 7 日（星期二） 今日待办  201 PoSD 翻译  修改负责的 5 个 Principles 并提交到 icode 前 20 个 Principles 合并到 word，并提交给出版社进行初审     编程 编程哲学 中文房间 中文房间（英语：Chinese room），是由约翰・希尔勒提出的一个思想实验，借以反驳强人工智能的观点。根据强人工智能的观点，只要计算机拥有了适当的程序，理论上就可以说计算机拥有它的认知状态并且可以像人一样地进行理解活动。\n该实验出自约翰・罗杰斯・希尔勒的论文《心灵、大脑和程序》（ Minds, Brains, and Programs）中，发表于 1980 年的《 行为与脑科学（英语：Behavioral and Brain Sciences）》。\n中文房间思想实验是什么？它是否成功地否决了图灵测试的有效性？\n中文房间是否可以否定人类会思考？\n因果论与自由意志 k8s rancher/fleet  Rancher 开源 Fleet：业界首个海量 K8S 集群管理项目\n2019 年，Rancher 推出了一系列轻量级 Kubernetes 开源项目，包括轻量级的 Kubernetes 发行版 K3s 、基于 Kubernetes 的应用程序部署引擎 Rio 、业界首个 Kubernetes 操作系统 K3OS 。\nrancher/rio  Rio 是 Rancher 新出的一款轻量级 service mesh 产品，基于 linkerd2，相当轻。但麻雀虽小，五脏俱全，基本上 istio 有的功能，它都有。\n参考：\n Rancher 极简 service mesh 产品 Rio 安装试玩（基于 k3s）  cncf/udpa  Universal Data Plane API Working Group (UDPA-WG)\nGoal: The objective of the Universal Data Plane API Working Group (UDPA-WG) is to bring together parties across the industry interested in a common control and configuration API for data plane proxies and load balancers.\nnote 使用 netlify 部署 gitbook 参考：A Step-by-Step Guide: GitBook on Netlify\n最后一步使用\nnpm install -g gitbook-cli \u0026amp;\u0026amp; gitbook install \u0026amp;\u0026amp; gitbook build 使用 netlify 持续部署 PR 参考：Github 集成 Netlify：快速预览 PR\nvps Ubuntu 开源镜像  清华开源镜像  CentOS Ubuntu   阿里巴巴开源镜像  Ubuntu    oh-my-zsh https://raw.githubusercontent.com/ohmyzsh/ohmyzsh/master/tools/install.sh\nzsh prompt export PROMPT=\u0026#39;%{$fg[magenta]%}%(?..%?%1v)%n@%{$fg[green]%}%M:%{$fg[cyan]%}%c%{$reset_color%} $(git_prompt_info)\u0026#39; 设置默认为 zsh sudo chsh -s /usr/bin/zsh ubuntu  电影 乔乔的异想世界 Jojo Rabbit (2019) 导演: 塔伊加・维迪提\n编剧: 塔伊加・维迪提 / 克里斯汀・勒南斯\n主演: 罗曼・格里芬・戴维斯 / 托马辛・麦肯齐 / 斯嘉丽・约翰逊 / 塔伊加・维迪提 / 山姆・洛克威尔\n 语言 左图右史 左图右史，汉语成语，拼音是 zuǒ tú yòu shǐ，意思是形容室内图书多。出自《新唐书·杨绾传》。\n参考：\n 左图右史，如何直观形象的去学习历史  "});index.add({'id':132,'href':'/note/docs/live/diary/2020/05/07/','title':"2020-05-07",'content':"2020 年 5 月 7 日（星期四） 今日待办     编程 brookhong/Surfingkeys  Surfingkeys 和现有的一些插件一样，让你尽可能的通过键盘来使用 Chrome/Firefox 浏览器，比如跳转网页，上下左右滚屏。但不只是给 vim 用户使用，Surfingkeys 的基本特性是让你自己写一段 Javascript 脚本，然后通过 mapkey 映射到某些按键。之后当你按了那几个键以后，对应的 Javascript 脚本就会被执行。\n快捷键  ?: 显示帮助   t: 搜索收藏夹和访问历史  参考：\n Surfingkeys \u0026ndash; 用 javascript 和键盘扩展你的 chrome  SaltStack Saltstack 是基于 python 开发的一套 C/S 自动化运维工具。\n漏洞风险 参考：\n SaltStack 远程命令执行漏洞风险通告（CVE-2020-11651/CVE-2020-11652）   公司 今日头条  EE 效率工程部：做飞书，包括存储/文档 Data 广告数据部：包括数据分析，AI-Lab，广告系统，接入分发，内容平台 IES 抖音多媒体部：抖音引擎，服务端中台，faceu 产品研发部：小说，小游戏，今日头条主端 app，新业务孵化以及基础架构  大的分类就这四个部门，还有 EA 企业信息化，风控跟安全一级部门等等\n"});index.add({'id':133,'href':'/note/docs/live/diary/2020/04/06/','title':"2020-04-06",'content':"2020 年 4 月 6 日（星期一） 备注：\n 清明节放假  今日待办  201 PoSD 翻译  前 20 个 Principles 翻译审校（评论） 编委会讨论前 20 个 Principles 翻译修改版 修改负责的 5 个 Principles 并提交到 icode    "});index.add({'id':134,'href':'/note/docs/live/diary/2020/05/06/','title':"2020-05-06",'content':"2020 年 5 月 6 日（星期三） 备注： 五一假后第一天\n今日待办     编程 算法复杂度 圈复杂度 圈复杂度（Cyclomatic complexity，简写 CC）也称为条件复杂度，是一种代码复杂度的衡量标准。由托马斯・J・麦凯布（Thomas J. McCabe, Sr.）于 1976 年提出，用来表示程序的复杂度，其符号为 VG 或是 M。它可以用来衡量一个模块判定结构的复杂程度，数量上表现为独立现行路径条数，也可理解为覆盖所有的可能情况最少使用的测试用例数。圈复杂度大说明程序代码的判断逻辑复杂，可能质量低且难于测试和 维护。程序的可能错误和高的圈复杂度有着很大关系。\n圈复杂度的计算方法很简单，计算公式为：\nV(G) = E - N + 2\n其中，e 表示控制流图中边的数量，n 表示控制流图中节点的数量。\n几个节点通过边连接。\n其实，圈复杂度的计算还有更直观的方法，因为圈复杂度所反映的是 “判定条件” 的数量，所以圈复杂度实际上就是等于判定节点的数量再加上 1，也即控制流图的区域数，对应的计算公式为：\nV (G) = P + 1\n其中 P 为判定节点数，判定节点举例：\nif 语句 while 语句 for 语句 case 语句 catch 语句 and 和 or 布尔操作 ?: 三元运算符\n参考：\n 详解圈复杂度   Kubernetes kubernetes/client-go  Kubernetes 官方从 2016 年 8 月份开始，将 Kubernetes 资源操作相关的核心源码抽取出来，独立出来一个项目 Client-go，作为官方提供的 Go client。 Kubernetes 的部分代码也是基于这个 client 实现的。\nclient-go 是一个调用 kubernetes 集群资源对象 API 的客户端，即通过 client-go 实现对 kubernetes 集群中资源对象（包括 deployment、service、ingress、replicaSet、pod、namespace、node 等）的增删改查等操作。大部分对 kubernetes 进行前置 API 封装的二次开发都通过 client-go 这个第三方包来实现。\n\n Github 搜索技巧 stars:\u0026gt;10000 forks:\u0026gt;5000 language:Go pushed:\u0026lt;2020-05-01  iptables 清空规则 iptables -F iptables --flush  Mac App Mortennn/Dozer  Hide status bar icons on macOS\n安装：\nbrew cask install dozer "});index.add({'id':135,'href':'/note/docs/live/diary/2020/06/05/','title':"2020-06-05",'content':"2020 年 6 月 5 日（星期五） 今日待办     编程 Beyond Compare MacOS 破解 移除失效的认证\nrm -rf ~/Library/Application\\ Support/Beyond\\ Compare/ moranzcw/Computer-Networking-A-Top-Down-Approach-NOTES  《计算机网络－自顶向下方法 (原书第 6 版)》编程作业，Wireshark 实验文档的翻译和解答。\nPacket Sender dannagle/PacketSender TCP, UDP, SSL 发包工具 https://packetsender.com/\n"});index.add({'id':136,'href':'/note/docs/live/diary/2020/05/04/','title':"2020-05-04",'content':"2020 年 5 月 4 日（星期一） 备注： 五一假日\n今日待办     编程 亚马逊的 14 条领导力原则 中文 1\n顾客至上\n简而言之，客户永远是第一位的，不管发生什么。这一点超越了所有的职责要求。从客户的角度出发、为客户牺牲自己的利益，实际上是说，你要愿意承担损失以便让客户获利，哪怕是违背你自己的使用条款或政策。如果你知道自己犯了错，要主动考虑退款，也就是说，要在客户要求之前作出补偿。\n2\n主人翁精神\n主人翁精神意味着两件事：\n（1）总是优先考虑长期目标，而不是短期目标；\n（2）始终代表团队和整个公司行事，一切都是 “你的工作”。\n3\n创新与简化\n成功的关键是保持简单，为此，需要不断创新。\n4\n正确，很多\n这个原则应该被理解为 “领导者要正确决策”。它说的不仅仅是不犯错误，而是要有全局观，在必要时能够并且愿意 180 度转变态度。史蒂夫・乔布斯正是因此而出名：今天他相信 XYZ，第二天他就会意识到自己完全错了，突然间他就完全支持 ABC 了。从这个角度来说，他做出了正确的决策。\n5\n学习并充满好奇心\n这项原则可以说是不言而喻。领导者必须时刻努力吸收更多的知识，进行自我提升。\n6\n雇佣人才，更要实现人尽其才\n这一点也是显而易见，但除了要确保提高雇佣标准外，更重要是，确定雇佣关系后，你要不断地培养员工，使他们发挥出最大潜力。\n7\n坚持高标准\n伟大的领导者总是在提高标准，创造最优质的产品和服务。\n8\n往大处着眼\n这项原则并不是说脱离实际，好高骛远；往大处着眼的同时，也要遵从第一条 “顾客至上” 的原则。\n9\n积极行动\n这项原则常常令人困惑不已。它的原理在于，由于多数错误并非不可挽回，所以冒险犯错也无可厚非。因此，伟大的领导者要积极行动：快速前进，而非被分析捆住了手脚，裹足不前。\n10\n节俭\n这条普遍适用于所有创业公司创始人：不能毫无节制地花钱。基本上，就是用最少的钱干最多的事，在投入最小化的同时做到产出的最大化。\n11\n赢得信任\n这是一条双行道：不仅需要取得他人的信任，也需要使他人感受到被信任的感觉。\n12\n深入研究\n数据才是最重要的。当数据和感觉不一致时，可以质疑，但要相信数据。\n13\n永远坚守核心，处理好争议与承诺\n虽然排到第十三位，但这条原则至关重要。它是说：当两方存在争议时，这很平常，有人最后坚决反对，十分坚定地说 “不”，也说清楚了个中缘由，在这样的情况下，你依然能同意去尝试不同的选择，并且给予全力支持。也就是说，即使你不同意，你也会给出自己的承诺去尝试。\n14\n达成最好的成果\n永远不要轻易屈从或妥协于任何事情，直到最终获得最好的结果。并且无论出现什么情况，总要找到方法克服一切困难。\nEnglish 1\nCustomer Obsession\nLeaders start with the customer and work backwards. They work vigorously to earn and keep customer trust. Although leaders pay attention to competitors, they obsess over customers.\n2\nOwnership\nLeaders are owners. They think long term and don\u0026rsquo;t sacrifice long-term value for short-term results. They act on behalf of the entire company, beyond just their own team. They never say \u0026lsquo;that\u0026rsquo;s not my job.\u0026rsquo;\n3\nInvent \u0026amp; simplify\nLeaders expect and require innovation and invention from their teams and always find ways to simplify. They are externally aware, look for new ideas from everywhere, and are not limited by \u0026lsquo;not invented here.\u0026rsquo; As we do new things, we accept that we may be misunderstood for long periods of time.\n4\nAre right, a lot\nLeaders are right a lot. They have strong business judgment and good instincts.\n5\nHire and Develop the Best\nLeaders raise the performance bar with every hire and promotion. They recognize exceptional talent and willingly move them throughout the organization. Leaders develop leaders and take seriously their role in coaching others.\n6\nInsist on the Highest Standards\nLeaders have relentlessly high standards — many people may think these standards are unreasonably high. Leaders are continually raising the bar and driving their teams to deliver high quality products, services, and processes. Leaders ensure that defects do not get sent down the line and that problems are fixed so they stay fixed.\n7\nThink Big\nThinking small is a self-fulfilling prophecy. Leaders create and communicate a bold direction that inspires results. They think differently and look around corners for ways to serve customers.\n8\nBias for Action\nSpeed matters in business. Many decisions and actions are reversible and do not need extensive study. We value calculated risk taking.\n9\nFrugality\nAccomplish more with less. Constraints breed resourcefulness, self-sufficiency and invention. There are no extra points for growing headcount, budget size, or fixed expense.\n10\nVocally Self Critical\nLeaders do not believe their or their team’s body odor smells of perfume .Leaders came forward with problems or information,even when doing so is awkward and or embarrassing.Leader benchmark themselves and their teams against the best.\n11\nEarn Trust of Others\nLeaders are sincerely open-minded,genuinely is ten,and are willing to examine their strangest convictions with humility.\n12\nDive Deep\nLeaders operate at all levels, stay connected to the details, audit frequently, and are skeptical when metrics and anecdote differ. No task is beneath them.\n13\nHave Backbone\nDisagree and Commit: Leaders are obligated to respectfully challenge decisions when they disagree, even when doing so is uncomfortable or exhausting. Leaders have conviction and are tenacious. They do not compromise for the sake of social cohesion. Once a decision is determined, they commit wholly.\n14\nDeliver Results\nLeaders focus on the key inputs for their business and deliver them with the right quality and in a timely fashion. Despite setbacks, they rise to the occasion and never settle.\n  JavaScript 异步 Promise Promise 是 ES6 中提供的一个异步编程的解决方案， 使用 Promise 的好处，就是在处理异步程序时，将异步操作队列化， 按照期望的顺序执行，返回符合预期的结果， 这样即使是多重异步操作，也可以方便的使用 Promise 进行链式调用\nPromise 本身是一个构造函数， 一般使用 new Promise () 创建一个新的 Promise 对象\n Promise 对象是一个异步操作，有三种状态：  pending（进行中） fulfilled（已成功） rejected（已失败）   对象的状态不受外界影响。  只有异步操作的结果，可以决定 Promise 是哪一种状态，任何其他操作都无法改变这个状态。   Promise 对象的状态改变，只有两种可能：  从 pending 变为 fulfilled 或者 从 pending 变为 rejected。 只要这两种情况发生，状态就不会再变了，会一直保持这个结果，这时就称为 resolved（已定型） 任何时候都可以得到这个结果。    Promise 的特点 无等待\nPromise 缺点  无法取消 Promise，一旦新建它就会立即执行，无法中途取消 如果不设置回调函数，Promise 内部抛出的错误，不会反应到外部 当处于 pending 状态时，无法得知目前进展到哪一个阶段（刚刚开始还是即将完成）  Promise 方法 then race race 的用法， 语法和 all () 一样，但是返回值有所不同，\nrace 根据传入的多个 Promise 实例，只要有一个实例 resolve 或者 reject，就只返回该结果，其他实例不再执行，\n也就是说多个异步程序，只返回响应最快的那个异步程序，不论成功或者失败，就把最快响应的返回值返回，后面的异步程序不再执行\nresolve 将非 Promise 类型的对象，转为 Promise 对象\n// 下面两种 等价 Promise.resolve(x); new Promise((resolve) =\u0026gt; { resolve(x); });  Generator 参考：\n Generator 函数的含义与用法   async vs await 异步操作是 JavaScript 编程的麻烦事，麻烦到一直有人提出各种各样的方案，试图解决这个问题。\n从最早的回调函数，到 Promise 对象，再到 Generator 函数，每次都有所改进，但又让人觉得不彻底。它们都有额外的复杂性，都需要理解抽象的底层运行机制。\nasync 函数就是 Generator 函数的语法糖。\nasync 函数（包含函数语句、函数表达式、Lambda 表达式）会返回一个 Promise 对象， 如果在函数中 return 一个直接量，async 会把这个直接量通过 Promise.resolve() 封装成 Promise 对象。\nawait await 关键字只能放在 async 函数内部\n await 是个运算符，用于组成表达式，await 表达式的运算结果取决于它等的东西  一个 Promise 对象，或者其它值   如果等的是一个 Promise 对象，await 就忙起来了，它会阻塞后面的代码， 等着 Promise 对象 resolve，然后得到 resolve 的值，作为 await 表达式的运算结果  async 函数调用不会造成阻塞，它内部所有的阻塞都被封装在一个 Promise 对象中异步执行   如果等的不是一个 Promise 对象，那 await 表达式的运算结果就是它等到的东西  参考：\n async 函数的含义和用法   Github repo-report list stargazers\n需要添加 accept header\nlet stargazers = await context.github.paginate( context.github.activity.getStargazersForRepo({ headers: { accept: \u0026#34;application/vnd.github.v3.star+json\u0026#34;, }, owner, repo, per_page: 100, }), (res) =\u0026gt; res.data );  C++ IDE 推荐 CLION\n编译器 GCC/G++\nyedf/handy  简洁易用的 C++11 网络库 支持单机千万并发连接\n参考：\n C++ 后台开发有哪些练基础的开源项目？   英语面试 在 Udacity 和 YouTube 编程频道练习听力\npramp.com 参考：\n 如何训练自己给老外讲算法题的能力？ 如何得到 Google 的工作机会？ 程序员想要出国工作（欧美国家）有哪些可以努力的途径？   算法 Root of Number 开方根 题目 Many times, we need to re-implement basic functions without using any standard library functions already implemented. For example, when designing a chip that requires very little memory space.\nIn this question we’ll implement a function root that calculates the n’th root of a number. The function takes a nonnegative number x and a positive integer n, and returns the positive n’th root of x within an error of 0.001 (i.e. suppose the real root is y, then the error is: |y-root(x,n)| and must satisfy |y-root(x,n)| \u0026lt; 0.001).\nDon’t be intimidated by the question. While there are many algorithms to calculate roots that require prior knowledge in numerical analysis (some of them are mentioned here), there is also an elementary method which doesn’t require more than guessing-and-checking. Try to think more in terms of the latter.\nMake sure your algorithm is efficient, and analyze its time and space complexities.\nExamples:\ninput: x = 7, n = 3 output: 1.913 input: x = 9, n = 2 output: 3 Constraints: [time limit] 5000ms [input] float x 0 ≤ x [input] integer n 0 \u0026lt; n [output] float 分析 二分法答案（Python） def root(x, n): if x == 0: return 0 low, high = 1, x while low \u0026lt; high: mid = (low + high) / 2 ans = mid ** n if abs(ans - x) \u0026lt; 0.001: return round(mid, 3) elif ans \u0026gt; x: high = mid else: low = mid return -1 print(root(7, 3))   学习 学位  B.A.  文学士 Bachelor Degree of Art   B.Sc.  理学士学位 Bachelor Degree of Science   B.Eng.  工学士学位 Bachelor Degree of Engineering   Nanodegree M.A. M.Sc.  科学硕士 master of science   M.Eng.  工程硕士 master of engineering   MBA 工商管理硕士 Master of Business Administration Ph.D.  Doctor degree 或 Doctor of Philosophy     历史 珍宝岛事件 背景： 中国脱离苏联，与美国建交。\n珍宝岛事件（中方称为珍宝岛自卫反击战）是指中华人民共和国和苏联因黑龙江流域的珍宝岛的归属问题于 1969 年 3 月间在岛上发生的武装冲突。事件以中方胜利告终，中方在事件后实际控制了珍宝岛。\n事件致使中苏关系进一步恶化。珍宝岛一役后，苏联高层曾多次商讨要对中国进行报复，并明确发出先发制人和核打击的威胁，中方作出相应舆论回击。苏联更是从周边围堵和威胁当时的中国。这使得珍宝岛事件成为继古巴导弹危机后冷战期间又一次爆发全面核战争的重大危机。\n官 / 吏 粗略可以认为，有品级的都属于官。这里的 “品级” 包括低于从九品的 “未入流” 一级。以清代为例，知县（正七品）以下的官员如县丞（正八品）、主簿（正九品）、巡检（从九品）、驿丞（未入流），都是官，不是吏。有些佐贰官如县丞有机会升到知县，但不都是如此，具体情况要参见《品级考》。\n参考：\n 明清两代官和吏的区别什么吗？ 官与吏的区别？官如何与吏分流的？ 北京大学公开课：中国古代政治与文化  "});index.add({'id':137,'href':'/note/docs/live/diary/2020/06/04/','title':"2020-06-04",'content':"2020 年 6 月 4 日（星期四） 今日待办     编程 判断是物理机还是虚拟机 $ systemd-detect-virt On KVM for example it returns:\nkvm and on a non-virtualized host:\nnone 其他方法 dmesg | grep -i virtual 基于 hardware，则说明是物理机\n结果返回包含 virtual，则是虚拟机\n$ dmesg |grep -i virtual [0.000000] Booting paravirtualized kernel on Xen HVM [1.034572] systemd[1]: Detected virtualization xen. [1.065757] systemd[1]: Starting Setup Virtual Console... [1.287144] xen_netfront: Initialising Xen virtual ethernet driver 参考：\n Easy way to determine virtualization technology  网络 TCP 和 UDP 的端口号可以是同一个吗 可以。\n 端口不是物理概念，仅仅是协议栈中的两个字节 TCP 和 UDP 的端口完全没有任何关系，完全有可能又有一种 XXP 基于 IP，也有端口的概念 TCP 和 UDP 传输协议监听同一个端口后，接收数据互不影响，不冲突。因为数据接收时时根据五元组 {传输协议，源IP，目的IP，源端口，目的端口} 判断接受者的  MacOS 查看端口占用的进程 sudo lsof -nP -iTCP:端口号 -sTCP:LISTEN  -n 表示不显示主机名 -P 表示不显示端口俗称 不加 sudo 只能查看以当前用户运行的程序  网卡 Two character prefixes based on the type of interface\n   Prefix Description     en Ethernet   ib InfiniBand   sl Serial line IP (slip)   wl Wireless local area network (WLAN)   ww Wireless wide area network (WWAN)    ethxxx -\u0026gt; enpxxx Ubuntu 16 进行更新了，网络接口的命名方式变了\n参考：\n systemd.net-naming-scheme — Network device naming schemes Linux - 网卡命名方式改变了 - enp0s3，enp0s8  网桥 IPC vs NVR IPC: IP-CAMERA\nNVR: Network Video Recorder\n NVR 前端是接网络摄像头 NVR 比 DVR 要清晰的多 有些 NVR 也兼容 DVR 的功能  DVR: Digital Video Recorder\n DVR 前端是接模拟摄像头  参考：\n IPC\\DVS\\DVR 与 NVR 之间的区别   Subsurface 有一个潜水记录 + 可视化的软件 subsurface, Linus 一定是很喜欢潜水，因为他经常往这个项目里提 pull request (迄今为止 commit 了 895 次，贡献了 33 万行代码) . 而这款软件的技术栈是 Qt + C++.\niostream: fix incorrect rfcomm error case when reading by torvalds · Pull Request #2673 · Subsurface-divelog/subsurface\n参考：\n 为什么看到这么多人不推荐 C++？  Linus Torvalds 只 star 了两个 Repositories，\n一个是 torvalds/linux ，\n另一个是 subsurface/subsurface  Linux 信号 信号是进程间通信的底层形式。\nLinux 有标准信号 32 个，从 32-63 的信号是实时信号。\n发送信号的原因：\n 硬件异常：如 0 作为除数，内核会发送 SIGFPE（信号值 8） 软件异常：如进程终止时，内核会给父进程发送 SIGCHLE（信号值 17），窗口大小调整，应用程序会收到 SIGWINCH（信号值 28）  普通用户使用的信号  SIGHUP 1  a program loses its controlling terminal   SIGINT 2  the user at the controlling terminal presses the interrupt character, which by default is ^C (Control-C).   SIGQUIT 3  the user at the controlling terminal presses the quit character, which by default is ^\\ (Control-Backslash)   SIGILL 4  执行了非法指令   SIGKILL 9  不可以被阻塞、处理和忽略   SIGTERM 15  kill 默认不带参数，发送的信号就是 SIGTERM 可以被阻塞、处理和忽略   SIGTOP 20  停止（挂起）进程 CRTL+D    "});index.add({'id':138,'href':'/note/docs/live/diary/2020/04/03/','title':"2020-04-03",'content':"2020 年 4 月 3 日（星期五） 今日待办     编程 Bookinfo Application 安装 istio istioctl manifest apply --set profile=demo kubectl label namespace default istio-injection=enabled 参考：https://istio.io/docs/setup/getting-started/\n运行 Bookinfo sample application alias k=\u0026#34;kubectl\u0026#34; k apply -f samples/bookinfo/platform/kube/bookinfo.yaml k get services 查看 Bookinfo 应用是否正常\nby checking for the page title in the response\nkubectl exec -it $(kubectl get pod -l app=ratings -o jsonpath=\u0026#39;{.items[0].metadata.name}\u0026#39;) -c ratings -- curl productpage:9080/productpage | grep -o \u0026#34;\u0026lt;title\u0026gt;.*\u0026lt;/title\u0026gt;\u0026#34; Set the ingress IP and ports:\nexport INGRESS_HOST=$(kubectl -n istio-system get service istio-ingressgateway -o jsonpath=\u0026#39;{.status.loadBalancer.ingress[0].ip}\u0026#39;) export INGRESS_PORT=$(kubectl -n istio-system get service istio-ingressgateway -o jsonpath=\u0026#39;{.spec.ports[?(@.name==\u0026#34;http2\u0026#34;)].port}\u0026#39;) export SECURE_INGRESS_PORT=$(kubectl -n istio-system get service istio-ingressgateway -o jsonpath=\u0026#39;{.spec.ports[?(@.name==\u0026#34;https\u0026#34;)].port}\u0026#39;) Docker Desktop 的 Kubernetes 版本需要使用 hostname 而不是 ip\nexport INGRESS_HOST=$(kubectl -n istio-system get service istio-ingressgateway -o jsonpath='{.status.loadBalancer.ingress[0].hostname}')   To confirm that the Bookinfo application is accessible from outside the cluster:\ncurl -s http://${GATEWAY_URL}/productpage | grep -o \u0026quot;\u0026lt;title\u0026gt;.\\*\u0026lt;/title\u0026gt;\u0026quot;  stedolan/jq  Command-line JSON processor http://stedolan.github.io/jq/\n"});index.add({'id':139,'href':'/note/docs/live/diary/2020/06/03/','title':"2020-06-03",'content':"2020 年 6 月 3 日（星期三） 今日待办     编程 kernel-devel 如果某个程序需要内核提供的一些功能，它就需要内核的 C header 来编译程序，这个时候 linux-devel 里面的东西就用上了。\n比如 nvidia 和 ati 的官方显卡驱动，alsa-driver 声卡驱动，他们都需要编译一个放在内核里面运行的模块，编译这个模块就需要内核的 header 文件才能顺利编译。\n当然，kernel-devel 不光是 C Header 文件，它还有内核的配置文件，以及其他的开发用的资料\nkernel devel vs kernel source kernel-devel 包只包含用于内核开发环境所需的内核头文件以及 Makefile， 而 kernel-souce 包含所有内核源代码。\n如果仅仅是用于你自己编写的模块开发的话，因为只需引用相应的内核头文件，所以只有 devel 包即可， 如果你要修改现有的内核源代码并重新编译，那必须是 kernel-souce。\nkernel-devel 是用做内核一般开发的，比如编写内核模块，原则上，可以不需要内核的原代码。 kernel 则是专指内核本身的开发，因此需要内核的原代码。\n lspci 显示当前主机的所有 PCI 总线信息，以及所有已连接的 PCI 设备信息。\nPCI Peripheral Component Interconnect 外设部件互连标准\n个人电脑中使用最为广泛的接口，几乎所有的主板产品上都带有这种插槽\n centos 安装 Kubernetes 环境 安装 GPU 驱动 检测是否检测到 GPU 设备 $ lspci | grep -i nvidia 3b:00.0 3D controller: NVIDIA Corporation GP104GL [Tesla P4] (rev a1) 86:00.0 3D controller: NVIDIA Corporation GP104GL [Tesla P4] (rev a1) af:00.0 3D controller: NVIDIA Corporation GP104GL [Tesla P4] (rev a1) d8:00.0 3D controller: NVIDIA Corporation GP104GL [Tesla P4] (rev a1) 安装 gcc yum install gcc 安装与当前 kernel 对应的 kernel-devel，yum 不能安装的用 rpm 安装\nyum install kernel-devel-$(uname -r) 若无法通过 yum 来安装 kernel-devel，可下载对应的 kernel-devel 文件安装\n#查看对应内核版本 uname -r wget --user=guest01 --password=baidu@123 ftp://cp01-cos-dev01.cp01.baidu.com:/kernel-4.14.0_1-0-0-16/kernel-devel-4.14.0_1-0-0-16.tgz tar -zxvf kernel-devel-4.14.0_1-0-0-16.tgz cd kernel-devel-4.14.0_1-0-0-16 ./auto_changekernel.sh #检查/usr/src/kernel目录下是否能看到kernel ls /usr/src/kernels 安装 GPU 驱动 首先在 Nvidia 官网下载驱动\n运行下载好的驱动文件\n./NVIDIA-Linux-x86_64-418.116.00.run --kernel-source-path=/usr/src/kernels/4.14.0_1-0-0-16 --kernel-source-path 内核文件路径\n验证\nnvidia-smi\n yum 安装 docker-ce # 安装依赖包 yum install -y yum-utils device-mapper-persistent-data lvm2 # 添加 docker yum 源 yum-config-manager --add-repo https://download.docker.com/linux/centos/docker-ce.repo # 如果网络速度太慢，可更换其他 docker-ce 源 # yum-config-manager --add-repo https://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo # 安装指定版本 # docker-ce 的最新版本为 19.03，同时也集成了 GPU 能力，但不确定是否兼容 nvidia-docker，所以目前 docker-ce 还是使用 18.09 版本。 #查看docker-ce版本 yum list docker-ce --showduplicates yum install docker-ce-18.09.6 #启动docker systemctl start docker nvidia-docker NVIDIA/nvidia-docker 因为 GPU 属于特定的厂商产品，需要特定的 driver， Docker 本身并不支持 GPU。 以前如果要在 Docker 中使用 GPU，就需要在 container 中安装主机上使用 GPU 的 driver， 然后把主机上的 GPU 设备（例如：/dev/nvidia0）映射到 container 中。 所以这样的 Docker image 并不具备可移植性。\nNvidia-docker 项目就是为了解决这个问题， 它让 Docker image 不需要知道底层 GPU 的相关信息，而是通过启动 container 时 mount 设备和驱动文件来实现的。\nyum 安装 nvidia-docker2 # 配置yum源 distribution=$(. /etc/os-release;echo $ID$VERSION_ID) curl -s -L https://nvidia.github.io/nvidia-docker/$distribution/nvidia-docker.repo | sudo tee /etc/yum.repos.d/nvidia-docker.repo # 安装nvidia-docker2 yum install -y nvidia-docker2 # 修改docker配置，添加nvidia runtime cat /etc/docker/daemon.json { \u0026#34;default-runtime\u0026#34;: \u0026#34;nvidia\u0026#34;, \u0026#34;runtimes\u0026#34;: { \u0026#34;nvidia\u0026#34;: { \u0026#34;path\u0026#34;: \u0026#34;/usr/bin/nvidia-container-runtime\u0026#34;, \u0026#34;runtimeArgs\u0026#34;: [] } } } #重启docker systemctl restart docker #ps aux | grep dockerd | grep -v grep | awk \u0026#39;{ print $2; }\u0026#39;|xargs -L 1 sudo kill -HUP 安装 k8s 环境 ipvs 安装 modprobe -- ip_vs modprobe -- ip_vs_rr modprobe -- ip_vs_wrr modprobe -- ip_vs_sh modprobe -- nf_conntrack_ipv4 yum install ipvsadm -y kubeadm 安装 k8s 集群 # apiserver-advertise-address指定master的interface，pod-network-cidr指定Pod网络的范围, service-cidr指定svc的范围 kubeadm init --service-cidr 10.240.0.0/16 --apiserver-advertise-address 172.27.9.131 --pod-network-cidr=10.244.0.0/16 参考：\n centos7 使用 kubeadm 部署 k8s 集群（单点 master，flannel 网络） （测试可用） centos7 使用 kubeadm 部署多 master 高可用集群（flannel 网络）  更换 calico 网络 wget -c https://docs.projectcalico.org/v3.8/getting-started/kubernetes/installation/hosted/kubernetes-datastore/calico-networking/1.7/calico.yaml # 修改calico.yaml中的CALICO_IPV4POOL_CIDR与kubeadm init指定的--pod-network-cidr保持一致（https://zhuanlan.zhihu.com/p/81120952） kubectl apply -f calico.yaml iptables -P FORWARD ACCEPT 若机器存在多网卡出口，在 calico.yaml 中增加如下配置选择出主机网卡\n验证所有跨主机 pod 通讯没问题再继续。  kube-proxy 开启 ipvs kubectl get configmap kube-proxy -n kube-system -o yaml \u0026gt; kube-proxy-configmap.yaml sed -i \u0026#39;s/mode: \u0026#34;\u0026#34;/mode: \u0026#34;ipvs\u0026#34;/\u0026#39; kube-proxy-configmap.yaml kubectl apply -f kube-proxy-configmap.yaml rm -f kube-proxy-configmap.yaml kubectl get pod -n kube-system | grep kube-proxy | awk \u0026#39;{system(\u0026#34;kubectl delete pod \u0026#34;$1\u0026#34; -n kube-system\u0026#34;)}\u0026#39; Coredns 部署 clusterIP 需要在 service-cidr 内\napiVersion: v1 kind: ServiceAccount metadata: name: coredns namespace: kube-system --- apiVersion: rbac.authorization.k8s.io/v1beta1 kind: ClusterRole metadata: labels: kubernetes.io/bootstrapping: rbac-defaults name: system:coredns rules: - apiGroups: - \u0026#34;\u0026#34; resources: - endpoints - services - pods - namespaces verbs: - list - watch --- apiVersion: rbac.authorization.k8s.io/v1beta1 kind: ClusterRoleBinding metadata: annotations: rbac.authorization.kubernetes.io/autoupdate: \u0026#34;true\u0026#34; labels: kubernetes.io/bootstrapping: rbac-defaults name: system:coredns roleRef: apiGroup: rbac.authorization.k8s.io kind: ClusterRole name: system:coredns subjects: - kind: ServiceAccount name: coredns namespace: kube-system --- apiVersion: v1 kind: ConfigMap metadata: name: coredns namespace: kube-system data: Corefile: | .:53 { errors health kubernetes cluster.local in-addr.arpa ip6.arpa { pods insecure upstream fallthrough in-addr.arpa ip6.arpa } prometheus :9153 forward . /etc/resolv.conf cache 30 loop reload loadbalance } --- apiVersion: extensions/v1beta1 kind: Deployment metadata: name: coredns namespace: kube-system labels: k8s-app: kube-dns kubernetes.io/name: \u0026#34;CoreDNS\u0026#34; spec: replicas: 1 strategy: type: RollingUpdate rollingUpdate: maxUnavailable: 1 selector: matchLabels: k8s-app: kube-dns template: metadata: labels: k8s-app: kube-dns spec: serviceAccountName: coredns tolerations: - key: node-role.kubernetes.io/master effect: NoSchedule - key: \u0026#34;CriticalAddonsOnly\u0026#34; operator: \u0026#34;Exists\u0026#34; containers: - name: coredns image: coredns/coredns:1.6.3 imagePullPolicy: IfNotPresent resources: limits: memory: 170Mi requests: cpu: 100m memory: 70Mi args: [\u0026#34;-conf\u0026#34;, \u0026#34;/etc/coredns/Corefile\u0026#34;] volumeMounts: - name: config-volume mountPath: /etc/coredns readOnly: true ports: - containerPort: 53 name: dns protocol: UDP - containerPort: 53 name: dns-tcp protocol: TCP - containerPort: 9153 name: metrics protocol: TCP securityContext: allowPrivilegeEscalation: false capabilities: add: - NET_BIND_SERVICE drop: - all readOnlyRootFilesystem: true livenessProbe: httpGet: path: /health port: 8080 scheme: HTTP initialDelaySeconds: 60 timeoutSeconds: 5 successThreshold: 1 failureThreshold: 5 dnsPolicy: Default volumes: - name: config-volume configMap: name: coredns items: - key: Corefile path: Corefile --- apiVersion: v1 kind: Service metadata: name: kube-dns namespace: kube-system annotations: prometheus.io/port: \u0026#34;9153\u0026#34; prometheus.io/scrape: \u0026#34;true\u0026#34; labels: k8s-app: kube-dns kubernetes.io/cluster-service: \u0026#34;true\u0026#34; kubernetes.io/name: \u0026#34;CoreDNS\u0026#34; spec: selector: k8s-app: kube-dns clusterIP: 10.240.0.2 ports: - name: dns port: 53 protocol: UDP - name: dns-tcp port: 53 protocol: TCP 安装 nvidia-device-plugin apiVersion: extensions/v1beta1 kind: DaemonSet metadata: name: nvidia-device-plugin-daemonset namespace: kube-system spec: updateStrategy: type: RollingUpdate template: metadata: # Mark this pod as a critical add-on; when enabled, the critical add-on scheduler # reserves resources for critical add-on pods so that they can be rescheduled after # a failure. This annotation works in tandem with the toleration below. annotations: scheduler.alpha.kubernetes.io/critical-pod: \u0026#34;\u0026#34; labels: name: nvidia-device-plugin-ds spec: tolerations: # Allow this pod to be rescheduled while the node is in \u0026#34;critical add-ons only\u0026#34; mode. # This, along with the annotation above marks this pod as a critical add-on. - key: CriticalAddonsOnly operator: Exists - key: nvidia.com/gpu operator: Exists effect: NoSchedule containers: - image: nvidia/k8s-device-plugin:1.11 name: nvidia-device-plugin-ctr securityContext: allowPrivilegeEscalation: false capabilities: drop: [\u0026#34;ALL\u0026#34;] volumeMounts: - name: device-plugin mountPath: /var/lib/kubelet/device-plugins volumes: - name: device-plugin hostPath: path: /var/lib/kubelet/device-plugins "});index.add({'id':140,'href':'/note/docs/live/diary/2020/04/02/','title':"2020-04-02",'content':"2020 年 4 月 2 日（星期四） 今日待办     编程 Istio 安装 minikube minikube start --image-mirror-country='cn' --registry-mirror=https://registry.docker-cn.com\n安装 istio istioctl manifest apply --set profile=demo kubectl label namespace default istio-injection=enabled 参考：https://istio.io/docs/setup/getting-started/\n运行 Bookinfo sample application kubectl apply -f samples/bookinfo/platform/kube/bookinfo.yaml kubectl get services 一切顺利，输出 service list。\n过了一会，报错，连不上 server\nThe connection to the server 192.168.99.100:8443 was refused - did you specify the right host or port? minikube status minikube start --image-mirror-country=\u0026#39;cn\u0026#39; --registry-mirror=https://registry.docker-cn.com 解决 连不上 server 删除： minikube delete\n重新 start\n 过一会又出现错误\nThe connection to the server 192.168.99.101:8443 was refused - did you specify the right host or port? 还是切换会 Docker Desktop 版本的 Kubernetes 吧。。。\n使用 gotok8s/k8s-docker-desktop-for-mac 原理：\n利用 GitHub Actions 实现 k8s.gcr.io 上 kubernetes 依赖镜像自动同步到 Docker Hub 上指定的仓库中。 通过 load_images.sh 将所需镜像从 Docker Hub 的同步仓库中取回，并重新打上原始的 tag。\n"});index.add({'id':141,'href':'/note/docs/live/diary/2020/06/02/','title':"2020-06-02",'content':"2020 年 6 月 2 日（星期二） 今日待办     编程 shell keyword vs reserved word vs builtin reserved word 保留字\nKeyword, reserved word, and builtin are all the \u0026ldquo;first word\u0026rdquo; of a Simple command. Could be placed in two groups: Keyword and Builtin. The two are mutually exclusive.\nA word (token) can be either a Keyword or a builtin, but not both.\n为什么 time 是 keyword，而不是 builtin To allow the existence of a command as the second word.\n参考：\n Differences between keyword, reserved word, and builtin?  命令前加反斜杠 \\ Linux 在命令前加反斜杠 \\ 调用别名的原命令\n例如：\\ls 则直接调用 ls 的原始命令， 而不会使用 alias 设置的带有 color 选项的命令\n什么是 tty ls: aliased to ls --color=tty zsh 执行慢 调试 zsh zsh -xv ls 只查看目录\n$ ls -d */ Desktop/ pic/ shell/ src/ $ ls -F | grep \u0026#34;/$\u0026#34; Desktop/ pic/ shell/ src/ $ ls -l | grep \u0026#34;^d\u0026#34; drwxr-xr-x 2 root root 4096 2011-05-08 01:46 Desktop drwxr-xr-x 2 root root 4096 2012-03-26 10:03 pic drwxr-xr-x 2 root root 4096 2012-03-30 17:21 shell drwxr-xr-x 3 root root 4096 2012-03-22 22:18 src  Mysql 修改 Mysql 提示符 \\D: 完整的日期时间 \\u: 用户名 \\h: 服务器地址 \\d: 当前数据库\n当前链接有效 # 连接客户端时通过参数指定 mysql --prompt=\u0026#34;(\\u@\\h) [\\d]\u0026gt; \u0026#34; # 连接上客户端后，通过 prompt 命令修改 prompt (\\u@\\h) [\\d]\u0026gt; 所有链接都有效 # 在 MySQL 的配置文件中配置 [mysql] prompt=(\\\\u@\\\\h) [\\\\d]\u0026gt;\\\\_ # 通过环境变量配置 export MYSQL_PS1=\u0026#34;(\\u@\\h) [\\d]\u0026gt; \u0026#34; 参考：\n 修改 MySQL 客户端的提示符  Jetbrains 同步配置 参考：\n 官网 Share IDE settings  IntelliJ IDEA 配置文件存放的位置 MacOS ~/Library/Application Support/IntelliJIdeaXX contains the catalog with plugins.\n~/Library/Preferences/IntelliJIdeaXX contains the rest of the configuration settings.\n~/Library/Caches/IntelliJIdeaXX contains data caches, logs, local history, etc. These files can be quite significant in size.\n9.0+~/Library/Logs/IntelliJIdeaXX contains logs\nLinux ~/.IntelliJIdeaXX/config that contains user-specific settings.\n~/.IntelliJIdeaXX/system that stores IntelliJ IDEA data caches.\nWindows \u0026lt;User home\u0026gt;/.IntelliJIdeaXX\\config that contains user-specific settings.\n\u0026lt;User home\u0026gt;/.IntelliJIdeaXX\\system that stores IntelliJ IDEA data caches.\n\u0026lt;User home\u0026gt;/ in WindowsXP is C:\\Documents and Settings\u0026lt;User name\u0026gt;; in Windows Vista it is C:\\Users\u0026lt;User name\u0026gt;\\\n 参考：\n IntelliJ IDEA 配置文件存放的位置  MacOS 删除 idea 配置文件 $ rm -rf ~/Library/Preferences/Idea* $ rm -rf ~/Library/Caches/Idea* $ rm -rf ~/Library/Logs/Idea*  局域网 IP A 类 10.0.0.0/8\n10.0.0.0 - 10.255.255.255\nB 类 172.16.0.0/12\n172.16.0.0 - 172.31.255.255\nC 类 192.168.0.0/16\n192.168.0.0 - 192.168.255.255\n github add file to remote without cloning PUT /repos/:owner/:repo/contents/:path 参考：\n How do I add file to remote Git repo (Github) without cloning the whole repo first   Keyboard Maestro  Kubernetes Volumes subPath 同一个 volume 多次挂载 apiVersion: v1 kind: Pod metadata: name: my-lamp-site spec: containers: - name: mysql image: mysql env: - name: MYSQL_ROOT_PASSWORD value: \u0026#34;rootpasswd\u0026#34; volumeMounts: - mountPath: /var/lib/mysql name: site-data subPath: mysql - name: php image: php:7.0-apache volumeMounts: - mountPath: /var/www/html name: site-data subPath: html volumes: - name: site-data persistentVolumeClaim: claimName: my-lamp-site-data 插入而非覆盖 The volumeMounts.subPath property can be used to specify a sub-path inside the referenced volume instead of its root.\n指定 subPath 后就是插入，而不是覆盖\n举个例子：\n如果没有指定 subPath，挂载后，/usr/ 下面的文件都会被覆盖\napiVersion: v1 kind: ConfigMap metadata: name: busybox-cm labels: addonmanager.kubernetes.io/mode: EnsureExists data: Corefile: | .:53 { errors log stdout health kubernetes cluster.local 172.21.0.0/16 prometheus proxy . /etc/resolv.conf cache 30 } --- apiVersion: v1 kind: ReplicationController metadata: name: busybox-cm labels: app: busybox-cm spec: replicas: 1 selector: app: busybox-cm template: metadata: name: busybox-cm labels: app: busybox-cm spec: containers: - image: busybox command: - sleep - \u0026#34;3600\u0026#34; imagePullPolicy: IfNotPresent name: busybox volumeMounts: - name: config-volume mountPath: /usr/Corefile # 如果没有指定 subPath，挂载后，/usr/ 下面的文件都会被覆盖 subPath: Corefile restartPolicy: Always volumes: - name: config-volume configMap: name: busybox-cm items: - key: Corefile path: Corefile 参考：\n Kubernetes 官网 Volumes subPath 解决 cm 覆盖目录问题   fatedier/frp  Fast Reverse Proxy\nfrp 反向代理 内网穿透\nlazy-luo/smarGate  内网穿透，c++ 实现，无需公网 IP，小巧，易用，快速，安全，最好的多链路聚合（p2p+proxy）模式，不做之一\u0026hellip; 这才是你真正想要的内网穿透工具！\n官方命名为 “移动网关”，通过手机客户端将位于内网的服务端网络进行按需暴露，核心引擎采用 c++ 实现。\n用过花生壳、frp、nps、zerotier 等穿透工具，都需要映射到外网。 身边同事有过深刻的教训，使用 frp 暴漏 rdp 服务，最终身中勒索病毒。\n参考：\n 用过的最好的 P2P 穿透工具（非 frp/nps 之流）  "});index.add({'id':142,'href':'/note/docs/live/diary/2020/07/02/','title':"2020-07-02",'content':"2020 年 7 月 2 日（星期四） 今日待办     编程 软件设计原则  Don’t Repeat Yourself (DRY) Keep It Simple, Stupid (KISS) Program to an interface, not an implementation Command-Query Separation (CQS) – 命令 - 查询分离原则 You Ain’t Gonna Need It (YAGNI) Law of Demeter – 迪米特法则 面向对象的 S.O.L.I.D 原则 Common Closure Principle（CCP）– 共同封闭原则 Common Reuse Principle (CRP) – 共同重用原则 Hollywood Principle – 好莱坞原则 High Cohesion \u0026amp; Low/Loose coupling \u0026amp; – 高内聚， 低耦合 Convention over Configuration（CoC）– 惯例优于配置原则 Separation of Concerns (SoC) – 关注点分离 Design by Contract (DbC) – 契约式设计  参考：\n 一些软件设计的原则  "});index.add({'id':143,'href':'/note/docs/study/degree/','title':"4.3 学位",'content':"学位 学历与学位 我国目前标准的高等教育学历只分为专科、本科、硕士和博士四个层次，学位分为学士、硕士、博士三个层次。\n取得学士学位证书的，必须首先获得大学本科毕业证书， 而取得硕士学位或博士学位证书的，却不一定能够获得硕士研究生或博士研究生毕业证书。\n 学历  专科 本科 硕士 博士   学位  学士（必须先有本科学历） 硕士（同等学力申硕只有硕士学位，没有硕士学历） 博士    "});index.add({'id':144,'href':'/note/docs/study/degree/masters-degree/mba/emba/','title':"EMBA",'content':"EMBA Executive Master of Business Administration\nMBA 分类 "});index.add({'id':145,'href':'/note/docs/study/docs/note/gitbook/','title':"Gitbook",'content':"Gitbook gitbook serve serve 多个笔记本 \u0026ndash;port Port for server to listen on (Default is 4000)\n\u0026ndash;lrport Port for livereload server to listen on (Default is 35729)\nSo you can change both two ports and serve as many books as you want.\neg:\none:\ngitbook --lrport 35730 --port 4001 serve another:\ngitbook --lrport 35731 --port 4002 serve "});index.add({'id':146,'href':'/note/docs/study/degree/masters-degree/mba/','title':"MBA",'content':"MBA Master of Business Administration\nMBA 分类 问答  深圳有哪些 MBA？   第一梯队\n北大光华、北大汇丰、中山大学（岭南＆管院）、上交安泰、浙大\n第二梯队\n厦大、西交大、华中科大、武大、同济\n第三梯队\n北理、西北工业、中南、大连理工、山东大学、哈工大、兰州大学、华南理工、暨大\n第四梯队\n广东财经、汕头大学、华南师范、广州大学、广东工业、广东外语外贸、深圳大学\n "});index.add({'id':147,'href':'/note/docs/study/docs/tool/','title':"工具",'content':"工具 格式转换 富文本 -\u0026gt; markdown  euangoddard/clipboard2markdown  http://euangoddard.github.io/clipboard2markdown/    pandoc https://pandoc.org/\n"});index.add({'id':148,'href':'/note/docs/study/degree/masters-degree/','title':"硕士",'content':"硕士 硕士分类 学术硕士与专业硕士 学术硕士可以调剂到专业硕士，但专业硕士不能调剂到学术硕士\n 学术硕士  涵盖所有的专业方向 学制一般为 3 年 单导师制 可以通过自己的导师直接读博，不用参加全国统考   专业硕士  共计 40 个专业 学制一般为 2-3 年 双导师制 不能硕博连读或直博，需要参加全国统考    全日制与非全日制   全日制\n  非全日制（在职研究生）\n 同等学力申硕  直接入学   非全日制研究生  参加 1 月份全国统考       "});index.add({'id':149,'href':'/note/docs/study/book/social/','title':"社会科学",'content':"社会科学 "});index.add({'id':150,'href':'/note/docs/study/course/social/','title':"社会科学",'content':"社会科学 "});index.add({'id':151,'href':'/note/docs/social/','title':"第三部分 社会科学",'content':"社会科学 "});index.add({'id':152,'href':'/note/docs/social/economic/insurance/buy/','title':"购买",'content':"购买 从哪里购买 "});index.add({'id':153,'href':'/note/docs/live/diary/2020/06/01/','title':"2020-06-01",'content':"2020 年 6 月 1 日（星期一） 今日待办     编程 Jeecg-Boot zhangdaiscott/jeecg-boot 前后端分离架构：SpringBoot 2.x，Ant Design\u0026amp;Vue，Mybatis-plus，Shiro，JWT\njhipster jhipster/generator-jhipster JHipster is a development platform to quickly generate, develop, \u0026amp; deploy modern web applications \u0026amp; microservice architectures. https://www.jhipster.tech\nSELinux The SELinux stands for Security-Enhanced Linux where it is a linux kernel security module. It is enabled by default on most of the linux distribution that we use for servers like centOS. It provides enhanced security measurements. It gives you fine control over all programs and daemons on their activities like communicating with out side programs or controlling whether to establish a outside connections for a particular program.\nIt is always recommended to have SELinux enabled on a server to avoid common security glitches.\nTo query the current status of SELinux use the following commands\ngetenforce  enforcing - SELinux security policy is enforced. permissive - SELinux prints warnings instead of enforcing. disabled - No SELinux policy is loaded.  参考：\n How to enable or disable SELinux and check status on centOS  BaaS Blockchain as a Service\n区块链即服务\nBAAS 是对区块链底层协议的封装后，让开发者能够快速的建立属于自己的区块链。 BAAS 平台通常提供高度定制化的底层区块链系统，隐私保护算法，每个平台都有其各自的特性。 BAAS 平台一般只提供联盟链和私有链的快速搭建，与公链协议不同，往往缺少内生额激励机制。 BAAS 主要是简化了部署的环节。\nBAAS 服务最早由 IBM、微软在 2015 年推出，之后谷歌也在 2016 年开始跟进。 BAAS 即从他们的云服务中开辟出以一个算力，来运行区块链节点， 并通过提供开发者环境和开发工具，帮助开发者更容易地开发区块链应用。\nLinux Linux centos 重启命令 1、reboot 2、shutdown -r now 立刻重启 (root 用户使用) 3、shutdown -r 10 过 10 分钟自动重启 (root 用户使用) 4、shutdown -r 20:35 在时间为 20:35 时候重启 (root 用户使用) 如果是通过 shutdown 命令设置重启的话，可以用 shutdown -c 命令取消重启\nLinux centos 关机命令 1、halt 立刻关机 2、poweroff 立刻关机 3、shutdown -h now 立刻关机 (root 用户使用) 4、shutdown -h 10 10 分钟后自动关机\n如果是通过 shutdown 命令设置关机的话，可以用 shutdown -c 命令取消重启\n apache/geode  Apache Geode is a data management platform that provides real-time, consistent access to data-intensive applications throughout widely distributed cloud architectures.\n一个分布式的，且支持低延迟、高并发的强一致分布式内存存储\n"});index.add({'id':154,'href':'/note/docs/live/diary/2020/07/01/','title':"2020-07-01",'content':"2020 年 7 月 1 日（星期三） 今日待办     编程 SIP BYE vs CANCEL For short, BYE is used when the callee already pick up the phone and talk for a while, otherwise, CANCEL takes place.\n参考：\n Introduction to SIP BYE, CANCEL and hop-by-hop messages [video]understanding difference between sip bye \u0026amp; cancel request   作用域  局部变量  在 C 语言中局部变量，只有执行了才会分配存储空间，只要离开作用域就会自动释放，C 语言的局部变量存储在栈区 Go 语言局部变量的生命周期和 C 语言一样   全局变量  在 C 语言中全局变量，只要程序一启动就会分配存储空间，只有程序关闭才会释放存储空间，C 语言的全局变量存储在静态区 (数据区) Go 语言全局变量的生命周期和 C 语言一样     如何学习 Web 安全  一切的安全问题都体现在 “输入输出” 上，一切的安全问题都存在于 “数据流” 的整个过程中。\n 1. 如果在操作系统层上没处理好，比如 Linux 的 Bash 环境把 “特殊数据” 当做指令执行时，就产生了 OS 命令执行的安全问题，这段 “特殊数据” 可能长得如下这般： ; rm -rf /; 2. 如果在存储层的数据库中没处理好，数据库的 SQL 解析引擎把这个 “特殊数据” 当做指令执行时，就产生 SQL 注入这样的安全问题，这段 “特殊数据” 可能长得如下这般： ' union select user, pwd, 1, 2, 3, 4 from users-- 3. 如果在 Web 容器层如 nginx 中没处理好，nginx 把 “特殊数据” 当做指令执行时，可能会产生远程溢出、DoS 等各种安全问题，这段 “特殊数据” 可能长得如下这般： %c0.%c0./%c0.%c0./%c0.%c0./%c0.%c0./%20 4. 如果在 Web 开发框架或 Web 应用层中没处理好，把 “特殊数据” 当做指令执行时，可能会产生远程命令执行的安全问题，这段 “特殊数据” 可能长得如下这般： eval($_REQUEST['x']); 5. 如果在 Web 前端层中没处理好，浏览器的 JS 引擎把 “特殊数据” 当做指令执行时，可能会产生 XSS 跨站脚本的安全问题，这段 “特殊数据” 可能长得如下这般： '\u0026quot;\u0026gt;\u0026lt;script\u0026gt;alert(/cos is my hero./)\u0026lt;/script\u0026gt; ...  参考：\n 零基础如何学习 Web 安全？  "});index.add({'id':155,'href':'/note/docs/social/economic/','title':"3.4 经济",'content':"经济 "});index.add({'id':156,'href':'/note/docs/study/docs/','title':"4.4 文档",'content':"文档 "});index.add({'id':157,'href':'/note/docs/study/domain/product/','title':"产品",'content':"产品 "});index.add({'id':158,'href':'/note/docs/study/domain/company/','title':"公司",'content':"公司 "});index.add({'id':159,'href':'/note/docs/study/domain/company/company-history/','title':"公司历史",'content':"公司历史 "});index.add({'id':160,'href':'/note/docs/social/economic/insurance/claims/','title':"理赔",'content':"理赔 "});index.add({'id':161,'href':'/note/docs/study/domain/company/company-history/baidu/','title':"百度",'content':"百度  投资页面链接  例如：An industrial-grade RPC framework used throughout Baidu    组织架构 百度组建 “前向收费业务群组”，成立 “搜索业务群组”，分别由百度副总裁王湛和副总裁向海龙负责。\n2015-02-03  移动服务事业群（百度副总裁李明远、副总裁刘骏） 搜索业务群组（高级副总裁向海龙、副总裁王海峰） 新兴业务群组（总裁张亚勤、副总裁王湛） 互联网金融事业群（朱光）  2015 年初，百度进行了一次大调整：即 N 合三，基本按照业务的不同属性将多个事业群组、收购而来的公司、新兴业务划分到三大事业群：LBS 和移动云为主的移动服务事业群；移动搜索、大搜索、移动网盟业务为主的搜索业务群组；还有就是新兴业务群组。通过 “合” 百度 架构更加精简，不同事业群可更有效地整合其内部资源，决策权更多。同时，2015 年底，百度又 “裂变” 出一个新事业群即互联网金融事业群，形成四大事业群的基础架构。\n2018-12-18 百度云的首次调整始于 2018 年 12 月 18 日，彼时，百度智能云事业部（ACU）升级为智能云事业群组（ACG），将 AI To B 的业务与传统的云业务实现合并，这也被看做是百度 “云 + AI” 战略的最初形态，为百度智能云的快速成长在内部架构上划定了轨道，铺平了道路。五个月后，百度云迎来了第二次调整，即在 2019 年 4 月 11 日，百度云更名为百度智能云，在品牌层面进行升级，并开启了下一个三年发展规划，进一步确立了规模化做大 AI 智能产业的发展思路。对于百度智能云的品牌升级，尹世明表示，智能是百度云的 DNA，百度云品牌全面升级为百度智能云，将不限于 “+ 智能”，不止于 “智能 +”，通过打造更领先的底层技术 ABC+X、更全面的平台支持、更丰富的行业应用，持续输出百度领先于业界的 ABC 技术能力，用 AI 思维推动产业智能化。业内人士认为，百度智能云的新目标既承接了 ABC 战略，又在此前的打法上加入了规模化的目标。品牌全面升级之后的百度智能云，智能开始成为其最显著的标签，这个标签也正在被越来越多的人接受并认可。又过了五个月后，在 2019 年 9 月 2 日，百度 CEO 李彦宏在内部发出全员信，宣布 “云 + AI” 战略进一步升级，百度智能云总经理尹世明直接向集团首席技术官王海峰汇报，百度智能云与 CTO 体系实现高度协同。这次调整中的一个新变化是，尹世明直接向集团首席技术官王海峰汇报，在这次调整之前，ACG 由尹世明负责，向张亚勤汇报；TG 和 AIG 是王海峰直接负责。如此一来，百度智能云与百度 CTO 体系将高度协同。当时的变动中，还有一个人事变动背景是：2019 年 3 月张亚勤宣布 10 月退休。而本次的调整，则被解读为百度在加码产业智能化，为的是推动 AI 技术在产业中得到更进一步的应用。同时，虽然百度 AI 和云之前已经完成协同，但显示出可能并不仅仅是出于业务考量，本次调整进一步显示出，百度 AI 商业化不论是技术侧还是落地侧，都以百度 CTO 王海峰为领导，云与 AI 都纳入 CTO 体系。\n2019-09-02 为了将百度 AI 的领先能力更高效地向产业界输出，让百度成为引领人工智能工业化大生产的关键力量，公司决定进一步升级“云 + AI”战略，进一步提高百度智能云的战略地位。即日起，百度智能云与 CTO 体系高效融合，公司副总裁、百度智能云总经理尹世明携 ACG 团队向集团首席技术官王海峰汇报。\n2020-01-09 为进一步整合资源，发挥技术中台价值，提升业务支持效率，经公司研究决定，AI 技术平台体系（原 AIG）与基础技术体系（原 TG）整合为技术中台群组（TPG），定位于集团级技术中台建设与业务支持。\n AIG（百度人工智能体系）(CTO 王海峰)  = TPG (技术中台群组) + ACG (智能云事业群组) = AIG (AI 技术平台体系) + TG (基础技术体系) + ACG (百度智能云事业群组)    "});index.add({'id':162,'href':'/note/docs/study/','title':"第四部分 学习",'content':"学习 "});index.add({'id':163,'href':'/note/docs/study/domain/company/equity/','title':"股权",'content':"股权 股权设计 股权设计常见隐患 好的股权设计是什么样的？ 股权设计的关键原则 合伙人股权如何分配   要有领军人物，切忌平均分配\n  让 CEO（占有）大股东地位\n 五个创始人，每人拿出 5%的股权，5 个人一共拿出 25%，形成一个激励股权池。把这个激励股权池暂时转到 CEO 的名下，这样 CEO 金大持股 40%，现在的 25%加上之前持有的 15%，其他四个创始人每个人持股 15%，这样 CEO 金大成为大股东，形成了相对控股。    CEO 能否获得这 25%的股权，要看他是否真的承担起 CEO 的责任。\n 针对这 25%的股权设定五年的成熟期，每年成数 5%，而成熟的条件，是这个 CEO 还（是否）能继续承担 CEO 的责任。每年年初制定企业的发展规划，即是年初 CEO 对全体股东做出的业绩承诺，大家认可的今年完成的目标。一年结束，大家回顾这一年的业绩，对 CEO 的业绩进行评估。如果认为他不能胜任，可以解除他职务，选举新的人接任。    如果 CEO 被解除了管理权，对于还没有成熟的股权，则需要交出来。比如在两年后，金大被认为不再能胜任 CEO，他的（激励股权）已经成熟了 10%，剩下的 15%的股权将交出来用以激励接任的 CEO。\n  获得远超其他人股权比例的同时，也承担了巨大的责任。在日常的工作中，他是总负责人，其他人要听从他的安排；但在年终的股东会上，他要对公司的整个业绩负责，要对其它股东有所交代。\n  金字塔结构是最稳定的结构，灵魂人物是不可缺少的，承担主要责任的人，（就）应该拥有主要的权利，获得重要的利益。责、权、利三者对等，这就是公平。\n如何保护公司的控制权 什么算控股  公司法  67% 以上是绝对控股  通过重大事项   50% 以上是相对控股   会计学里  持股超过 50%就称之为“绝对控股”， 持股小于 50%，但处于第一大股东地位的，则被称为相对控股。 再扩展一点，只要能控制董事会的半数以上成员，就能控制公司。   现实  百度的李彦宏持股 22.4% 阿里巴巴的马云持股 7.8% 腾讯的马化腾持股 14.43% 他们都远远小于 50%，谁能说他们不是 BAT 的控制者？    如何做   要找不以控股为目的的股东。\n 什么样的投资人是不想做要公司的控制权呢？ 专业的投资基金，VC、PE 我们称之为财务投资人的，通常都以单纯的投资回报为目的 比如软银的孙正义持有阿里巴巴 34%的股权，远远高于马云，仍然心甘情愿的把公司交给马云去控制。  也有一些战略投资人，除了投资收益外，还会有其他与自己公司发展战略相对应的目的，甚至有的投资人直接就会讲，如果你发展的好，我未来想收购你。      制订合理的初始股权结构。\n 如果公司成立时的初始股权结构不合理，就象一个人的得了先天性的心脏病，想要在事后补救会困难千倍、百倍。合理的初始股权结构，就象一个金字塔，要有一个独大的控股权股东，当然具体数字要依每个公司的具体情况而定，但原则上控制股东的持股比例越高、结构越稳定。    一致行动人。\n 控股股东可以和持有一定股权的合伙人、关系密切的股东达成一致的行动关系，即在股东会的事项表决中，按照一致的意见或听从一个人的声音对投票。把分散的股权集合在一起，形成合力。成为一致行动人，可以共同签署一份一致行动协议，更重要的是，达成心理上的共识。雷军对金山公司的控制，就是通过一致行为的方式完成的。    通过多层公司结构，提高控制权。\n 比如唐僧师徒四人是一个项目公司的创始股东，一共持有公司 70%的股权。唐僧是主创始人，持股 50%，孙悟空持股 10%、八戒和沙僧各持股 5%，如来佛主、唐王李世民做为投资人，持有 40%的股权。现在，可以由唐僧师徒单独设立一个持股公司，把项目公司中的股权比例平移到持股公司中，即 50：10：5：5。唐僧在这家持股公司里持股超过 50%，是绝对控股的股东，通过这家持股公司，唐僧实际上掌握了项目公司 70%的股权，而且不用担心孙悟空他们会造反。    牛卡计划，也就是俗称的 AB 股制度。\n 把股权分成不同的类别，比如说分成 A 类和 B 类，一般来说，每一股股权都会有一份股东会上的表决权，但牛卡计划可以让某一类股权有多份表决权。比如 A 类股权每一股有 10 个表决权，而 B 类每一股持有一个表决权。这样，就等于把 A 类股权放大了 10 倍，持有这类股权的人一般都是企业的创始人或高管。比如 JD 商城，刘强东只持有 20%左右的股权，但他的每一股股权都有二十倍的表决权，所以刘强东在 JD 有着 80%以上的表决权，对公司的控制稳如泰山。但是，牛卡计划目前只有在美国的资本市场上可以使用，只有去美国上市才能用得上这个制度，在其他地方上市尚不能使用。    除了以上五个法宝，还有一些神奇的保护公司控制权的方式，比如阿里巴巴的合伙人制度，比如华为的虚拟股权制度，但这些方式突破常规，有其特殊的原因和历史背景，很难复制或大面部使用，这里就不予展开介绍了。\n  "});index.add({'id':164,'href':'/note/docs/study/domain/operate/','title':"运营",'content':"运营 "});index.add({'id':165,'href':'/note/docs/study/domain/product/requirement/','title':"需求",'content':"需求 需求又称为 user story，是从用户的角度描述的独立功能点。\n在敏捷中对一个需求的描述应当包括 3 个方面：\n As a\u0026hellip; (作为\u0026hellip;角色或岗位) I want\u0026hellip; (我想\u0026hellip;希望做什么) So that\u0026hellip; (以便\u0026hellip;达到什么目的或商业价值)  需求拆分时应该满足 INVEST 原则：\n I：Independent：独立的 N：Negotiable：可协商的 V：Valuable：有价值的 E：Estimate：可评估的 S：Small ：小粒度的 T：Testable：可测试的  评定需求优先级时可参考 MoSCoW 原则：\n Must：必须有 Should：应该有 Could：可有可无 Won\u0026rsquo;t：没有  "});index.add({'id':166,'href':'/note/docs/natural/computer/','title':"1.5 计算机",'content':"计算机 见：计算机学习笔记\n"});index.add({'id':167,'href':'/note/docs/humanities/music/','title':"2.5 音乐",'content':"音乐 "});index.add({'id':168,'href':'/note/docs/study/domain/','title':"4.5 领域",'content':"领域 "});index.add({'id':169,'href':'/note/docs/live/cook/','title':"5.5 下厨房",'content':"下厨房 "});index.add({'id':170,'href':'/note/docs/study/degree/doctorate/','title':"博士",'content':"博士 博士分类 "});index.add({'id':171,'href':'/note/docs/live/','title':"第五部分 生活",'content':"生活 "});index.add({'id':172,'href':'/note/docs/humanities/movie/','title':"2.7 电影",'content':"电影 "});index.add({'id':173,'href':'/note/docs/live/travel/','title':"5.9 旅行",'content':"旅行 "});index.add({'id':174,'href':'/note/docs/live/diary/2020/','title':"2020 年",'content':"2020 年 年度计划 2020 年读书计划  xxx xxx  2020 年观影计划  xxx xxx  2020 年旅行计划  xxx xxx   年度总结  "});index.add({'id':175,'href':'/note/docs/','title':"Docs",'content':""});})();